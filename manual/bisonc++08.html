<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<title> <div style="text-align: center"><strong >Bisonc++</strong> (Version 5.02.01) User Guide</div> </title>
<style type="text/css">
    figure {text-align: center;}
    img {vertical-align: center;}
</style>
</head>
<body text="#27408B" bgcolor="#FFFAF0">
<hr>
<ul>
    <li> <a href="bisonc++.html">Table of Contents</a>
    <li> <a href="bisonc++07.html">Previous Chapter</a>
    <li> <a href="bisonc++09.html">Next Chapter</a>
</ul>
<hr>
<a name="RECOVERY"></a><a name="l125"></a>
<h1 >Chapter 8: Error Recovery</h1>
    Usually it is not acceptable to have a program terminate on a parse
error. For example, a compiler should recover sufficiently to parse the rest
of the input file and check it for errors; a calculator should accept another
expression. Such errors violate the grammar for which the parser was
constructed and are called <em >syntactic errors</em>. Other types of errors are
called <em >semantical errors</em>: here the intended <em >meaning</em> of the language is
not observed. For example, a division by too small a numeric constant (e.g.,
0) may be detected by the parser <em >compile time</em>. In general, what <em >can</em> be
detected compile time should not left for the run-time to detect, and so the
parser should flag an error when it detects a division by a very small
numerical constant. <strong >Bisonc++</strong>'s parsers may detect both syntactic <em >and</em>
semantical errors. Syntactical errors are detected automatically, while
the parser performs its parsing-job, semantical errors must explicitly be
defined when the grammar is constructed. The following sections cover the way
<strong >Bisonc++</strong>'s parser may handle syntactic errors and semantical errors, respectively.
<p>
<a name="l126"></a>
<h2 >8.1: Syntactical Error Recovery</h2>
    In a simple interactive command parser where each input is one line, it
may be sufficient to allow <code >parse()</code> to return <code >PARSE_ABORT</code> on error and
have the caller ignore the rest of the input line when that happens (and then
call <code >parse()</code> again). But this is inadequate for a compiler, because it
forgets all the syntactic context leading up to the error. A syntactic error
deep within a function in the compiler input should not cause the compiler to
treat the following line like the beginning of a source file.
<p>
It is possible to specify how to recover from a syntactic error by
writing rules recognizing the special token <code >error</code>. This is a terminal
symbol that is always defined (it must <em >not</em> be declared) and is reserved
for error handling. The <strong >bisonc++</strong> parser generates an <code >error</code> token whenever a
syntactic error is detected; if a rule was provided recognizing this token
in the current context, the parse can continue. For example:
        <pre>
        
    statements:  
        // empty
    | 
        statements '\n'
    | 
        statements expression '\n'
    | 
        statements error '\n'
        
</pre>

    The fourth rule in this example says that an error followed by a newline
makes a valid addition to any <code >statements</code>.
<p>
What happens if a syntactic error occurs in the middle of an
<code >expression</code>?  The error recovery rule, interpreted strictly, applies to the
precise sequence of a <code >statements</code>, an error and a newline. If an error
occurs in the middle of an <code >expression</code>, there will probably be some
additional tokens and subexpressions on the parser's stack after the last
<code >statements</code>, and there will be tokens waiting to be read before the next
newline. So the rule is not applicable in the ordinary way.
<p>
<strong >bisonc++</strong>, however, can force the situation to fit the rule, by <em >discarding</em>
part of the semantic context and part of the input. When a (syntactic) error
occurs the parsing algorithm tries to recover from the error in the
following way: First it discards states from the stack until it encounters a
state in which the <code >error</code> token is acceptable (meaning that the
subexpressions already parsed are discarded, back to the last complete
<code >statements</code>). At this point the error token is shifted. Then, if the
available look-ahead token is not acceptable to be shifted next, the parser
continues to read tokens and to discard them until it finds a token which
<em >is</em> acceptable. I.e., a token which <em >can</em> follow an <code >error</code> token in
the current state. In this example, <strong >bisonc++</strong> reads and discards input until the
next newline was read so that the fourth rule can apply.
<p>
The choice of error rules in the grammar is a choice of strategies for
error recovery. A simple and useful strategy is simply to skip the rest of the
current input line or current statement if an error is detected:
        <pre>

    statement: 
        error ';'  // on error, skip until ';' is read 
        
</pre>

    Another useful recovery strategy is to recover to the matching
close-delimiter of an opening-delimiter that has already been
parsed. Otherwise the close-delimiter probably appears to be unmatched,
generating another, spurious error message:
        <pre>
    
    primary:  
        '(' expression ')'
    | 
        '(' error ')'
    |
        ...
    ;
        
</pre>

    Error recovery strategies are necessarily guesses. When they guess wrong,
one syntactic error often leads to another. In the above example, the error
recovery rule guesses that an error is caused by bad input within one
statement. Suppose that instead a spurious semicolon is inserted in the middle
of a valid statement. After the error recovery rule recovers from the first
error, another syntactic error will immediately be found, since the text
following the spurious semicolon is also an invalid statement.
<p>
To prevent an outpouring of error messages, the parser may be configured
in such a way that no error message are generated for another syntactic error
that happens shortly after the first. E.g., only after three consecutive input
tokens have been successfully shifted error messages may again be
generated. This configuration is currently not available in <strong >bisonc++</strong>'s parsers.
<p>
Note that rules using the <code >error</code> token may have actions, just as any
other rules can.
<p>
The token causing an error is re-analyzed immediately when an error
occurs. If this is unacceptable, then the member function <code >clearin()</code> may be
called to skip this token. The function can be called by any member function
of the Parser class. For example, suppose that on a parse error, an error
handling routine is called that advances the input stream to some point where
parsing should once again commence. The next symbol returned by the lexical
scanner is probably correct. The previous token ought to be discarded using
<code >clearin()</code>.
<p>
<a name="l127"></a>
<h3 >8.1.1: Error Recovery</h3>
    <strong >Bisonc++</strong> implements a simple error recovery mechanism. When the <code >lookup()</code>
function cannot find an action for the current token in the current state it
throws an <code >UNEXPECTED_TOKEN__</code> exception. 
<p>
This exception is caught by the parsing function, calling the
<code >errorRecovery()</code> member function. By default, this member function 
terminates the parsing process. The non-default recovery procedure is
available once an <code >error</code> token is used in a production rule. When the
parsing process throws <strong >UNEXPECTED_TOKEN__</strong> the recovery procedure is
started (i.e., it is started whenever a syntactical error is encountered or
<code >ERROR()</code> is called).
<p>
The recovery procedure consists of 
    <ul>
    <li> looking for the first state on the state-stack having an
error-production, followed by:
    <li> handling all state transitions that are possible without retrieving a
terminal token. 
    <li> then, in the state requiring a terminal token and starting
with the initial unexpected token (3) all subsequent terminal tokens are
ignored until a token is retrieved which is a continuation token in that
state.
    </ul>
<p>
If the error recovery procedure fails (i.e., if no acceptable token is
ever encountered) error recovery falls back to the default recovery
mode (i.e., the parsing process is terminated).
<p>
Not all syntactic errors are always reported: the option
<a href="bisonc++09.html#REQUIRED">--required-tokens</a> can be used to specify the minimum number of
tokens that must have been successfully processed before another syntactic
error is reported (and counted).
<p>
The option <a href="bisonc++09.html#ERRORVERBOSE">--error-verbose</a> may be specified to obtain the
contents of the state stack when a syntactic error is reported.
<p>
The example grammar may be provided with an <code >error</code> production rule:
        <pre>

    %token NR
    
    %left '+'
    
    %%
    
    start:
        start expr
    |
        // empty
    ;
    
    expr:
        error
    |
        NR
    |
        expr '+' expr
    ;
        
</pre>

    The resulting grammar has one additional state (handling the error
production) and one state in which the <code >ERR_ITEM</code> flag has been set. When
and error is encountered, this state obtains tokens until a token having a
valid continuation was received, after which normal processing continues. 
<p>
The following output from the <code >parse()</code> function, generated by <strong >bisonc++</strong> using the
<code >--debug</code> option illustrates error recovery for the above grammar, entering
the input 
        <pre>

    a
    3 + a
        
</pre>

<p>
The program defining the parser and calling the parsing member was:
    <pre >
#include "Parser.h"

int main()
{
    Parser parser;

    parser.parse();
}
</pre>

<p>
For this example the following implementation of the <code >lex()</code> member 
was used:
        <pre>

    int Parser::lex()
    {
        std::string word;
    
        std::cin &gt;&gt; word;
        if (std::cin.eof())
            return 0;
        if (isdigit(word[0]))
            return NR;
        
        return word[0];
    }
        
</pre>

<p>
<a name="l128"></a>
<h4 >8.1.1.1: Error recovery --debug output</h4>
<p>
<pre>

    parse(): Parsing starts
    push(state 0)
    ==
    lookup(0, `_UNDETERMINED_'): default reduction by rule 2
    executeAction(): of rule 2 ...
    ... action of rule 2 completed
    pop(0) from stack having size 1
    pop(): next state: 0, token: `start'
    reduce(): by rule 2 to N-terminal `start'
    ==
    lookup(0, `start'): shift 1 (`start' processed)
    push(state 1)
    ==
a
Syntax error
    nextToken(): using `a' (97)
    lookup(1, `a' (97)): Not found. Start error recovery.
    errorRecovery(): 1 error(s) so far. State = 1
    errorRecovery(): state 1 is an ERROR state
    lookup(1, `_error_'): shift 3 (`_error_' processed)
    push(state 3)
    lookup(3, `a' (97)): default reduction by rule 3
    pop(1) from stack having size 3
    pop(): next state: 1, token: `expr'
    reduce(): by rule 3 to N-terminal `expr'
    errorRecovery() REDUCE by rule 3, token = `expr'
    lookup(1, `expr'): shift 2 (`expr' processed)
    push(state 2)
    errorRecovery() SHIFT state 2, continue with `a' (97)
    lookup(2, `a' (97)): default reduction by rule 1
    pop(2) from stack having size 3
    pop(): next state: 0, token: `start'
    reduce(): by rule 1 to N-terminal `start'
    errorRecovery() REDUCE by rule 1, token = `start'
    lookup(0, `start'): shift 1 (`start' processed)
    push(state 1)
    errorRecovery() SHIFT state 1, continue with `a' (97)
    lookup(1, `a' (97)): Not found. Continue error recovery.
3+a
    nextToken(): using `NR'
    lookup(1, `NR'): shift 4 (`NR' processed)
    push(state 4)
    errorRecovery() SHIFT state 4, continue with `_UNDETERMINED_'
    errorRecovery() COMPLETED: next state 4, no token yet
    ==
    lookup(4, `_UNDETERMINED_'): default reduction by rule 4
    executeAction(): of rule 4 ...
    ... action of rule 4 completed
    pop(1) from stack having size 3
    pop(): next state: 1, token: `expr'
    reduce(): by rule 4 to N-terminal `expr'
    ==
    lookup(1, `expr'): shift 2 (`expr' processed)
    push(state 2)
    ==
[input terminated here]
    nextToken(): using `_EOF_'
    lookup(2, `_EOF_'): default reduction by rule 1
    executeAction(): of rule 1 ...
    ... action of rule 1 completed
    pop(2) from stack having size 3
    pop(): next state: 0, token: `start'
    reduce(): by rule 1 to N-terminal `start'
    ==
    lookup(0, `start'): shift 1 (`start' processed)
    push(state 1)
    ==
    lookup(1, `_EOF_'): ACCEPT
    ACCEPT(): Parsing successful
    parse(): returns 0
    
</pre>

<p>
<a name="l129"></a>
<h2 >8.2: Semantical Error Recovery</h2>
Semantical error recovery once again requires judgment on the part of the
grammar-writer. For example, an assignment expression may be syntactically
defined as
        <pre>

    expr '=' expr
        
</pre>

    The assignment operator's left-hand side must be a so-called
<em >lvalue</em>. An <em >lvalue</em> is simply an addressable location, like a variable's
identifier, a dereferenced pointer expression or some other
address-expression. The right-hand side is a so-called <em >rvalue</em>: this may be
any value: any expression will do.
<p>
A rule like the above leaves room for many different semantical errors:
    <ul>
    <li> Since the rule's LHS equals <code >expr</code>, <em >any</em> expression is accepted
by the parser. E.g.,
        <pre>

    3 = 12
        
</pre>

    So, the action associated with this rule should <em >check</em> whether the
expression's left-hand side is actually an lvalue. If not, a <em >semantical</em>
error should be reported;
    <li> In a typed language (like <strong >C++</strong>), not all assignments are
possible. E.g., it is not acceptable to assign a <strong >std:string</strong> value
to a <strong >double</strong> variable. When conflicting types are used, a <em >semantical</em>
error should be reported;
    <li> In a language requiring variables to be defined or declared before
they are used (like <strong >C++</strong>) the parser should check whether a variable is
actually defined or declared when it is used in an expression. If not, a
<em >semantical</em> error should be reported
    </ul>
    A parser that should be able to detect semantic errors normally uses a
counter counting the number of semantic errors, e.g., <code >size_t
d_nSemanticErrors</code>. It may be possible to test this counter's value once the
input has been parsed, calling <code >ABORT()</code> (see section <a href="bisonc++05.html#PRIVMEM">5.3</a>) if the
counter isn't zero anymore. When the grammar's start symbol itself has
multiple alternatives, it is probably easiest to augment the grammar with an
additional rule, becoming the augmented grammar's start symbol which simply
calls the former start symbol. For example, if <code >input</code> was the name of the
original start-symbol, augment the grammar as follows to ensure a
<strong >PARSE_ABORT</strong> return value of the <code >parse()</code> member when either syntactic
or semantical errors were detected:
        <pre>

    semantic_input:                 // new start-symbol
        input
        {
            if (d_nSemanticErrors)  // return PARSE_ABORT
                ABORT();            // on semantic errors too.
        }
        
</pre>

    Returning from the parser's <code >parse()</code> member the number of syntactic
and semantical errors could then be printed, whereupon the program might
terminate. 
<p>
<hr>
<ul>
    <li> <a href="bisonc++.html">Table of Contents</a>
    <li> <a href="bisonc++07.html">Previous Chapter</a>
    <li> <a href="bisonc++09.html">Next Chapter</a>
</ul>
<hr>
</body>
</html>
