<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<title> <div style="text-align: center"><strong >Bisonc++</strong> (Version 5.03.00) User Guide</div> </title>
<style type="text/css">
    figure {text-align: center;}
    img {vertical-align: center;}
</style>
</head>
<body text="#27408B" bgcolor="#FFFAF0">
<hr>
<ul>
    <li> <a href="bisonc++.html">Table of Contents</a>
    <li> <a href="bisonc++02.html">Next Chapter</a>
</ul>
<hr>
<a name="l1"></a>
<h1 >Chapter 1: Introduction</h1>
<strong >Bisonc++</strong> is a general-purpose parser generator converting grammar descriptions for
LALR(1) context-free grammars into <strong >C++</strong> classes whose members can parse
such grammars.  Once you are a proficient <strong >bisonc++</strong> user, you may use it to develop
a wide range of language parsers, from those used in simple desk calculators
to complex programming languages.
<p>
<strong >Bisonc++</strong> is highly comparable to the program bison++, written by Alain Coetmeur:
all properly-written bison++ grammars ought to be convertible to <strong >bisonc++</strong> grammars
requiring very little or no modifications.  Anyone familiar with bison++ or
its precursor, bison, should quickly be able to use <strong >bisonc++</strong> as well. <strong >Bisonc++</strong>
generates <strong >C++</strong> code, rather than <strong >C</strong> code, and so a fair knowledge of the
<strong >C++</strong> programming language is required before <strong >bisonc++</strong> can profitably be used.
<p>
This manual closely resembles <strong >bison</strong>(1)'s userguide. In fact, many sections
of that manual were copied straight into this manual. With <strong >bisonc++</strong> distributions
(both the full source distribution and the binary <code >.deb</code> distributions)
<strong >bison</strong>'s orginal manual is included in both <em >PostScript</em> and (converted
from the <code >texi</code> format) <code >HTML</code> format. Where necessary sections of the
original manual were adapted to <strong >bisonc++</strong>'s characteristics. Some sections were
removed, and some new sections were added to the current manual. Expect
upgrades of the manual to appear without further notice. Upgrades will be
announced in the manual's title.
<p>
The current manual starts with tutorial chapters that explain the basic
concepts of using <strong >bisonc++</strong> and use three examples illustrating some of the core
issues of LALR(1) grammars, each example building on the previous example
(where available).  If you don't know <strong >bisonc++</strong>, bison++ or bison, start by reading
these chapters.  Reference chapters follow describing specific aspects of <strong >bisonc++</strong>
in detail.
<p>
<strong >Bisonc++</strong> was designed and built by <a href="mailto:f.b.brokken@rug.nl">Frank
B. Brokken</a>. The program's first version was 
constructed between November 2004 and May 2005.
<p>
<a name="l2"></a>
<h2 >1.1: What's new in version 5.03.00</h2>
    If you're new to <strong >bisonc++</strong>, you can safely skip this section. If you used <strong >bisonc++</strong>
before, please note the following new and modified features:
    <ul>
    <li> New option/directive <code >stack_expansion</code> defining the number of
elements which are added to the semantic value stack when it's completely
full. By default room for 10 new elements are added.
<p>
<li> Polymorphic semantic values are accessed via <code >STYPE__</code> objects,
privately derived from <code >std::unique_ptr&lt;Base&gt;</code> objects. Inside the parser,
semantic values are not copied but only moved.
<p>
<li> When polymorphic semantic values are used default actions are
implemented as <code >$$ = std::move($1)</code>, thus preventing needless copies. In
combination with polymorphic values, however, default actions can frequently
be suppressed, slightly improving the efficency of the generated parser.
    </ul>
<p>
<hr>
<ul>
    <li> <a href="bisonc++.html">Table of Contents</a>
    <li> <a href="bisonc++02.html">Next Chapter</a>
</ul>
<hr>
</body>
</html>
