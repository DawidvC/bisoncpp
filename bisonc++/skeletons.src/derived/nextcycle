void \@::nextCycle__()
try
{
    if (s_state[d_state__]->d_type & REQ_TOKEN)
        nextToken();                // obtain next token


    int action = lookup(false);     // lookup d_token__ in d_state__

    if (action > 0)                 // SHIFT: push a new state
    {
        push__(action);
        popToken__();               // token processed

        if (d_recovery__ and d_terminalToken__)
        {
$insert 12 debug "errorRecovery() COMPLETED: next state " << action
            d_recovery__ = false;
            d_acceptedTokens__ = 0;
        }
        return;
    }

    if (action < 0)            // REDUCE: execute and pop.
    {
        if (not d_recovery__)
            executeAction(-action);
        else 
        {
            if (d_token__ != _UNDETERMINED_)
                pushToken__(d_token__);
$insert 12 debug "errorRecovery() REDUCE by rule " << -action << ", token = " << symbol__(d_token__)
        }
                                    // next token is the rule's LHS
        reduce__(s_productionInfo[-action]); 
        return;
    }

    if (d_recovery__)
        ABORT();
    else 
        ACCEPT();
}
catch (ErrorRecovery__)
{
    if (not d_recovery__)
        errorRecovery();
    else
    {
        if (d_token__ == _EOF_)
            ABORT();
        popToken__();               // skip the failing token
    }
}

