int \@::parse()
try 
{
    // The parsing algorithm:
    // Initially, state 0 is pushed on the stack, and d_token__ as well as
    // d_nextToken__ are initialized to _UNDETERMINED_. 
    //
    // Then, in an eternal loop:
    //
    //  1. If a state does not have REQ_TOKEN no token is assigned to
    //     d_token__. If the state has REQ_TOKEN, nextToken() is called to
    //      determine d_nextToken__ and d_token__ is set to
    //     d_nextToken__. nextToken() will not call lex() unless d_nextToken__
    //     is  _UNDETERMINED_. 
    //
    //  2. lookup() is called: 
    //     d_token__ is stored in the final element's d_token field of the
    //     state's SR_ array. 
    //
    //  3. The current token is looked up in the state's SR_ array
    //
    //  4. Depending on the result of the lookup() function the next state is
    //     shifted on the parser's stack, a reduction by some rule is applied,
    //     or the parsing function returns ACCEPT(). When a reduction is
    //     called for, any action that may have been defined for that
    //     reduction is executed.
    //
    //  5. An error occurs if d_token__ is not found, and the state has no
    //     default reduction. Error handling was described at the top of this
    //     file.

$insert 4 debug "parse(): Parsing starts"
    clearin();                              // initialize, push(0)

    while (true)
    {
$insert prompt
        nextCycle__();
    }


//        try
//        {
//            if (s_state[d_state__]->d_type & REQ_TOKEN)
//                nextToken();                // obtain next token
//
//
//            int action = lookup(false);     // lookup d_token__ in d_state__
//
//            if (action > 0)                 // SHIFT: push a new state
//            {
//                push__(action);
//                popToken__();               // token processed
//            }
//            else if (action < 0)            // REDUCE: execute and pop.
//            {
//                executeAction(-action);
//                                            // next token is the rule's LHS
//                reduce__(s_productionInfo[-action]); 
//            }
//            else 
//                ACCEPT();
//        }
//        catch (ErrorRecovery__)
//        {
//            errorRecovery();
//        }
//    }


}
catch (Return__ retValue)
{
$insert 4 debug "parse(): returns " << retValue
    return retValue;
}

