void \@::errorRecovery()
{
    // When an error has occurred, pop elements off the stack until the top
    // state has an error-item. If none is found, the default recovery
    // mode (which is to abort) is activated. 
    //
    // If EOF is encountered without being appropriate for the current state,
    // then the error recovery will fall back to the default recovery mode.
    // (i.e., parsing terminates)

    if (d_acceptedTokens__ >= d_requiredTokens__)// only generate an error-
    {                                           // message if enough tokens 
        ++d_nErrors__;                          // were accepted. Otherwise
        error("Syntax error");                  // simply skip input

$insert 8 errorverbose
    }

$insert 4 debug "errorRecovery(): " << d_nErrors__ << " error(s) so far. State = " << top__()

    // get the error state
    while (not (s_state[top__()][0].d_type & ERR_ITEM))
    {
$insert 8 debug "errorRecovery(): pop state " << top__()
        pop__();
    }
$insert 4 debug "errorRecovery(): state " << top__() << " is an ERROR state"

    // In the error state, lookup a token allowing us to proceed.
    // Continuation may be possible following multiple reductions,
    // but eventuall a shift will be used, requiring the retrieval of
    // a terminal token. If a retrieved token doesn't match, the catch below 
    // will ensure the next token is requested in the while(true) block
    // implemented below:

    int lastToken = d_token__;                  // give the unexpected token a
                                                // chance to be processed
                                                // again.

    pushToken__(_error_);                       // specify _error_ as next token
    push__(lookup(true));                       // push the error state

    d_token__ = lastToken;                      // reactivate the unexpected
                                                // token (we're now in an
                                                // ERROR state).

    d_recovery__ = true;

//     while (true)
//     {
//         try
//         {
//             if (s_state[d_state__]->d_type & REQ_TOKEN)
//                 nextToken();                    // obtain next token
//             
//             int action = lookup(true);
// 
//             if (action > 0)                 // push a new state
//             {
//                 push__(action);
//                 popToken__();
// $insert 16 debug "errorRecovery() SHIFT state " << action +
// $insert 16 debug ", continue with " << symbol__(d_token__)
// 
//                 if (d_terminalToken__)
//                 {
// $insert 20 debug "errorRecovery() COMPLETED: next state " +
// $insert 20 debug action << ", no token yet"
// 
//                     d_acceptedTokens__ = 0;
//                     return;
//                 }
//             }
//             else if (action < 0)
//             {
//                 // no actions executed on recovery but save an already 
//                 // available token:
//                 if (d_token__ != _UNDETERMINED_)
//                     pushToken__(d_token__);
//  
//                                             // next token is the rule's LHS
//                 reduce__(s_productionInfo[-action]); 
// $insert 16 debug "errorRecovery() REDUCE by rule " << -action +
// $insert 16 debug ", token = " << symbol__(d_token__)
//             }
//             else
//                 ABORT();                    // abort when accepting during
//                                             // error recovery
//         }
//         catch (...)
//         {
//             if (d_token__ == _EOF_)
//                 ABORT();                    // saw inappropriate _EOF_
//                       
//             popToken__();                   // failing token now skipped
//         }
//     }
}
