#!/bin/sh

export BISONCPP=../../../tmp/bin/bisonc++

example()
{
    cd $*
    echo --------------------------------
    cat doc
    echo
    
    bison -v grammar
    $BISONCPP -V --construction grammar > bisonc++.output

        
    find ./ -type f -not -name grammar -not -name doc \
                    -not -name grammar.output -not -name bisonc++.output \
                    -exec rm '{}' ';'

    echo "bisonc++: `grep Determined bisonc++.output`
--------------------------------
"
    cd ..
}

echo "
    This script feeds several grammars to both bison and bisonc++
With each grammar a summary of its results are shown, and you can select
whether or not to run the example. Each example is available in a separate
subdirectory, so you could also run one particular example. 

    From the various test directories, bisonc++ should be accessible as

                $BISONCPP

    If that's not true for you, consider changing the BISONCPP variable in
this script.

    Note that bison always defines one additional state compared with
bisonc++. Bison accepts its input in a separate state, whereas bisonc++
accepts when <EOF> is seen in combination with the reduction of the
the augmented grammar rule G* -> G . Bisonc++ will not execute an action here,
but that should be ok, since the grammar specification does not make G* -> G
visible, so no action can be associated with its reduction anyway.

"

echo Press Enter, else skip to run example 1, AHO Example 4.42, p. 231
read RUN
[ "$RUN" == "" ] && example aho4.42

echo Press Enter, else skip, to run example 2, a grammar having 2 R/R conflicts
read RUN
[ "$RUN" == "" ] && example rr2

echo Press Enter, else skip, to run example 3, the dangling-else problem
read RUN
[ "$RUN" == "" ] && example danglingelse





    
