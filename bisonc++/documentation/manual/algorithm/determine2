We will now determine the LA sets for the items of the states of the grammar
introduced at the beginning of this chapter. Its augmented grammar defines the
following production rules:
        verb(
    1.  start:      start expr
    2.  start:      // empty
    3.  expr:       NR
    4.  expr:       expr '+' expr
    5.  start_$:    start
        )
When analyzing this grammer, we found the following five states, consisting of 
several items and transitions (kernel items are marked with K following their
item indices). Next to the items, where applicable, the goto-table is shown:
the state to go to when the mentioned grammatical symbol has been recognized:
    verb(
State 0:                                    start
    0K:     start_$ ->  . start               1
    1:      start   ->  . start expr          1
    2:      start   ->  . 

State 1:                                    expr    NR
    0K:     start_$ ->  start  .         
    1K:     start   ->  start  . expr         2
    2:      expr    ->  . NR                         3
    3:      expr    ->  . expr '+' expr

State 2:                                     '+'
    0K:     start   -> start expr  .
    1K:     expr    -> expr  . '+' expr       4

State 3: 
    0K:     expr    -> NR  .

State 4:                                    expr    NR
    0K:     expr    -> expr '+'  . expr       5
    1:      expr    -> . NR                          3
    2:      expr    -> . expr '+'  expr       5

State 5:                                     '+'
    0K:     expr    -> expr '+' expr  .     
    1K:     expr    -> expr . '+' expr        4
    )
 
We'll use the notation (x,y) to refer to state x, item y. 
    
The LA sets of the items of state 0 are computed first. It has one kernel
item, so tt(distributeLAsetsOfItem(0)) is called:
    verb(
distributeLAsetsOfItem(0)
    0K:     start_$ ->  . start               1
    1:      start   ->  . start expr          1
    2:      start   ->  . 

State 1:                                    expr    NR
    0K:     start_$ ->  start  .         
    1K:     start   ->  start  . expr         2
    2:      expr    ->  . NR                         3
    3:      expr    ->  . expr '+' expr

State 2:                                     '+'
    0K:     start   -> start expr  .
    1K:     expr    -> expr  . '+' expr       4

State 3: 
    0K:     expr    -> NR  .

State 4:                                    expr    NR
    0K:     expr    -> expr '+'  . expr       5
    1:      expr    -> . NR                          3
    2:      expr    -> . expr '+'  expr       5

State 5:                                     '+'
    0K:     expr    -> expr '+' expr  .     
    1K:     expr    -> expr . '+' expr        4
    )
 
We'll use the notation (x,y) to refer to state x, item y. 
    
The LA sets of the items of state 0 are computed first. It has one kernel
item, so tt(distributeLAsetsOfItem(0)) is called:
    verb(
distributeLAsetsOfItem(0)
    0K:     start_$ ->  . start               1
    1:      start   ->  . start expr          1
    2:      start   ->  . 

State 1:                                    expr    NR
    0K:     start_$ ->  start  .         
    1K:     start   ->  start  . expr         2
    2:      expr    ->  . NR                         3
    3:      expr    ->  . expr '+' expr

State 2:                                     '+'
    0K:     start   -> start expr  .
    1K:     expr    -> expr  . '+' expr       4

State 3: 
    0K:     expr    -> NR  .

State 4:                                    expr    NR
    0K:     expr    -> expr '+'  . expr       5
    1:      expr    -> . NR                          3
    2:      expr    -> . expr '+'  expr       5

State 5:                                     '+'
    0K:     expr    -> expr '+' expr  .     
    1K:     expr    -> expr . '+' expr        4
    )
 
We'll use the notation (x,y) to refer to state x, item y. 
    
The LA sets of the items of state 0 are computed first. It has one kernel
item, so tt(distributeLAsetsOfItem(0)) is called:
    verb(
distributeLAsetsOfItem(0)
    0K:     start_$ ->  . start               1
    1:      start   ->  . start expr          1
    2:      start   ->  . 

State 1:                                    expr    NR
    0K:     start_$ ->  start  .         
    1K:     start   ->  start  . expr         2
    2:      expr    ->  . NR                         3
    3:      expr    ->  . expr '+' expr

State 2:                                     '+'
    0K:     start   -> start expr  .
    1K:     expr    -> expr  . '+' expr       4

State 3: 
    0K:     expr    -> NR  .

State 4:                                    expr    NR
    0K:     expr    -> expr '+'  . expr       5
    1:      expr    -> . NR                          3
    2:      expr    -> . expr '+'  expr       5

State 5:                                     '+'
    0K:     expr    -> expr '+' expr  .     
    1K:     expr    -> expr . '+' expr        4
    )
 
We'll use the notation (x,y) to refer to state x, item y. 
    
The LA sets of the items of state 0 are computed first. It has one kernel
item, so tt(distributeLAsetsOfItem(0)) is called (below, LA(x) indicates the
LA set of item 1, and {..} is used to specify the contents of a set of grammar
symbols):
    verb(
distributeLAsetsOfItem(0)
  start_$ -> . start:     LA: {$}, B: start, c: {}, so b: {$}
  items 1 and 2 refer to B (start) and are inspected:
  1: LA(1): {}: b contains unique elements. Therefore:
    LA(1) = {$}
    distributeLAsetsOfItem(1):
      start -> . start expr: LA: {$}, B: start, c: {expr}, so b: {NR}
      inspect items 1 and 2: they refer to B (start):
      1: LA(1): {}: b contains unique elements. Therefore:
        LA{1) = {$,NR}
        distributeLAsetsOfItem(1)
          start -> . start expr: LA: {$,NR}, B: start, c: {expr}, so b: {NR}
          inspect items 1 and 2: they refer to B (start):
          1: LA(1): {$,NR}, so b does not contain unique elements
          2: LA(2): {}, b contains unique elements
            LA(2) = {NR}
            distributeLAsetsOfItem(2)
            start -> .: LA: {NR}, B: -, c: {}, so b: {NR}
            inspect items 1 and 2: they refer to B (start):
              1: LA(1): {$,NR}, b does not contain unique elements
              2: LA(2): {NR}, so b does not contain unique elements
      2: LA(2): {NR}, so b does not contain unique elements
  2: LA(2): {NR}: b contains unique elements. Therefore:
    LA{2) = {$,NR}
    distributeLAsetsOfItem(2)
    start -> .: LA: {$,NR}, B: -, c: {}
    B empty, so return.

    

set tt($):
    verb(
    0K:     start_$ ->  . start         LA: $
    )
 Next, we compute the LA sets of state 0 (computeLAsetsOfState(0)). To do so,
the LA sets of the items of state 0. There is one kernel item (item 0), so the
LA set of item 0 is distributed (distributeLASetOfItem(0)):
    verb(
     start_$ ->  . start        LA: $
matching:      a .   B   c

b = FIRST(c) = e
    )
 Since b is empty, the item's own LA set is added to b, so b = $.  The above
steps can be summarized using the following line:
    verb(
               a .   B   c        B      LA  1st(c)  b      0
     start_$ ->  . start        start     $    e     $
    )
 The 0 at the end of the first line provides recursion information: the number
of values represents the recursion depth, the leftmost value represents the
index of the item whose LA set is being distributed.  Similar summaries are
used below.

The LA set of item (0,1) is empty, so $ is added to it, followed by
distributing the LA set of item (0,1):
    verb(
               a .   B    c       B      LA  1st(c)  b
     start   ->  . start expr   start     $    NR    NR     1,0
    )
 As item 0's LA set is $, element NR is now added to it:
    verb(
               a .   B   c        B      LA    1st(c)  b      0,1,0
     start_$ ->  . start        start    $,NR    e     $
    )

                    





State 0:                                L b
    0K:     start_$ ->  . start         $ $ 
                                            L b
    1:      start   ->  . start expr        $
    2:      start   ->  .                   $


dist(0)
    L = $, B = start, b = $: handle 1 {}, 2 {}
    1:
        add b to LA-1: L = $
        dist(1)
            L = $, B: expr, b = NR: handle 1 {$}, 2 {}
            1:
                add NR to LA-1: L = $,NR
                dist(1)
                    L = $,NR, B: expr, b = NR: handle 1 {$,NR}, 2 {}
                    1:  no new items

                    2: 
                        add $,NR to LA-2: L = $,NR
                        dist(2)
                
