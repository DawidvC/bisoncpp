Once the items of all the grammar's states have been determined the LA sets
for the states' items are computed. Starting from the LA set of the kernel
item of state 0 (representing the augmented grammar's production rule as
tt(S_$: . S), where tt(S) is the grammar's start rule) the LA sets of all
items of all of the grammar's states are determined. By definition, the LA set
of state 0's kernel item equals tt($), representing end-of-file. 

Here is the algorithm computing the LA sets of all the states' items. The
computation starts from function tt(State::determineLAsets), which
is called for state 0.

The LA sets of the items of a state are computed first. Once they have been
computed, the LA sets of items from where transitions to other states are
possible are then propagated to the matching kernel items of those destination
states. When the LA sets of kernel items of those destination states are
enlarged then their state indices are added to a set tt(todo). LA sets of the
items of states whose indices are stored in the tt(todo) set are (re)computed
(by calling tt(determineLAsets) for those states) until tt(todo) is empty, at
which point all LA sets have been computed. Initially tt(todo) only contains
0, the index of the initial state, representing the augmented grammar's
production rule.

Starting from the LA sets of its kernel items the LA sets of the state's items
are computed, . The LA set of each kernel item is distributed (by the member
tt(State::distributeLAsetOf)) over the items which are implied by the item
being considered. E.g., for item tt(X: a . Y z), where tt(a) and tt(z) are any
sequence of grammar symbols and tt(X) and tt(Y) are non-terminal symbols, all
of tt(Y's) production rules are added as new items to the current state.

The member tt(distributeLAsetOfItem(idx)) matches the item's rule
specification with the specification tt(a.Bc), where tt(a) and tt(c) are
(possibly empty) sequences of grammatical symbols, and tt(B) is a (possibly
empty) non-terminal symbol appearing immediately to the right of the item's
dot position. if tt(B) is empty then there are no additional production rules
and tt(distributeLAsetOf) may return. Otherwise, the set tt(b = FIRST(c)) is
computed. This set holds all symbols which may follow tt(B). If tt(b) contains
epsilon() (i.e., the element representing the empty set), then the currently
defined LA set of the item can also be observed. In that case epsilon() is
removed, and the currently defined LA set is added to tt(b). Finally, the LA
sets of all items representing a production rule for tt(B) are inspected: if
tt(b) contains unique elements compared to the LA sets of these items, then
the unique elements of tt(b) are added to those items' LA sets and
tt(distributeLAsetOfItem) is recursively called for those items whose LA sets
were enlarged.

Once the LA sets of the items of a state have been computed,
tt(inspectTransitions) is called to propagate the LA sets of items from where
transitions to other states are possible to the affected items of those other
(destination) states. The member tt(inspectTransitions) inspects all tt(Next)
objects of the current state's tt(d_nextVector). Next objects provide
    itemization(
    it()  the state index of a state to transfer to from the current state;
    it() a size_t vector of item transitions. Each element is the index of an
        item in the current state (the source-item), its index is the index
        of a (kernel) item of the state to transfer to (the destination
        index). 
    )
If the LA set of the destination item can be enlarged from the LA set of
the source item then the LA sets of the destination state's items
must be recomputed. This is realized by inserting the destation
state's index into the `todo' set.


As an illustration of an LA-set computation we will now compute the LA sets
for the items of the states of the grammar introduced at the beginning of this
chapter. Its augmented grammar defines the following production rules:
        verb(
    1.  start:      start expr
    2.  start:      // empty
    3.  expr:       NR
    4.  expr:       expr '+' expr
    5.  start_$:    start
        )
When analyzing this grammer, we found the following five states, consisting of 
several items and transitions (kernel items are marked with K following their
item indices). Next to the items, where applicable, the goto-table is shown:
the state to go to when the mentioned grammatical symbol has been recognized:
    verb(
                                            Goto table
                                            -----------
State 0:                                    start
    0K:     start_$ ->  . start               1
    1:      start   ->  . start expr          1
    2:      start   ->  . 

State 1:                                    expr    NR
    0K:     start_$ ->  start  .         
    1K:     start   ->  start  . expr         2
    2:      expr    ->  . NR                         3
    3:      expr    ->  . expr '+' expr

State 2:                                     '+'
    0K:     start   -> start expr  .
    1K:     expr    -> expr  . '+' expr       4

State 3: 
    0K:     expr    -> NR  .

State 4:                                    expr    NR
    0K:     expr    -> expr '+'  . expr       5
    1:      expr    -> . NR                          3
    2:      expr    -> . expr '+'  expr       5

State 5:                                     '+'
    0K:     expr    -> expr '+' expr  .     
    1K:     expr    -> expr . '+' expr        4
    )

Item 0 of state 0 by definition has LA symbol $, and LA computation therefore
always starts at item 0 of state 0. The interesting part of the LA set
computation is encountered in the recursive member tt(distributeLAsets): 
    verb(
distributeLAsetsOfItem(0)
  start_$ -> . start:     LA: {$}, B: start, c: {}, so b: {$}

  items 1 and 2 refer to production rules of B (start) and are inspected:

  1: LA(1): {}: b contains unique elements. Therefore: 
    LA(1) = {$}
    distributeLAsetsOfItem(1):
      start -> . start expr: LA: {$}, B: start, c: {expr}, so b: {NR}
      inspect items 1 and 2 as they refer to production rules of B (start):

      1: LA(1): {}: b contains unique elements. Therefore: 
        LA{1) = {$,NR}
        distributeLAsetsOfItem(1)
          start -> . start expr: LA: {$,NR}, B: start, c: {expr}, so b: {NR}
          inspect items 1 and 2 as they refer to prod. rules of B (start):

          1: LA(1): {$,NR}, so b does not contain unique elements: done

          2: LA(2): {}, b contains unique elements
            LA(2) = {NR}
            distributeLAsetsOfItem(2)
              start -> .: LA: {NR}, B: -, c: {}, so b: {NR}
              inspect items 1 and 2 as they refer to prod. rules of B (start):

              1: LA(1): {$,NR}, b does not contain unique elements: done

              2: LA(2): {NR}, so b does not contain unique elements: done

      2: LA(2): {NR}, so b does not contain unique elements: done

  2: LA(2): {NR}: b contains unique elements. Therefore:
    LA{2) = {$,NR}
    distributeLAsetsOfItem(2)
      start -> .: LA: {$,NR}, B: -, c: {}
      B empty, so return.
    )
So, item 0 has LA set tt({$}), items 1 and 2 have LA sets tt({$,NR}).

The next step involves propagating the LA sets to kernel items of the states
to where transitions are possible:
        itemization(
    it() Item 0, state 0 transits to item 0 state 1. Item 0 of state 1's
current LA set is empty, so it receives LA set tt({$}), and 1 (state 1's
index) is inserted into the tt(todo) set.
    it() Item 1, state 0 transits to item 1 state 1. Item 1 of state 1's
current LA set is empty, so it receives LA set tt({$,NR}), and 1 (state 1's
index) is inserted into the tt(todo) set.
        )

Following this LA set propagation the LA sets of all items of state 1 are
computed, which in turn is followed by LA propagation to other states (states
2 and 3), etc. etc.

In this grammar there are no transitions to the current state (i.e.,
transitions from state x to state x). If such transitions are encountered then
they can be ignored by tt(inspectTransitions) as the LA sets of the items of a
state have already be computed by the time tt(inspectTransitions) is called.



COMMENT(

    itemization(
    it() For each item in each state, b() determines the items whose LA sets
depend on that particular item.

To determine which items have LA set that depend on a particular item the
symbol following the item's dot position is inspected. If it's a nonterminal,
then all items whose LHSs are equal to that nonterminal depend on the item
being considered.

    Inspecting the states of our example grammar, using offsets (0-based) to
indicate their items, the following dependencies are observed:
        itemization(
        it() State 0: items 1 and 2 depend on items 0 and 1.
        it() State 1: items 2 and 3 depend on items 1 and 3.
        it() State 2: no dependencies
        it() State 3: no dependencies
        it() State 4: items 1 and 2 depend on items 0 and 2.
        it() State 5: no dependencies
        )

    it() Then, for each item it is determined what the next state will be if
that item is actually used in a transition. Items representing a reduction are
not considered here. This results in the following:
        itemization(
        it() State 0: items 0 and 1: transition to state 1
        it() State 1: items 1 and 3: transition to state 2; item 2: transition
                        to state 3
        it() State 2: item 1: transition to state 4
        it() State 3: no transitions
        it() State 4: items 1 and 2: transition to state 5; item 1: transition
                        to state 3
        it() State 5: item 1: transition to state 4
        )

    it() Next, LA propagation takes place: 
            itemization( 
            it() The LA set of the augmented start rule is initialized to
                tt($). All other LA sets are initiaized to an empty set.

            it() For each state all items are considered. Dependent items
                receive their LA sets from the items on which they depend
                (called their `parent item').

                The LA sets of the dependent items are equal to the tt(FIRST)
                set of the subrule of their parent items, starting at the
                symbol following their parent item's dot positions. 

            it() If a subrule's tt(FIRST) set contains tt(e), then that item's
                LA set is added to the subrule's LA set, removing the tt(e).

            it() If items depend on multiple parents, then the LA sets of
                those items are the union of the LA sets as determined for
                each of their parents.
            it() Once the LA sets of items in a state have been determined,
                then the LA sets of items transiting to other states are added
                to the LA sets of the corresponding kernel items in these
                other states (each item in an originating state only modifies
                one kernel item in a destination state).
            it() Since transitions may return to earlier states, determining
                LA sets is implemented as an iterative process, terminating
                when all LA sets have stabilized.
            )

        Applying the above algorithm to the example grammar we get:
        itemization(
        it() State 0:
            itemization(
            it() item 0: tt(start_$ ->  . start) LA: tt({$})nl()
                Add the LA set (tt({$})) to the items resulting from 
                the tt(start) productions nl()
                Next state from here: 1

            it() item 1: tt(start ->  . start expr) LA: tt({$})nl()
                Next state from here: 1

            it() item 2: tt(start ->  .) LA: tt({$})nl()

            it() From item 1: once again consider the tt(start) rules, adding
                fst(expr) tt(= {NR}) to the LA sets of those rules:
                itemization(
                it() item 1: tt(start ->  . start expr) LA: tt({$ NR})nl()
                it() item 2: tt(start ->  .) LA: tt({$ NR})nl()
                )
            )

        it() State 1:
            itemization(
            it() item 0: tt(start_$ -> start .) inherits LA: tt({$}) from item
                0, state 0. nl()

            it() item 1: tt(start -> start  . expr) inherits LA: tt({NR $})
                from item 1, state 0. nl()
                Add the LA set (tt({NR $})) to the items resulting from 
                the tt(expr) productions nl()
                Next state from here: 2

            it() item 2: tt(expr ->  . NR) LA: tt({NR $})nl()
                Next state from here: 3

            it() item 3: tt(expr ->  . expr '+' expr) LA: tt({NR $})nl()
                Next state from here: 2

            it() From item 2: once again consider the tt(expr) rules, adding
                fst('+') tt(= {'+'}) to the LA sets of those rules:
                itemization(
                it() item 2: tt(expr ->  . NR) LA: tt({+ NR $})nl()
                it() item 3: tt(expr ->  . expr '+' expr) LA: tt({+ NR $})nl()
                )
            )

        it() State 2:
            itemization(
            it() item 0: tt(start -> start expr  .) inherits LA: tt({NR $}) 
                from item 1, state 1. nl()
            it() item 1: tt(expr -> expr  . '+' expr) inherits LA: tt(+ NR $)
                from item 3, state 1.nl()
                Next state from here: 4
            )

        it() State 3:
            itemization(
            it() item 0: tt(expr -> NR  .) inherits LA: tt({+ NR $}) 
                from item 2, state 1.
            )

        it() State 4:
            itemization(
            it() item 0: tt(expr -> expr '+'  . expr) inherits LA: tt({+ NR
                $}) from item 2, state 2. nl()
                Add the LA set (tt({+ NR $})) to the items resulting from 
                the tt(expr) productions nl()
                Next state from here: 5
            it() item 1: tt(expr ->  . NR) LA: tt({+ NR $})nl()
                Next state from here: 3. Since item 0 in state 3 already has a
                LA set containing all elements of the current LA set, no
                further modifications need to be propagated.

            it() item 2: tt(expr ->  . expr '+' expr) LA: tt(+ NR $)nl()
                Next state from here: 5

            it() From item 2 all tt(expr) production rules need to be
                considered again. This time no LA sets change, so the LA sets
                of all items in this state have been determined.
            )

        it() State 5:
            itemization(
            it() item 0: tt(expr -> expr '+' expr  .) inherits LA: tt(+ NR $)
                from item 0, state 4
            it() item 1: tt(expr -> expr  . '+' expr) inherits LA: tt(+ NR $)
                from item 2, state 4. nl()
                Next state: 4. Since item 0 in state 4 already has a
                LA set containing all elements of the current LA set, no
                further modifications need to be propagated.
            )
        )
    )

    Once again, look at state 5. In this state, item 0 calls for a reduction
on tokens tt('+', NR) or tt(EOF). However, according to item 1 a em(shift)
must be performed when the next token is a tt('+'). This choice represents a
shift-reduce conflict which is reported by b() unless special actions are
taken. One of the actions is to tell b() what to do. A tt(%left) directive
tells b() to prefer a reduction over a shift when encountering a shift-reduce
conflict for the token(s) mentioned with the tt(%left) directive. Analogously,
a tt(%right) tells b() to perform a shift rather than a reduction. 

Since a tt(%left '+') was specified, b() drops the shift alternative, and a
listing of the grammar's construction process (using the option
tt(--construction)) shows for state 5:
        verb(
    State 5:
    0: [P4 3] expr -> expr '+' expr  .   { NR '+' <EOF> }  1, () -1
    1: [P4 1] expr -> expr  . '+' expr   { NR '+' <EOF> }  0, () 0
      0: 
      Reduce item(s): 0 
        )
    The shift action (implied by item 1) is not reported.

END)
