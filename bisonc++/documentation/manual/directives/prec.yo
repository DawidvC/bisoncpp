Syntax: bf(%prec) tt(token) 

    The construction bf(%prec) tt(token) may be used in production rules to
overrule the actual precedence of an operator in a particular production
rule. Well known is the construction
                verb(
    expression:
        '-' expression %prec UMINUS
        {
            ...
        }
                ) 
    Here, the default priority and precedence of the tt(`-') token as the
subtraction operator is overruled by the precedence and priority of the
tt(UMINUS) token, which is frequently defined as:
                verb(
    %right UMINUS
                )
    E.g., a list of arithmetic operators could consists of:
        verb(
    %left '+' '-'
    %left '*' '/' '%'
    %right UMINUS
        )
    giving tt(* /) and tt(%) a higher priority than tt(+) and tt(-),
ensuring at the same time that tt(UMINUS) is given both the highest priority
and a right-associativity.

In the above production rule the operator order would result in the
construction 
        verb(
    '-' expression
        )
    being evaluated from right to left, having a higher precedence than either
the multiplication or the addition operators.

The tt(%prec) operator can only be used in rules starting with an operator,
followed by a non-terminal, as it changes the configured precedence of the
rule's initial terminal.

tt(%prec) cannot be used to modify the precedence of rules defining postfix
operators such as tt(expression '!') for computing factorials. In those cases
priority and association for the operator must explicitly be defined.

Why is this? 

When a grammar is analyzed em(states) are constructed describing to which
point input has has been recognized. In the above example one of the states
looks like this:
        verb(
    (1)     expression -> '-' expression  . 
    (2)     expression -> expression  . '-' expression 
        )
    Here, the dot indicates to point to where the input has been
recognized. In this case there are two possibilities: (1) indicates that a
minus character and an expression have just been read, (2) indicates that the
parser has just recognized an expression, and that there is a minus character
waiting to be processed (presumably followed by another expression). At this
point the parser can either em(reduce) (1) to an expression, thus processing
the unary minus, em(or) it can continue the parsing, first processing the
binary minus operator. Common priority rules select (1), resulting in the
unary minus having a higher precedence than the binary minus. The tt(%prec)
specification explicitly associates the tt(UMINUS) priority and associativity
with (1), and so after recognizing `tt(- expression)' an expression is
recognized instead of continuing the parsing process at the waiting minus.

When instead of tt(expression -> '-' expression) the rule tt(expression ->
expression '-') is defined quite a different situation is encountered. In this
case one of the states becomes:
        verb(
    (1)     expr -> expr '-' expr  . 
    (2)     expr -> expr  . '-' expr 
    (3)     expr -> expr  . '-' 
        )
    The thing to note here is that items 2 and 3 represent, respectively, the
rule for the binary minus operator and the rule for something we might call
the `postfix minus operator'. Looking at the items in this state observe that
the operators in both cases are identical (both minuses), and since the
grammar is an LALR(1) type of grammar, the parser must decide what to do given
the next terminal token that's observed. When parsing input, it must make the
decision based on observed tokens, and so items (2) and (3) both cause a
transition to the same other state (e.g., the next one, in which the minus has
been recognized):
        verb(
    (1)     expr -> expr  '-' . expr 
    (2)     expr -> expr  '-' .
        )
    The important thing to note here is that a tt(%prec) specification here
cannot have an effect, because once the parser has been constructed the
decision about the state to transit to is always based on tokens, and not on
priority specifications that were used in the grammar definition.

Because of the above, tt(%prec) can only be used for production rules starting
with an operator (terminal token), which is followed by a non-terminal. When
bic() recognizes a tt(%prec) directive it will check that this is true,
and will report an error otherwise.








