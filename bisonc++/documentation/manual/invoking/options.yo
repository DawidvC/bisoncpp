    Where available, single letter options are listed between parentheses
following their associated long-option variants. Single letter options require
arguments if their associated long options require arguments as well.
    itemization(
    it() loption(analyze-only) (soption(A))nl()
           Only analyze the grammar. No files are (re)written. This option can
            be used to test the grammatical correctness of modification `in
            situ', without overwriting previously generated files. If the
            grammar contains syntactic errors only syntax analysis is 
            performed.
    it() label(PREINCLUDE) lsoption(baseclass-preinclude)(H)(header)nl()
           Use tt(header) as the pathname to the file preincluded in the
            parser's base-class header. This option is useful in situations
            where the base class header file refers to types which might not
            yet be known. E.g., with bf(%union) a bf(std::string *) field
            might be used. Since the class bf(std::string) might not yet be
            known to the compiler once it processes the base class header file
            we need a way to inform the compiler about these classes and
            types. The suggested procedure is to use a pre-include header file
            declaring the required types. By default tt(header) will be
            surrounded by double quotes (using, e.g., tt(#include "header")).
            When the argument is surrounded by pointed brackets
            tt(#include <header>) will be included. In the latter case,
            quotes might be required to escape interpretation by the shell
            (e.g., using tt(-H '<header>')).
    it() lsoption(baseclass-header)(b)(header)nl()
           Use tt(header) as the pathname of the file containing the parser's
            base class. This class defines, e.g., the parser's symbolic
            tokens. Defaults to the name of the parser class plus the suffix
            tt(base.h). It is generated, unless otherwise indicated (see
            bf(--no-baseclass-header) and bf(--dont-rewrite-baseclass-header)
            below).
    it() lsoption(baseclass-skeleton)(B)(skeleton)nl() 
           Use tt(skeleton) as the pathname of the file containing the
            skeleton of the parser's base class. Its filename defaults to
            tt(bisonc++base.h).
    it() lsoption(class-header)(c)(header)nl()
           Use tt(header) as the pathname of the file containing the parser
            class. Defaults to the name of the parser class plus the suffix
            tt(.h)
    it() lsoption(class-skeleton)(C)(skeleton)nl()
           Use tt(skeleton) as the pathname of the file containing the
            skeleton of the parser class. Its filename defaults to
            tt(bisonc++.h). The environment variable tt(BISON_SIMPLE_H)
            is not inspected anymore.
    it() loption(construction)nl() 
           This option may be specified to write details about the
            construction of the parsing tables to the standard output
            stream. This information is primarily useful for developers, and
            augments the information written to the verbose grammar output
            file, produced by the bf(--verbose) option.
    it() loption(debug)nl() 
           Provide tt(parse()) and its support functions with debugging code,
            showing the actual parsing process on the standard output
            stream. When included, the debugging output is active by default,
            but its activity may be controlled using the bf(setDebug(bool
            on-off)) member. Note that no tt(#ifdef DEBUG) macros are used
            anymore. By rerunning b()() without the bf(--debug) option an
            equivalent parser is generated not containing the debugging
            code. 
    it() label(ERRORVERBOSE) loption(error-verbose)nl()
           When a syntactic error is reported, the generated parse function
            will dump the parser's state stack to the standard output
            stream. The stack dump shows on separate lines a stack index
            followed by the state stored at the indicated stack element. The
            first stack element is the stack's top element.
    it() lsoption(filenames)(f)(filename)nl()
           Specify a filename to use for all files produced by b()(). 
            Specific options overriding particular filenames are also
            available (which then, in turn, overide the name specified by this
            option).
    it() loption(force-class-header)nl()
           By default the generated class header is not overwritten once it
            has been created. This option can be used to force the
            (re)writing of the file containing the parser's class.
    it() loption(force-implementation-header)nl()
           By default the generated implementation header is not overwritten
            once it has been created. This option can be used to force the
            (re)writing of the implementation header file.
    it() loption(help) (soption(h))nl()
            Write basic usage information to the standard output stream and
            terminate. 
    it() lsoption(implementation-header)(i)(header)nl()
           Use tt(header) as the pathname of the file containing the
            implementation header. Defaults to the name of the generated
            parser class plus the suffix tt(.ih). The implementation header
            should contain all directives and declarations em(only) used by
            the implementations of the parser's member functions. It is the
            only header file that is included by the source file containing
            tt(parse())'s implementation . User defined implementation of
            other class members may use the same convention, thus
            concentrating all directives and declarations that are required
            for the compilation of other source files belonging to the parser
            class in one header file.
    it() lsoption(implementation-skeleton)(I)(skeleton)nl()
           Use tt(skeleton) as the pathname of the file containing the
            skeleton of the implementation header. Its filename defaults to
            tt(bisonc++.ih).
    it() loption(include-only)nl()
           All grammar files will be concatenated to the standard output
            stream in their order of processing. Following this, b()
            terminates.
    it() loption(insert-stype)nl()
           This option is only effective if the bf(debug) option (or
            bf(%debug) directive has also been specified. When
            bf(insert-stype) has been specified the parsing function's debug
            output will also show selected semantic values. It should only be
            specified if objects or variables of the semantic value type
            bf(STYPE__) can be inserted into tt(ostreams).
    it() loption(lines) (soption(l))nl() 
           Put bf(#line) preprocessor directives in the file containing the
            parser's tt(parse()) function. By including this option the
            compiler and debuggers will associate errors with lines in your
            grammar specification file, rather than with the source file
            containing the tt(parse()) function itself.
    it() label(MAXDEPTH) laoption(max-inclusion-depth)(value)nl()
           Set the maximum number of nested grammar files. Defaults to 10.
    it() lsoption(namespace)(n)(namespace)nl()
           Define the parser base class, the paser class and the parser
            implentations in the namespace tt(namespace). By default
            no namespace is defined. If this options is used the
            implementation header will contain a commented out tt(using
            namespace) declaration for the requested namespace. 
    it() loption(no-baseclass-header)nl()
           Do not write the file containing the parser class' base class, even
            if that file doesn't yet exist. By default the file containing the
            parser's base class is (re)written each time b()() is called. Note
            that this option should normally be avoided, as the base class
            defines the symbolic terminal tokens that are returned by the
            lexical scanner. By suppressing the construction of this file any
            modification in these terminal tokens will not be communicated to
            the lexical scanner.
    it() loption(no-lines)nl() 
           Do not put bf(#line) preprocessor directives in the file containing
            the parser's tt(parse()) function. This option is primarily useful
            in combination with the bf(%lines) directive, to suppress that
            directive. It also overrides option bf(--lines), though.
    it() loption(no-parse-member)nl()
           Do not write the file containing the parser's predefined parser
            member functions, even if that file doesn't yet exist. By default
            the file containing the parser's tt(parse()) member function is
            (re)written each time b()() is called. Note that this option
            should normally be avoided, as this file contains parsing
            tables which are altered whenever the grammar definition is
            modified. 
    it() lsoption(parsefun-skeleton)(P)(skeleton)nl()
           Use tt(skeleton) as the pathname of the file containing the parsing
            member function's skeleton. Its filename defaults to
            tt(bisonc++.cc). The environment variable tt(BISON_SIMPLE) is not
            inspected anymore.
    it() lsoption(parsefun-source)(p)(source)nl()
           Define tt(source) as the name of the source file containing the
            parser member function tt(parse()). Defaults to tt(parse.cc).
    it() label(REQUIRED) laoption(required-tokens)(value)nl()
    Whenever a syntactic error is detected during the parsing process the next
few tokens that are received  by the parsing function may easily cause yet
another (spurious) syntactic error. The option tt(--required-tokens) (as well
as the directive tt(%requireed-tokens)) can be used to specify the number of
tokens that must have been successfully processed before the parsing function
reports another syntactic error. By default the number of required tokens is
initialized to 0.


    it() label(SCANOPT) lsoption(scanner)(s)(header)nl()
           Use tt(header) as the pathname to the file defining a class
            bf(Scanner), offering a member tt(int yylex()) producing the next
            token from the input stream to be analyzed by the parser generated
            by b()(). When this option is used the parser's member bf(int
            lex()) will be predefined as 
                verb(
    int lex()
    {
        return d_scanner.yylex();
    }
                )
           and an object tt(Scanner d_scanner) will be composed into the
            parser. The tt(d_scanner) object will be constructed using its
            default constructor. If another constructor is required, the
            parser class may be provided with an appropriate (overloaded)
            parser constructor after having constructed the default parser
            class header file using b()().  By default tt(header) will be
            surrounded by double quotes (using, e.g., tt(#include "header")).
            When the argument is surrounded by pointed brackets tt(#include
            <header>) will be included. In the latter case, quotes might be
            required to escape interpretation by the shell (e.g., using tt(-s
            '<header>')).
    it() loption(scanner-debug)nl() 
           Show de scanner's matched rules and returned tokens.
    it() loption(show-filenames)nl() 
           Write the names of the files that are generated to the 
            standard error stream.
    it() laoption(skeleton-directory)(directory)nl() 
           Specifies the directory containing the skeleton files to use. This
            option can be overridden by the specific skeleton-specifying
            options (tt(-B -C, -H,) and tt(-I)).
    it() loption(thread-safe)nl() 
            No static data are modified, making bisonc++ thread-safe.
    it() loption(usage)nl()
            Write basic usage information to the standard output stream and
            terminate. 
    it() loption(verbose) (soption(V))nl() 
           Write a file containing verbose descriptions of
            the parser states and what is done for each type of look-ahead
            token in that state.  This file also describes all conflicts
            detected in the grammar, both those resolved by operator
            precedence and those that remain unresolved.  By default it will
            not be created, but if requested it will receive the filename
            tt(<grammar>.output), where tt(<grammar>)
            is the name of the file containing the grammar definition (i.e,
            the file passed as argument to b()()).
    it() loption(version) (soption(v))nl()
            Display b()()'s version number and terminate.
    )
