The parser's tt(%stype) is tt(Semantic). For this illustrative
example the parser's grammar is a simple one expecting input according to the
following two rules:
        verb(
    rule:
        identifier '(' identifier ')' '\n'
    |
        identifier '=' int '\n'
    ;
        )
    
    The rules for tt(identifier) and tt(int) simply pass the text matched by
the scanner on to tt(Semantic::assign):
        verb(
    identifier:
        IDENTIFIER
        {
            $$.assign<TagType<Tag::TEXT>>(d_scanner.matched());
        }
    ;
    int:
        INT
        {
            $$.assign<TagType<Tag::INT>>(d_scanner.matched());
        }
    ;
        )

The rule's actions are also simple, echoing the received identifiers and
tt(int) values to tt(cout). Here is an example of such an action block:
        verb(
    identifier '(' identifier ')' '\n'
    {
          cout << $1 << " " << $3 << '\n';
    }
        )

So, in this example Bisonc++'s parser stores em(all) semantic values on its
semantic values stack, even though different tokens were returned by different
rules. At any time em(all) semantic values associated with previously
recognized tokens are available in the action block. Once the semantic value
stack is reduced, the tt(Semantic) class takes care of the proper destruction
of the objects pointed to by tt(Semantic)'s tt(shard_ptr) base class.




