Occasionally it is useful to insert an action block somewhere in the middle of
a production rule. These so-called mid-rule action blocks are comparable to
the usual action blocks, appearing at the end of production rules, but
mid-rule action blocks are executed before the parser has recognized the
production rule's components that follow them.

A mid-rule action block can refer to the components preceding it using tt($i),
but it may not (cannot) refer to subsequent components because it is executed
before they have been observed.

The mid-rule action block itself counts as one of the components of the
production rule. In the example shown below, tt(stmnt) can be referred to as
tt($6) in the final action block.

Mid-rule action blocks can also have semantic values. When using tt(%union) or
tt(%polymorphic) and a rule's nonterminal is associated with a union field or
polymorphic token, then mid-rule action blocks loose those associations. When
the tt($$, $$.) or tt($$->) shorthand notations appear in mid-action blocks of
production rules whose nonterminal is associated with a polymorphic type or
union field then a warning is issued that automatic type associations do not
apply. Using the tt(_$$) shorthand notation prevents the warning from being
issued. 

Here is an example from a hypothetical grammar, defining a tt(let) statement
that looks like `this:
        verb(
    let (variable) statement
        )
    Here, tt(variable) is the name of a variable that must only exists for the
tt(statement's) lifetime. To parse this construct, we must insert tt(variable)
into a symbol table before parsing tt(statement), and must remove it
afterward. Here is how it is done:
        verb(
    stmt:   
        LET '(' variable ')'
        {
            _$$.assign<SYMTAB>(pushSymtab());
            addVariable($3); 
        }
        stmt    
        { 
            $$ = $6;
            popSymtab($5); 
        }
        )
    As soon as `tt(let (variable))' has been recognized, the first action is
executed. It saves a copy of the current symbol table as the mid-rule's
semantic value, using the polymorphic tag tt(SYMTAB) (which could be
associated with, e.g., an tt(std::unordered_map)).  Then tt(addVariable)
receives the new variable's name, adding it to the current symbol table. Once
the first action is finished, the embedded statement (tt(stmt)) is
parsed. Note that the mid-rule action is component number 5, so `tt(stmt)' is
component number 6.

Once tt(statement) has been parsed, its semantic value is returned as the
semantic value of the production rule's nonterminal. Then the semantic value
from the earlier action is used to restore the former symbol table. This
removes the temporary tt(let)-variable from the list so that it won't appear
to exist while the rest of the program is parsed.

Defining mid-rule action blocks before a rule is completely recognized often
leads to conflicts since the parser must commit to a parse in order to execute
the action. For example, the following two rules, without mid-rule actions,
can coexist in a working parser because the parser can shift the open-brace
token and look at what follows before deciding whether there is a declaration
or not:
        verb(
    compound: 
        '{' declarations statements '}'
    | 
        '{' statements '}'
    ;
        )
    But when we add a mid-rule action as follows, the rules become
nonfunctional:
        verb(
    compound: 
        { 
            prepareForLocalVariables(); 
        }
        '{' declarations statements '}'
    | 
        '{' statements '}'
    ;
        )
    Now the parser is forced to decide whether to execute the mid-rule action
when it has read no farther than the open-brace. In other words, it must
commit to using one rule or the other, without sufficient information to do it
correctly. (The open-brace token is what is called the look-ahead token at
this time, since the parser is still deciding what to do about it. See section
ref(LOOKAHEAD).

You might think that the problem can be solved by putting identical actions
into the two rules, like this:
        verb(
        { 
            prepareForLocalVariables(); 
        }
        '{' declarations statements '}'
    | 
        { 
            prepareForLocalVariables(); 
        }
        '{' statements '}'
    ;
        )
    But this does not help, because b() em(never) parses the contents of
actions, and so it does em(not) realize that the two actions are identical.

    If the grammar is such that a declaration can be distinguished from a
statement by the first token (which is true in bf(C), but em(not) in bf(C++),
which allows statements and declarations to be mixed)), then one solution
is to put the action after the open-brace, like this:
        verb(
    compound: 
        '{'
        { 
            prepareForLocalVariables(); 
        }
        declarations statements '}'
    | 
        '{' statements '}'
    ;
        )
    Now the next token following a recognized tt('{') token would be either
the first tt(declarations) token or the first tt(statements) token, which
would in any case tell b() which rule to use, thus solving the problem.

Another (much used) solution is to bury the action inside a support
nonterminal symbol which recognizes the first block-open brace and performs
the required preparations:
        verb(
    openblock:
        '{'
        { 
            prepareForLocalVariables(); 
        }
    ;

    compound: 
            openblock declarations statements '}'
    | 
            openblock statements '}'
    ;
        )
    Now b() can execute the action in the rule for subroutine without
deciding which rule for compound it eventually uses. Note that the action
is now at the end of its rule. Any mid-rule action can be converted to an
end-of-rule action in this way, and this is what b() actually does to
implement mid-rule actions.

    By the way, note that in a language like bf(C++) the above construction is
obsolete anyway, since bf(C++) allows mid-block variable- and object
declarations. In bf(C++) a compound statement could be defined, e.g., as
follows:
        verb(
    stmnt_or_decl:
        declarations
    |
        pure_stmnt      // among which: compound_stmnt
    ;

    statements:
        // empty
    |
        statements stmnt_or_decl
    ;

    compound_stmnt:                 
        open_block statements '}'
    ;
        )
    Here, the tt(compound_stmnt) would begin with the necessary preparations
for local declarations, which would then have been completed by the time they
would really be needed by tt(declarations).

