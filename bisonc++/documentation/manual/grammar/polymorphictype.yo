    The tt(%type) directive associates (non-)terminals with semantic value
types.

When semantic values are associated with terminal tokens then it is the
responsibility of the lexical scanner to assign a properly typed value to the
parser's tt(STYPE__ d_val__) data member.

Non-terminals may be associated with polymorphic semantic values using 
tt(%type) directives. E.g., following
        verb(
    %polymorphic INT: int
    %type <INT> expr
        )
    the tt(expr) non-terminal returns tt(int) semantic values. In this case,
a rule like
        verb(
    expr:
        '-' expr
        {
            $$ = -$2;
        }
        )
    automatically associates $$ and $2 with tt(int) values. $$
represents an lvalue (representing the semantic value associated with the
tt(expr:) rule), while $2 represents the tt(int) semantic value associated
with the tt(expr) non-terminal in the production rule tt('-' expr) (an
rvalue).

    Semantic value types cannot be pre-associated with negative dollar indices
(like $-1). However, semantic value types can explicitly be specified (or
provided tt(%type) associations can be overruled) using the common
`$<type-identifier>$' or `$<type-identifier>nr' syntax. In this syntax tt(nr)
is a (positive or negative) number (like $2, $-1). In this type-overruling
syntax blanks cannot be used (so $<INT>$ is OK, $< INT >$ isn't.

Several combinations of type-associations and type specifications may be
encountered (index values are used as examples, they are non-negative unless
explicitly shown as negative values): 

itemization(
it() $-1: tt(%type) associations are ignored, and the semantic value type
    tt(STYPE__) is used instead. A warning is issued unless the
    tt(%negative-dollar-indices) directive was specified.
it() $<tag>-1: em(error): tt(<tag>) specifications are not allowed for negative
    dollar indices. 
)

center(
table(5)(cccll)(
    rowline()
    row(cells(5)($$ or $1 specifications (- indicates: not provided)))

    rowline()
    tr(%type<TAG>)($<tag>)(action:)

    rowline()

    tr(empty or STYPE__) (-)       (STYPE__ is used)
        columnline(3)(5)
    tr()        (STYPE__) (STYPE__ is used)
        columnline(3)(5)
    tr()        (id)      (if tt(id) is a defined tag:nl()
                                $<tag>$ or $<tag>1 represents 
                                the tag's type+nl() 
                            otherwise em(error) (using undefined tag tt(id)))
    rowline()

    tr((existing) tag)
                (-)       ($<tag>$ or $<tag>1 represents 
                                the tag's type+nl() )
        columnline(3)(5)
    tr()        (STYPE__) (STYPE__ is used)
        columnline(3)(5)
    tr()        (id)      (if tt(id) is a defined tag:nl()
                                $<tag>$ or $<tag>1 represents 
                                the tag's type+nl() 
                            otherwise em(error) (using undefined tag tt(id)))
    rowline()

    tr((undefined) tag)
                (-)       (em(error): tt(tag) undefined)
        columnline(3)(5)
    tr()        (STYPE__) (STYPE__ is used)
        columnline(3)(5)
    tr()        (id)      (if tt(id) is a defined tag:nl()
                                $<tag>$ or $<tag>1 represents 
                                the tag's type+nl() 
                            otherwise em(error) (using undefined tag tt(id)))

    rowline()

)
)

When using `$$.' or `$1.' default tags are not used. Instead, a
warning is issued that the default tag is ignored. This allows members of the
semantic value type (tt(STYPE__)) to be called explicitly. The default tag is
only ignored if there are no additional characters (e.g., blanks, closing
parentheses) between the dollar-expressions and the member selector
operator. Note that the opposite, ignoring default tag associations, is
accomplished using the $<STYPE__>$ and $<STYPE__>1 constructions.


