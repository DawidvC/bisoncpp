B() may generate code using polymorphic semantic values. The
approach discussed here is a direct result of an suggestion initially made by
Dallas A. Clement in September 2007. All sources of the example discussed
in this section are found in the lurl(poly) directory.

One may wonder why a tt(union) is still used by b() as bf(C++) offers
inherently superior approaches to combine multiple types in one type. The
bf(C++) way to do so is by defining a polymorphic base class and a series of
derived classes implementing the various exclusive data types. The tt(union)
approach is still supported by b() since it is supported by bf(bison)(1) and
bf(bison++); dropping the tt(union) would needlessly impede backward
compatibility.

The (preferred) alternative to using a tt(union), however, is to use a
polymorphic base class. Although it is possible to define your own polymorphic
semantic value classes, b() makes life easy by offering the tt(%polymorphic)
directive.

In the example program (cf. lurl(poly)) the types of the fields of a classic
tt(union), defining the various values that are handled by the parser are now
defined by classes derived from a polymorphic base class, generated by
bic(). In the example program two semantic value types are used: tt(int) and
tt(std::string). These (and potentially additional) types are specified using
the tt(%polymorphic) directive, which is discussed in the next section.



