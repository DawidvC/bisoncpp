Below the way Bisonc++ may use a polymorphic semantic value is discussed. The
approach discussed below is a direct result of an suggestion initially made by
Dallas A. Clement in September 2007. All sources of the example discussed
below are found in the lurl(poly) directory.

One may wonder why a tt(union) is still used by b() as bf(C++) offers
inherently superior approaches to combine multiple types in one type. The
bf(C++) way to do so is by defining a polymorphic base class and a series of
derived classes implementing the various exclusive data types. The tt(union)
approach is still supported by b() since it is supported by bf(bison)(1) and
bf(bison++); dropping the tt(union) would impede backward compatibility.

The alternative to using a tt(union) is to use a polymorphic base
class. Although it is possible to define your own polymorphic semantic value
classes, b() makes life easy by offering the tt(%polymorphic) directive.


In the example program (cf. lurl(poly)) 
The fields of a classical tt(union), defining the various values that are
handled by the parser are now defined by classes derived from the class
tt(Base). For example:
    itemization(
    it() Objects of the class tt(Int) contain tt(int) value values. Here is
its interface (and implementation):
    verbinclude(poly/int/int.h)

    it() Objects of the class tt(Text) contain text. These objects can be
used, e.g., to store the names of identifiers recognized by a lexical scanner.
Here is the interface of the class tt(Text):
    verbinclude(poly/text/text.h)
    )

Notice that tt(Base) can't be the parser's semantic value:
    itemization(
    it() a tt(Base) class object cannot contain derived class's data members. 
    it() it's not possible to define a tt(Base) reference as a semantic value,
        as vectors and other containers cannot store references.
    it() the semantic value should not be a pointer to a tt(Base)
        class. Although a pointer would offer programmers the benefits of the
        polymorphic nature of the tt(Base) class, it would also require them
        to keep track of memory used by tt(Base) objects, which would counter
        many of the benefits of using a polymorphic base class.
    )

However, a tt(std::shared_ptr<Base>) is perfectly suited for storing pointers
to objects of classes that were derived from tt(Base). Since tt(Base) is
provided with a virtual destructor the tt(shared_ptr) takes care of the proper
destruction of these dynamically allocated objects. But since the semantic
value should handle the functionality that is common among the derived
classes, the tt(shared_ptr) itself is used as a base class of the parser's
semantic value type, which is defined as the class tt(Semantic). Here is its
interface:
    verbinclude(poly/semantic/semantic.h)

tt(Semantic) is still a very light-weight class. The two types of derived
class objects can be assigned to tt(Semantic)'s tt(shared_ptr) via the
function tt(assign), using a little bit of template meta programming to avoid
run-time selections based on tt(Tag) values. tt(Semantic) also offers an
overloaded insertion operator, forwarding the insertion request to the objects
that are reached via its tt(shared_ptr).


