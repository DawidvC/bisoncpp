In most programs, you will need different data types for different kinds of
tokens and groupings. For example, a numeric constant may need type tt(int) or
tt(double), while a string needs type tt(std::string), and an identifier might
need a pointer to an entry in a symbol table.

To use more than one data type for semantic values in one parser, B()
offers the following feature:
    itemization(
    it() Specify the entire collection of possible data types, using a
tt(%union) directive (see section ref(COLLECTION)).
    it() Choose one of those types for each symbol (terminal or nonterminal)
for which semantic values are used. This is done for tokens with the
tt(%token) directive (see section ref(TOKTYPENAMES))
and for groupings with the tt(%type) directive (see section
ref(NONTERMS)).
    )
    This approach has the advantage that B() is able to enforce the
correct association between semantic types and rules and/or tokens, and that
B() is able to check the type-correctness of assignments to rule
results. It has the em(drawback) that tt(union) fields cannot contain
tt(class) objects as fields, and thus that such objects must be accessed
through pointers. So, if the semantic value of a textual token is returned in
tt(std::string) object, then the tt(union) should have a tt(std::string *)
field. Consequently, the programmer must take care to delete the memory
pointed to by the tt(string *) fields whenever these fields become
obsolete. However, this requirement is not too hard to meet, and so tt(union)
constructions containing pointers to class type objects are frequently used in
practice.
