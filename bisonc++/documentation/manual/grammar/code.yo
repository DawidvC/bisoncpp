A parser using polymorphic semantic values adds several classes to the
generated files. The majority of these are class templates, defined in
tt(parserbase.h); some of the additionally implemented code is added to the
tt(parse.cc) source file.

To minimize namespace pollution most of the additional code is contained in a
namespace of its own: tt(Meta__). If the tt(%namespace) directive was used
then tt(Meta__) is nested under the namespace declared by that directive. The
name tt(Meta__) provides a hint to the fact that much of the code implementing
polymorphic semantic values uses template meta programming.

bf(The enumeration 'enum class Tag__')

One notable exception to the above is the enumeration tt(Tag__). To simplify
its use it is declared outside of tt(Meta__) (but inside the tt(%namespace)
namespace, if provided). Its identifiers are the tags declared by the
tt(%polymorphic) directive. This is a strongly typed enumeration. The
tt(%weak-tags) directive can be used to declare a pre C++-11 standard `tt(enum
Tag__)'.

bf(The namespace Meta__)

Below, tt(DataType) refers to the semantic value's data type that is
associated with a tt(Tag__) identifier.

Several classes are defined in the namespace tt(Meta__). However, the really
import class is the class tt(SType), defining the interface to the various
semantic value types. The tt(SType) class becomes the parser's tt(STYPE__)
type. All operations related to semantic values are handled by this class. 

The class tt(SType) provides the following public interface:

includefile(stypeinterface)

bf(Additional Headers)

When using tt(%polymorphic) three additional header files are included by
tt(parserbase.h):
    itemization(
    itt(memory,) required for tt(std::shared_ptr);
    itt(stdexcept,) required for tt(std::logic_error);
    itt(type_traits,) required for the implementation of one of tt(SType)'s
         overloaded assignment operators.
    )
