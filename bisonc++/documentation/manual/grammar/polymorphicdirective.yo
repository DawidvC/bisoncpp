    When encountering the tt(%polymorphic) directive bic() generates a parser
using polymorphic semantic values. Each semantic value specification
consists of a em(tag), which is a bf(C++) identifier, and a bf(C++) type
definition.

Tags and type definitions are separated by colons, and multiple semantic
values specifications are separated by semicolons. The semicolon trailing the
final semantic value specification is optional.

The tt(%polymorphic) directive may be specified only once, and the
tt(%polymorphic, %stype) and tt(%union) directives are mutually exclusive.

Here is an example, defining three semantic values types: tt(int), 
tt(std::string) and tt(std::vector<double>):
        verb(
    %polymorphic INT: int; STRING: std::string; 
                 VECT: std::vector<double>
        )
    The identifier to the left of the colon is called the em(type-identifier),
and the type definition to the right of the colon is called the
em(type-definition). Types specified at the tt(%polymorphic) type-definitions
must be built-in types or class-type declarations. Since bic() version 4.12.00
the types no longer have to be default-constructible.

As the parser's generic semantic value type is called tt(STYPE__), and
functions called by the parser may return tt(STYPE__) values, production rules
can be associated with the generic tt(STYPE__) semantic type. To prevent
ambiguities the generic tt(STYPE__) type cannot be specified as a polymorphic
type. E.g., a specification like tt(GENERIC: STYPE__) cannot be used when
defining the tag/type pairs at the tt(%polymorphic) directive. However,
(non-)terminals em(may) be associated with the generic semantic type, using
the tt(%type<STYPE__>) directive. In the demo program a nonterminal tt(combi)
is defined like this:
        verb(
    combi:
        int
    |
        string
    ;
        )
    Here, the tt(int) nonterminal is associated with an tt(int) value type,
while tt(string) is associated with tt(std::string). Clearly, tt(combi) cannot
be both. But tt(combi) em(can) be associated with tt(STYPE__), in which case
the semantic values of tt(int) and tt(string) can be returned as tt(combi's)
semantic value. Nonterminals receiving tt(combi's) semantic value then have to
inspect the semantic value's tt(tag) to retrieve the value of the semantic
value's actual type. 
                

    When polymorphic type-names refer to types that have not yet been declared
by the parser's base class header, then these types must be declared in a
header file whose location is specified through the tt(%baseclass-preinclude)
directive (as these types are referred to in the generated tt(parserbase.h)
header file).
