When you run B(), you give it a B() grammar file as input. The
output, however, defines a bf(C++) em(class), in which several em(members)
have already been defined. Therefore, the em(output) of B() consists of
em(header files) and a bf(C++) source file, defining a member (tt(parse())
that parses the language described by the grammar. The class and its
implementation is called a B() em(parser class). Keep in mind that the
B() utility and the B() parser class are two distinct pieces of
software: the B() utility is a program whose output is the B()
parser class that becomes part of your program. 

More specifically, B() generates the following files from a B()
grammar file:
    itemization(
    it() A em(baseclass header), which can be included by em(lexical scanners)
(see below), primarily defining the em(lexical tokens) that the parser expects
the lexical scanner to return;
    it() A em(class header), defining the B() parser class interface;
    it() An em(implementation header), which is used to declare all entities
which are em(only) used by B()'s parser class em(implementation) (and not
required by the remaining parts of your program);
    it() The em(parsing member), actually performing the parsing of a
provided input according to the rules of the defined B() grammar (that
you, as B()'s user, defined).
    )

The job of the B() parsing member is to group tokens into groupings
according to the grammar rules--for example, to build identifiers and
operators into expressions. As it does this, it runs the actions for the
grammar rules it uses.

In bf(C++) the tokens should be produced by an object called the em(lexical
analyzer) or em(lexical scanner) that you must supply in some fashion (such as
by writing it in bf(C++)). The B() parsing member requests the next token from
the lexical analyzer each time it wants a new token. The parser itself doesn't
know what is "inside" the tokens (though their semantic values may reflect
this). Typically the lexical analyzer makes the tokens by parsing characters
of text, but B() does not depend on this. See section ref(LEX).

The B() parsing function is bf(C++) code which defines a function named
tt(parse()) which implements that grammar. This parsing function nor the
parser object for which it is called does not make a complete bf(C++) program:
you must supply some additional details. One is the lexical analyzer. The
parser class itself declares several more members which must be defined when
used. One of these additional members is an error-reporting function which the
parser calls to report an error. Simple default, yet sensible, implementations
for these additional members may be generated by B(). Having constructed
a parser class and a lexical scanner class, em(objects) of these classes must
be defined in a complete bf(C++) program. Usually such objects are defined in
a function called tt(main()); you have to provide this, and arrange for it to
call the parser's tt(parse()) function, or the parser will never run. See
chapter ref(INTERFACE).

Note that, different from conventions used by Bison and Bison++, there is no
special name convention requirement anymore imposed by B(). In
particular, there is em(no) need to begin all variable and function names used
in the B() parser with `yy' or `YY' anymore.



