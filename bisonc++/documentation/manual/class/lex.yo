    The bf(int lex()) private member function is called by the
bf(parse()) member to obtain the next lexical token. By default it is not
implemented, but the tt(%scanner) directive (see ref(SCANNER) may be used to
pre-implement a standard interface to a lexical analyzer. 

    The bf(lex()) member function interfaces to the lexical scanner, and it is
expected to return the next token produced by the lexical scanner. This token
may either be a plain character or it may be one of the symbolic tokens
defined in the bf(Parser::Tokens) enumeration. Any zero or negative token
value is interpreted as `end of input', causing tt(parse()) to return.

    The bf(lex()) member function may be implemented in various ways:
    itemization(
    it() bf(lex()) may itself implement a lexical analyzer (a
em(scanner)). This may actually be a useful option when the input offered to
the program using b()'s parser class is not overly complex. This approach was
used when implementing the earlier examples (see sections ref(RPNLEX) and 
ref(MFLEX)).
    it() bf(lex()) may call a external function or member function of class
implementing a lexical scanner, and return the information offered by this
external function. When using a class, an object of that class could also be
defined as additional data member of the parser (see the next
alternative). This approach can be followed when generating a lexical scanner
from a lexical scanner generating tool like bf(lex)(1) or bf(flex)(1). The
latter program allows its users to generate a scanner em(class).
    it() Since bf(flex)(1) is fairly often used as a tool to generate a
scanner (class), a standard interface for this situation is available with
b(): using the bf(scanner) option or directive (see section ref(SCANNER)) it
is assumed that a class bf(Scanner) is available, and that the parser should
have a data member tt(Scanner d_scanner). Furthermore, it is assumed that the
parser's bf(lex()) member merely has to return tt(d_scanner.yylex()).
    )
