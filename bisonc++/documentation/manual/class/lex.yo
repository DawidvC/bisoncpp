    The tt(int lex()) private member function is called by the tt(parse())
member to obtain the next lexical token. By default it is not implemented, but
the tt(%scanner) directive (see section ref(SCANNER)) may be used to
pre-implement a standard interface to a lexical analyzer.

    The tt(lex()) member function interfaces to the lexical scanner, and it is
expected to return the next token produced by the lexical scanner. This token
may either be a plain character or it may be one of the symbolic tokens
defined in the bf(Parser::Tokens) enumeration. Any zero or negative token
value is interpreted as `end of input', causing tt(parse()) to return.

    The tt(lex()) member function may be implemented in various ways:
    itemization(
    it() tt(lex()) may itself implement a lexical analyzer (a
em(scanner)). This may actually be a useful option when the input offered to
the program using b()'s parser class is not overly complex. This approach was
used when implementing the earlier examples (see sections ref(RPNLEX) and 
ref(MFLEX)).
    it() tt(lex()) may call a external function or member function of class
implementing a lexical scanner, and return the information offered by this
external function. When using a class, an object of that class could also be
defined as additional data member of the parser (see the next
alternative). This approach can be followed when generating a lexical scanner
from a lexical scanner generating tool like bf(lex)(1) or bf(flex)(1). The
latter program allows its users to generate a scanner em(class).
    it() Since bf(flex)(1) is fairly often used as a tool to generate a
scanner (class), a standard interface for this situation is available with
b(): using the bf(--scanner) option or bf(%scanner) directive (see section
ref(SCANNER)) it is assumed that a class bf(Scanner) is available. In this
case the parser receives a data member tt(Scanner d_scanner) and 
the parser's tt(lex()) member merely returns tt(d_scanner.yylex()).
    )
