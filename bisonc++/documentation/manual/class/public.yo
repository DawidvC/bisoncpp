
    The following public members and types can be used by users of the parser classes
generated by bic() (tt(`Parser Class'::) prefixes are silently implied):
    itemization(
    it() bf(LTYPE__):nl() 
           The parser's location type (user-definable). Available only when
            either tt(%lsp-needed, %ltype) or tt(%locationstruct) has been
            declared. 
    it() bf(STYPE__):nl()
            The parser's stack-type (user-definable), defaults to bf(int).
    it() bf(Tokens__):nl()
           The enumeration type of all the symbolic tokens defined in the
            grammar file (i.e., bic()'s input file). The scanner should be
            prepared to return these symbolic tokens Note that, since the
            symbolic tokens are defined in the parser's class and not in the
            scanner's class, the lexical scanner must prefix the parser's
            class name to the symbolic token names when they are
            returned. E.g., tt(return Parser::IDENT) should be used rather
            than tt(return IDENT).
    it() bf(int parse()):nl()
           The parser's parsing member function. It returns 0 when parsing has
            completed successfully, 1 if errors were encountered while parsing
            the input.
    it() bf(void setDebug(bool mode)):nl()
       This member can be used to activate or deactivate the debug-code
        compiled into the parsing function. It is always available but is only
        operational if the tt(%debug) directive or tt(--debug) option was
        specified.When debugging code has been compiled into the parsing
        function, it is em(not) active by default. To activate the debugging
        code, use tt(setDebug(true)).
       This member can be used to activate or deactivate the debug-code
        compiled into the parsing function. It is available but has no
        effect if no debug code has been compiled into the parsing
        function. When debugging code has been compiled into the parsing
        function, it is active by default, but debug-code is suppressed by
        calling tt(setDebug(false)).
    )

When the tt(%polymorphic) directive is used:
    itemization(
    it() bf(Meta__):nl()
           Templates and classes that are required for implementing the
            polymorphic semantic values are all declared in the tt(Meta__)
            namespace. The tt(Meta__) namespace itself is nested under the
            namespace that may have been declared by the tt(%namespace)
            directive. See also section ref(META).
    
    it() bf(Tag__):nl()
           The (strongly typed) tt(enum class Tag__) contains all the
            tag-identifiers specified by the tt(%polymorphic) directive. It is
            declared outside of the Parser's class, but within the namespace
            that may have been declared by the tt(%namespace) directive.

    it() bf(Meta__::Semantic<Tag__::tag> *semantic__(DataType const &data))nl()
           The address of a newly allocated tt(Semantic<Tag__::tag>) object,
            initialized with the value tt(data) of the data type matching the
            tag is returned. This is a free function, declared outside of the
            Parser's class, but within the namespace that may have been
            declared by the tt(%namespace) directive.

    it() bf(Meta__::Semantic<Tag__::tag> *semantic__(DataType &&data))nl()
           The address of a newly allocated tt(Semantic<Tag__::tag>) object,
            using tt(DataType)'s move constructor to initialize
            tt(Semantic<Tag__::tag>)'s data member. This is a free function,
            declared outside of the Parser's class, but within the namespace
            that may have been declared by the tt(%namespace) directive.
    )


