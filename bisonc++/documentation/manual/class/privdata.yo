    The following private members can be used by members of parser classes
generated by b(). All data members are actually protected
members inherited from the parser's base class. 
    itemization(
    it() bf(bool d_debug):nl()
       When the bf(debug) option has been specified, this variable (bf(true)
        by default) determines whether debug information is actually
        displayed.
    it() bf(LTYPE d_loc):nl()
       The location type value associated with a terminal token. It can be
        used by, e.g., lexical scanners to pass location information of a
        matched token to the parser in parallel with a returned token. It is
        available only when bf(%lsp-needed, %ltype) or bf(%locationstruct) has
        been defined. nl()
       Lexical scanners may be offered the facility to assign
        a value to this variable in parallel with a returned
        token. In order to allow a scanner access to bf(d_loc), bf(d_loc)'s
        address should be passed to the scanner. This can be realized, for
        example, by defining a member bf(void setLoc(STYPE *)) in the lexical
        scanner, which is then called from the parser's constructor as
        follows:
       verb(
            d_scanner.setSLoc(&d_loc);
       )
       Subsequently, the lexical scanner may assign a value to the parser's
        bf(d_loc) variable through the pointer to bf(d_loc) stored inside the
        lexical scanner. 
    it() bf(LTYPE d_lsp):nl()
       The location stack pointer. Used internally by the parser. Not to be
        used otherwise.
    it() bf(STYPE d_val):nl()
       The semantic value of a returned token or non-terminal symbol. With
        non-terminal tokens it is assigned a value through the action rule's
        symbol bf($$). Lexical scanners may be offered the facility to assign
        a semantic value to this variable in parallel with a returned
        token. In order to allow a scanner access to bf(d_val), bf(d_val)'s
        address should be passed to the scanner. This can be realized, for
        example, by defining a member bf(void setSval(STYPE *)) in the lexical
        scanner, which is then called from the parser's constructor as
        follows:
       verb(
            d_scanner.setSval(&d_val);
       )
       Subsequently, the lexical scanner may assign a value to the parser's
        bf(d_val) variable through the pointer to bf(d_val) stored inside the
        lexical scanner. 
    it() bf(LTYPE d_vsp):nl()
       The semantic value stack pointer. Used internally by the parser. Not to
        be used otherwise.
    it() bf(unsigned d_nErrors):nl()
       The number of errors counted by bf(parse()). It is initialized by the
        parser's base class initializer, and is updated while bf(parse())
        executes. When bf(parse()) has returned it contains the total number
        of errors counted by bf(parse()).
    it() bf(int d_state):nl()
       The current parsing state. Used internally by the parsing function. Not
        to be used otherwise.
    it() bf(int d_token):nl()
       The current token used internally by the parser. The parser may modify
        the token value retrieved via bf(lex()), so bf(d_token) may not be the
        value of the last token actually retrieved by bf(lex()).
    it() bf(static PI s_productionInfo):nl()
       Used internally by the parsing function. Not to be used otherwise.
    it() bf(static SR s_<nr>[]):nl()
       Here, tt(<nr>) is a numerical value representing a state number.
       Used internally by the parsing function. Not to be used otherwise.
    it() bf(static SR *s_state[]):nl()
       Used internally by the parsing function. Not to be used otherwise.
    )
