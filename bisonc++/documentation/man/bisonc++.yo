NOUSERMACRO(yyparse parse lex yylex error setDebug ParserBase throw ACCEPT
        ABORT errok RECOVERING print done prompt Parse yyrestart
        debug setSval setLoc)

includefile(../../release.yo)

htmlbodyopt(text)(#27408B)
htmlbodyopt(bgcolor)(#FFFAF0)
whenhtml(mailto(Frank B. Brokken: f.b.brokken@rug.nl))

DEFINEMACRO(lsoption)(3)(\
    bf(--ARG1)=tt(ARG3) (bf(-ARG2))\
)
DEFINEMACRO(laoption)(2)(\
    bf(--ARG1)=tt(ARG2)\
)
DEFINEMACRO(loption)(1)(\
    bf(--ARG1)\
)
DEFINEMACRO(soption)(1)(\
    bf(-ARG1)\
)

DEFINEMACRO(bic)(0)(bf(bisonc++))
DEFINEMACRO(Bic)(0)(bf(Bisonc++))
DEFINEMACRO(Cpp)(0)(bf(C++))
DEFINEMACRO(prot)(0)(tt((prot)))

DELETEMACRO(tt)
DEFINEMACRO(tt)(1)(em(ARG1))

COMMENT( man-request, section, date, distribution file, general name)
manpage(bisonc++)(1)(_CurYrs_)(bisonc++._CurVers_.tar.gz)
        (bisonc++ parser generator)

COMMENT( man-request, larger title )
manpagename(bisonc++)(Generate a C++ parser class and parsing function)

COMMENT( all other: add after () )
manpagesynopsis()
       bf(bisonc++) [OPTIONS] tt(grammar-file)

manpagedescription()

    The program bic() is based on previous work on bf(bison) by Alain Coetmeur
(coetmeur@icdc.fr), who created in the early '90s a Cpp() class encapsulating
the bf(yyparse()) function as generated by the GNU-bf(bison) parser generator.

    Initial versions of bic() (up to version 0.92) wrapped Alain's program in
a program offering a more modern user-interface, removing all old-style
(bf(C)) bf(%define) directives from bf(bison++)'s input specification file
(see below for an in-depth discussion of the differences between bf(bison++)
and bic()). Starting with version 0.98, bic() is compiled from a complete 
rebuilt of the parser generator, closely following the description of Aho,
Sethi and Ullman's em(Dragon Book). Moreover, starting with version 0.98 
bic() is now a Cpp() program, rather than a bf(C) program generating bf(C++)
code. 

    Bic() expands the concepts initially implemented in bf(bison) and
bf(bison++), offering a cleaner setup of the generated parser class. The
parser class is derived from a base-class, mainly containing the parser's
token- and type-definitions as well as several member functions which should
not be (re)defined by the programmer. 

    Most of these base-class members might also be defined directly in the
parser class, but were defined in the parser's base-class. This design results
in a very lean parser class, declaring only members that are actually defined
by the programmer or that em(must) be defined by bic() itself (e.g., the
member function bf(parse()) as well as those support functions requiring access
to facilities that are only available in the parser class itself, rather than
in the parser's base class).  

    Moreover, this design does not require the use of virtual members: the
members which are not involved in the actual parsing process may always be
(re)implemented directly by the programmer. Thus there is no need to apply or
define virtual member functions.

    In fact, there are only two public members in the parser class generated
by bic(): bf(setDebug()) (see below) and bf(parse()). Remaining members are
private, and those that can be redefined by the programmer using bic() usually
receive initial, very simple default in-line implementations. The (partial)
exception to this rule is the member function bf(lex()), producing the next
lexical token. For bf(lex()) either a standardized interface or a mere
declaration is offerered (requiring the programmer to provide a tailor-made
implementation for bf(lex())).

    To enforce a primitive namespace, bf(bison) used a well-known
naming-convention: all its public symbols started with tt(yy) or tt(YY).
bf(Bison++) followed bf(bison) in this respect, even though a class by itself
offers enough protection of its identifiers. Consequently, the present author
feels that these tt(yy) and tt(YY) conventions are outdated, and consequently
bic() does not generate any symbols defined in either the parser (base) class
or in the parser function starting with tt(yy) or tt(YY). Instead, all data
members have names, following a suggestion by Lakos (2001), starting with
tt(d_), and all static data members have names starting with tt(s_). This
convention was not introduced to enforce identifier protection, but to clarify
the storage type of variables. Other (local) symbols lack specific
prefixes. Furthermore, bic() allows its users to define the parser class in a
particular namespace of their own choice.


    Bic() should be used as follows:
    itemization(
    it() As usual, a grammar must be defined. Using bic() this is no
different, and the reader is referred to bf(bison)'s documentation for details
about specifying and decorating grammars.
    it() The number and function of the various bf(%define) declarations as
used by bf(bison++), however, is greatly modified. Actually, all bf(%define)
declarations are replaced by their (former) first arguments. Furthermore,
`macro-style' declarations are no longer supported or required. Finally, all
directives use lower-case characters only and do not contain underscore
characters (but sometimes hyphens). E.g., bf(%define DEBUG) is now declared as
bf(%debug); bf(%define LSP_NEEDED) is now declared as bf(%lsp-needed) (note
the hyphen).
    it() As noted, no `macro style' bf(%define) declarations are required
anymore. Instead, the normal practice of defining class members in source
files and declaring them in a class header files can be adhered to using
bic().  Basically, bic() concentrates on its main tasks: the definition of an
initial parser class and the implementation of its parsing function bf(int
parse()), leaving all other parts of the parser class' definition to the
programmer.
    it() Having specified the grammar and (usually) some directives bic() is
able to generate files defining the parser class and the implementation of the
member function bf(parse()) and its support functions. See the next section
for details about the various files that may be written by bic().
    it() All members (except for the member bf(parse())) and its support
functions must be implemented by the programmer. Of course, additional member
functions should also be declared in the parser class' header.  At the very
least the member bf(int lex()) em(must) be implemented (although a
standardized implementation can also be generated by bic()). The member
bf(lex()) is called by bf(parse()) (support functions) to obtain the next
available token. The member function bf(void error(char const *msg)) may also
be re-implemented by the programmer, but a basic in-line implementation is
provided by default. The member function bf(error()) is called when
bf(parse()) detects (syntactical) errors.
    it() The parser can now be used in a program. A very simple example would
be: 
        verb(
    int main()
    {
        Parser parser;
        return parser.parse();
    }
        )
    )

    manpagesection(GENERATED FILES)

    Bic() may create the following files:
    itemization(
    it() A file containing the implementation of the member function
bf(parse()) and its support functions. The member bf(parse()) is a public
member that can be called to parse a token-sequence according to a specified
LALR1 type grammar. The implementations of these members is by default written
on the file bf(parse.cc). There should be em(no) need for the programmer to
alter the contents of this file, as its contents change whenever the grammar
is modified. Hence it is rewritten by default. The option
bf(--no-parse-member) may be specified to prevent this file from being
(re)written. In normal circumstances, however, this option should be avoided.
    it() A file containing an initial setup of the parser class, containing
the declaration of the public member bf(parse()) and of its (private) support
members. The members bf(error()) and bf(print()) receive default in-line
implementations which may be altered by the programmer. The member bf(lex())
may receive a standard in-line implementation (see below), or it will merely
be declared, in which case the programmer em(must) provide an implementation. 
Furthermore, new members may be added to the parser class as well. By
default this file will only be created if not yet existing, using the filename
tt(<parser-class>.h) (where tt(<parser-class>) is the the name of the defined
parser class). The option bf(--force-class-header) may be used to (re)write
this file, even if already existing.
        it() A file containing the parser class' em(base class). This base
class should not be modified by the programmer. It contains types defined by
bic(), as well as several (protected) data members and member functions, which
should not be redefined by the programmer. All symbolic parser terminal tokens
are defined in this class, so it escalates these definitions in a separate
class (cf. Lakos, (2001)), thus preventing circular dependencies between the
lexical scanner and the parser (circular dependencies occur in situations
where the parser needs access to the lexical scanner class to define a lexical
scanner as one of its data members, whereas the lexical scanner, in turn,
needs access to the parser class to know about the grammar's symbolic terminal
tokens. Escalation is a way out of such circular dependencies). By default
this file will be (re)written any time bic() is called, using the filename
tt(<parser-class>base.h). The option bf(--no-baseclass-header) may be
specified to prevent the base class header file from being (re)written. In
normal circumstances, however, this option should be avoided.
        it() A file containing an em(implementation header). An implementation
header may be included by source files implementing the various member
functions of a class. The implementation header first includes its associated
class header file, followed by any directives (formerly defined in the
bf(%{header ... %}) section of the bf(bison++) parser specification file) that
are required for the proper compilation of these member functions. The
implementation header is included by the file defining bf(parse()). By default
the implementation header will be created if not yet existing, receiving the
filename tt(<parser-class>.ih).  The option bf(--force-implementation-header)
may be used to (re)write this file, even if already existing.
        it() A verbose description of the generated parser. This file is
comparable to the verbose ouput file originally generated by bf(bison++). It
is generated when the option bf(--verbose) or bf(-V) is provided. When
generated, it will use the filename tt(<grammar>.output), where tt(<grammar>)
is the name of the file containing the grammar definition.
        )

manpageoptions()
    If available, single letter options are listed between parentheses
following their associated long-option variants. Single letter options require
arguments if their associated long options require arguments as well.
    itemization(
    it() loption(analyze-only) (soption(A))nl()
           Only analyze the grammar. No files are (re)written. This option can
            be used to test the grammatical correctness of modification `in
            situ', without overwriting previously generated files. If the
            grammar contains syntactic errors only syntax analysis is 
            performed.
    it() lsoption(baseclass-preinclude)(H)(header)nl()
           Use tt(header) as the pathname to the file preincluded in the
            parser's base-class header. This option is useful in situations
            where the base class header file refers to types which might not
            yet be known. E.g., with bf(%union) a bf(std::string *) field
            might be used. Since the class bf(std::string) might not yet be
            known to the compiler once it processes the base class header file
            we need a way to inform the compiler about these classes and
            types. The suggested procedure is to use a pre-include header file
            declaring the required types. By default tt(header) will be
            surrounded by double quotes (using, e.g., tt(#include "header")).
            When the argument is surrounded by pointed brackets
            tt(#include <header>) will be included. In the latter case,
            quotes might be required to escape interpretation by the shell
            (e.g., using tt(-H '<header>')).
    it() lsoption(baseclass-header)(b)(header)nl()
           Use tt(header) as the pathname of the file containing the parser's
            base class. This class defines, e.g., the parser's symbolic
            tokens. Defaults to the name of the parser class plus the suffix
            tt(base.h). It is generated, unless otherwise indicated (see
            bf(--no-baseclass-header) and bf(--dont-rewrite-baseclass-header)
            below).
    it() lsoption(baseclass-skeleton)(B)(skeleton)nl() 
           Use tt(skeleton) as the pathname of the file containing the
            skeleton of the parser's base class. Its filename defaults to
            tt(bisonc++base.h).
    it() lsoption(class-header)(c)(header)nl()
           Use tt(header) as the pathname of the file containing the parser
            class. Defaults to the name of the parser class plus the suffix
            tt(.h)
    it() lsoption(class-skeleton)(C)(skeleton)nl()
           Use tt(skeleton) as the pathname of the file containing the
            skeleton of the parser class. Its filename defaults to
            tt(bisonc++.h). The environment variable tt(BISON_SIMPLE_H)
            is not inspected anymore.
    it() loption(construction)nl() 
           This option may be specified to write details about the
            construction of the parsing tables to the standard output
            stream. This information is primarily useful for developers, and
            augments the information written to the verbose grammar output
            file, produced by the bf(--verbose) option.
    it() loption(debug)nl() 
           Provide bf(parse()) and its support functions with debugging code,
            showing the actual parsing process on the standard output
            stream. When included, the debugging output is active by default,
            but its activity may be controlled using the bf(setDebug(bool
            on-off)) member. Note that no tt(#ifdef DEBUG) macros are used
            anymore. By rerunning bic() without the bf(--debug) option an
            equivalent parser is generated not containing the debugging
            code. 
    it() loption(error-verbose)nl()
           When a syntactic error is reported, the generated parse function
            will dump the parser's state stack to the standard output
            stream. The stack dump shows on separate lines a stack index
            followed by the state stored at the indicated stack element. The
            first stack element is the stack's top element.
    it() lsoption(filenames)(f)(filename)nl()
           Specify a filename to use for all files produced by bic(). 
            Specific options overriding particular filenames are also
            available (which then, in turn, overide the name specified by this
            option).
    it() loption(force-class-header)nl()
           By default the generated class header is not overwritten once it
            has been created. This option can be used to force the
            (re)writing of the file containing the parser's class.
    it() loption(force-implementation-header)nl()
           By default the generated implementation header is not overwritten
            once it has been created. This option can be used to force the
            (re)writing of the implementation header file.
    it() loption(help) (soption(h))nl()
            Write basic usage information to the standard output stream and
            terminate. 
    it() lsoption(implementation-header)(i)(header)nl()
           Use tt(header) as the pathname of the file containing the
            implementation header. Defaults to the name of the generated
            parser class plus the suffix tt(.ih). The implementation header
            should contain all directives and declarations em(only) used by
            the implementations of the parser's member functions. It is the
            only header file that is included by the source file containing
            bf(parse())'s implementation . User defined implementation of
            other class members may use the same convention, thus
            concentrating all directives and declarations that are required
            for the compilation of other source files belonging to the parser
            class in one header file.
    it() lsoption(implementation-skeleton)(I)(skeleton)nl()
           Use tt(skeleton) as the pathname of the file containing the
            skeleton of the implementation header. Its filename defaults to
            tt(bisonc++.ih).
    it() loption(include-only)nl()
           All grammar files will be concatenated to the standard output
            stream in their order of processing. Following this, Bic()
            terminates.
    it() loption(lines) (soption(l))nl() 
           Put bf(#line) preprocessor directives in the file containing the
            parser's bf(parse()) function. By including this option the
            compiler and debuggers will associate errors with lines in your
            grammar specification file, rather than with the source file
            containing the bf(parse()) function itself.
    it() laoption(max-inclusion-depth)(value)nl()
           Set the maximum number of nested grammar files. Defaults to 10.
    it() lsoption(namespace)(n)(namespace)nl()
           Define the parser base class, the paser class and the parser
            implentations in the namespace tt(namespace). By default
            no namespace is defined. If this options is used the
            implementation header will contain a commented out tt(using
            namespace) declaration for the requested namespace. 
    it() loption(no-baseclass-header)nl()
           Do not write the file containing the parser class' base class, even
            if that file doesn't yet exist. By default the file containing the
            parser's base class is (re)written each time bic() is called. Note
            that this option should normally be avoided, as the base class
            defines the symbolic terminal tokens that are returned by the
            lexical scanner. By suppressing the construction of this file any
            modification in these terminal tokens will not be communicated to
            the lexical scanner.
    it() loption(no-lines)nl() 
           Do not put bf(#line) preprocessor directives in the file containing
            the parser's bf(parse()) function. This option is primarily useful
            in combination with the bf(%lines) directive, to suppress that
            directive. It also overrides option bf(--lines), though.
    it() loption(no-parse-member)nl()
           Do not write the file containing the parser's predefined parser
            member functions, even if that file doesn't yet exist. By default
            the file containing the parser's bf(parse()) member function is
            (re)written each time bic() is called. Note that this option
            should normally be avoided, as this file contains parsing
            tables which are altered whenever the grammar definition is
            modified. 
    it() lsoption(parsefun-skeleton)(P)(skeleton)nl()
           Use tt(skeleton) as the pathname of the file containing the parsing
            member function's skeleton. Its filename defaults to
            tt(bisonc++.cc). The environment variable tt(BISON_SIMPLE) is not
            inspected anymore.
    it() lsoption(parsefun-source)(p)(source)nl()
           Define tt(source) as the name of the source file containing the
            parser member function bf(parse()). Defaults to tt(parse.cc).
    it() laoption(required-tokens)(number)nl()
           Following a syntactic error, require at least tt(number)
            successfully processed tokens before another syntactic error can
            be reported. By default tt(number) is zero.
    it() lsoption(scanner)(s)(header)nl()
           Use tt(header) as the pathname to the file defining a class
            bf(Scanner), offering a member bf(int yylex()) producing the next
            token from the input stream to be analyzed by the parser generated
            by bic(). When this option is used the parser's member bf(int
            lex()) will be predefined as 
                verb(
    int lex()
    {
        return d_scanner.yylex();
    }
                )
           and an object tt(Scanner d_scanner) will be composed into the
            parser. The tt(d_scanner) object will be constructed using its
            default constructor. If another constructor is required, the
            parser class may be provided with an appropriate (overloaded)
            parser constructor after having constructed the default parser
            class header file using bic().  By default tt(header) will be
            surrounded by double quotes (using, e.g., tt(#include "header")).
            When the argument is surrounded by pointed brackets tt(#include
            <header>) will be included. In the latter case, quotes might be
            required to escape interpretation by the shell (e.g., using tt(-s
            '<header>')).
    it() loption(scanner-debug)nl() 
           Show de scanner's matched rules and returned tokens.
    it() loption(show-filenames)nl() 
           Write the names of the files that are generated to the 
            standard error stream.
    it() laoption(skeleton-directory)(directory)nl() 
           Specifies the directory containing the skeleton files to use. This
            option can be overridden by the specific skeleton-specifying
            options (tt(-B -C, -H,) and tt(-I)).
    it() loption(thread-safe)nl() 
           No static data are modified, making bic() thread-safe.
    it() loption(usage)nl()
            Write basic usage information to the standard output stream and
            terminate. 
    it() loption(verbose) (soption(V))nl() 
           Write a file containing verbose descriptions of
            the parser states and what is done for each type of look-ahead
            token in that state.  This file also describes all conflicts
            detected in the grammar, both those resolved by operator
            precedence and those that remain unresolved.  By default it will
            not be created, but if requested it will receive the filename
            tt(<parse>.output), where tt(<parse>) is the filename (without the
            tt(.cc) extension) of the file containing bf(parse())'s
            implementation.
    it() loption(version) (soption(v))nl()
            Display bic()'s version number and terminate.
    )

manpagesection(DIRECTIVES)

    The following directives can be used in the initial section of the
grammar specification file. When command-line options for directives exist,
they overrule the corresponding directives given in the grammar
specification file.
    itemization(
    it() bf(%baseclass-header) tt(header) nl()
           Defines the pathname of the file containing the parser's base
            class. This directive is overridden by the
            bf(--baseclass-header) or bf(-b) command-line options.
    it() bf(%baseclass-preinclude) tt(header)nl()
           Use tt(header) as the pathname to the file pre-included in the
            parser's base-class header. See the description of the
            bf(--baseclass-preinclude) option for details about this option.
            Like the convention adopted for this argument, tt(header) will (by
            default) be surrounded by double quotes.  However, when the
            argument is surrounded by pointed brackets tt(#include <header>)
            will be included.
    it() bf(%class-header) tt(header) nl()
           Defines the pathname of the file containing the parser 
            class. This directive is overridden by the
            bf(--class-header) or bf(-c) command-line options.
    it() bf(%class-name) tt(parser-class-name) nl()
           Declares the name of this parser. This directive replaces the
            bf(%name) declaration previously used by bf(bison++). It defines
            the name of the bf(C++) class that will be generated. Contrary to
            bf(bison++)'s bf(%name) declaration, bf(%class-name) may appear
            anywhere in the first section of the grammar specification
            file. However, it may be defined only once. If no bf(%class-name)
            is specified the default class name tt(Parser) will be used.
    it() bf(%debug) nl() 
           Provide bf(parse()) and its support functions with debugging code,
            showing the actual parsing process on the standard output
            stream. When included, the debugging output is active by default,
            but its activity may be controlled using the bf(setDebug(bool
            on-off)) member. Note that no tt(#ifdef DEBUG) macros are used
            anymore. By rerunning bic() without the bf(--debug) option an
            equivalent parser is generated not containing the debugging
            code. 
    it() bf(%error-verbose) nl()    
           When a syntactic error is reported, the generated parse function
            will dump the parser's state stack to the standard output
            stream. The stack dump shows on separate lines a stack index
            followed by the state stored at the indicated stack element. The
            first stack element is the stack's top element.
    it() bf(%expect) tt(number) nl()    
            If defined the parser will not report encountered shift/reduce and
            reduce/reduce conflicts if all detected conflicts are equal to the
            number following bf(%expect). Conflicts are mentioned in the
            tt(.output) file and the number of encountered conflicts is shown
            on the standard output if the actual number of conflicts deviates
            from tt(number).
    it() bf(%filenames) tt(header) nl()
           Defines the generic name of all generated files, unless overridden
            by specific names. This directive is overridden by the
            bf(--filenames) or bf(-f) command-line options.
    it() bf(%implementation-header) tt(header) nl()
           Defines the pathname of the file containing the implementation
            header.  This directive is overridden by the
            bf(--implementation-header) or bf(-i) command-line options.
    it() bf(%include) tt(path) nl() 
            This directive may be used to read part of the grammar
            specification file from the file specified at tt(path). Unless
            tt(path) is an absolute file-path, tt(path) is searched relative
            to the location of bic()'s grammar specification file. This
            directive can be used to split long grammar specification files in
            shorter, meaningful units. 
    it() bf(%left) tt(terminal ...) nl()    
            Defines the names of symbolic terminal tokens that should be
            treated as left-associative. I.e., in case of a shift/reduce
            conflict, a reduction will be preferred over a shift.
            Sequences of bf(%left, %nonassoc, %right) and bf(%token)
            directives may be used to define the precedence of operators. In
            expressions, the first used directive will have the lowest
            precedence, the last used the highest. See also bf(%token) below.
    it() bf(%lines) nl() 
           Put bf(#line) preprocessor directives in the file containing the
            parser's bf(parse()) function. It acts identically to the bf(-l)
            command line option, and is suppressed by the bf(--no-lines)
            option.
    it() bf(%locationstruct) tt(struct-definition) nl() 
       Defines the organization of the location-struct data type
        bf(LTYPE__). This struct should be specified analogously to the way
        the parser's stacktype is defined using bf(%union) (see below). The
        location struct is named bf(LTYPE__). If neither bf(locationstruct)
        nor bf(LTYPE__) is specified, the aforementioned default struct is
        used.
    it() bf(%lsp-needed) nl()    
           Defining this causes bic() to include code into the generated
            parser using the standard location stack.  The token-location type
            defaults to the following struct, defined in the parser's base
            class when this directive is specified: 
           verb(
    struct LTYPE__
    {
        int timestamp;
        int first_line;
        int first_column;
        int last_line;
        int last_column;
        char *text;
    };
           )
    it() bf(%ltype typename) nl()    
           Specifies a user-defined token location type. 
           If bf(%ltype) is used, tt(typename) should be the name of an
            alternate (predefined) type (e.g., bf(size_t)). It should not be
            used if a bf(%locationstruct) specification is defined (see
            below). Within the parser class, this type will be available as
            the type `bf(LTYPE__)'.  All text on the line following bf(%ltype)
            is used for the tt(typename) specification. It should therefore
            not contain comment or any other characters that are not part of
            the actual type definition.
    it() bf(%namespace) tt(namespace) nl()
           Define the parser class in the namespace tt(namespace). By default
            no namespace is defined. If this options is used the
            implementation header will contain a commented out tt(using
            namespace) declaration for the requested namespace.  This
            directive is overridden by the bf(--namespace) command-line
            option.
    it() bf(%negative-dollar-indices) nl()
           Do not generate warnings when zero- or negative dollar-indices are
            used in the grammar's action blocks. Zero or negative
            dollar-indices are commonly used to implement inherited
            attributes, and should normally be avoided. When used, they can be
            specified like tt($-1) or tt($<type>-1), where tt(type) is a
            tt(%union) field-name.
    it() bf(%nonassoc) tt(terminal ...) nl()    
            Defines the names of symbolic terminal tokens that should be
            treated as non-associative. I.e., in case of a shift/reduce
            conflict, a reduction will be preferred over a shift.
            Sequences of bf(%left, %nonassoc, %right) and bf(%token)
            directives may be used to define the precedence of operators. In
            expressions, the first used directive will have the lowest
            precedence, the last used the highest. See also bf(%token) below.
    it() bf(%parsefun-source) tt(source) nl()
           Defines the pathname of the file containing the parser member
            bf(parse()). This directive is overridden by the 
            bf(--parse-source) or bf(-p) command-line options.
    it() bf(%prec) tt(token) nl()    
            Overrules the defined precendence of an operator for a particular
            grammatical rule. Well known is the construction
                verb(
    expression:
        '-' expression %prec UMINUS
        {
            ...
        }
                )
            Here, the default priority and precedence of the `tt(-)' token as
            the subtraction operator is overruled by the precedence and
            priority of the tt(UMINUS) token, which is commonly defined as 
                verb(
    %right UMINUS
                )
            (see below) following, e.g., the tt('*') and tt('/') operators.
    it() bf((%required-tokens) tt(number)nl()
           Following a syntactic error, require at least tt(number)
            successfully processed tokens before another syntactic error can
            be reported. By default tt(number) is zero.
    it() bf(%right) tt(terminal ...) nl()    
            Defines the names of symbolic terminal tokens that should be
            treated as right-associative. I.e., in case of a shift/reduce
            conflict, a shift will be preferred over a reduction.
            Sequences of bf(%left, %nonassoc, %right) and bf(%token)
            directives may be used to define the precedence of operators. In
            expressions, the first used directive will have the lowest
            precedence, the last used the highest. See also bf(%token) below.
    it() bf(%scanner) tt(header)nl()
           Use tt(header) as the pathname to the file pre-included in the
            parser's class header. See the description of the bf(--scanner)
            option for details about this option.  Similar to the convention
            adopted for this argument, tt(header) will (by default) be
            surrounded by double quotes.  However, when the argument is
            surrounded by pointed brackets tt(#include <header>) will be
            included. Note that using this directive implies the definition
            of a composed tt(Scanner d_scanner) data member into the generated
            parser, as well as a predefined bf(int lex()) member, returning
            tt(d_scanner.yylex()). If this is inappropriate, a user defined
            implementation of bf(int lex()) must be provided.
    it() bf(%start) tt(non-terminal) nl()    
            The non-terminal tt(non-terminal) should be used as the grammar's 
            start-symbol. If omitted, the first grammatical rule will be used
            as the grammar's starting rule. All syntactically correct
            sentences must be derivable from this starting rule.
    it() bf(%stype typename) nl() 
       The type of the semantic value of tokens.  The specification
        tt(typename) should be the name of an unstructured type (e.g.,
        bf(size_t)). By default it is bf(int). See bf(YYSTYPE) in bf(bison).
        It should not be used if a bf(%union) specification is defined.
        Within the parser class, this type will be available as the type
        `bf(STYPE__)'. All text on the line following bf(%stype) is used for
        the tt(typename) specification. It should therefore not contain
        comment or any other characters that are not part of the actual type
        definition.
    it() bf(%token) tt(terminal ...) nl()    
            Defines the names of symbolic terminal tokens.
            Sequences of bf(%left, %nonassoc, %right) and bf(%token)
            directives may be used to define the precedence of operators. In
            expressions, the first used directive will have the lowest
            precedence, the last used the highest.nl()
            bf(NOTE:) Symbolic tokens are defined as tt(enum)-values in the
            parser's base class. The names of symbolic tokens may not be equal
            to the names of the members and types defined by bic()
            itself (see the next sections). This requirement is em(not)
            currently enforced by bic(), but unexpected compilation errors may
            result if this requirement is violated.
    it() bf(%type) tt(<type> non-terminal ...) nl()    
            In combination with bf(%union): associate the semantical value of
            a non-terminal symbol with a union field defined by the bf(%union)
            directive.
    it() bf(%union) tt(union-definition) nl()    
            Acts identically to the bf(bison) and bf(bison++) declaration. 
            as with bison generate a union for semantic type. 
            The union type is named bf(STYPE__). If no bf(%union) is
            declared, a simple stack-type may be defined using the bf(%stype)
            directive. If no bf(%stype) directive is used, the default
            stacktype (bf(int)) is used.
    )

manpagesection(PUBLIC MEMBERS AND -TYPES)

    The following public members can be used by users of the parser classes
generated by bic() (tt(`Parser Class'::) prefixes are silently implied):
    itemization(
    it() bf(LTYPE__):nl() 
           The parser's location type (user-definable). Available only when
            either bf(%lsp-needed, %ltype) or bf(%locationstruct) has been
            declared. 
    it() bf(STYPE__):nl()
            The parser's stack-type (user-definable), defaults to bf(int).
    it() bf(Tokens__):nl()
           The enumeration type of all the symbolic tokens defined in the
            grammar file (i.e., bic()'s input file). The scanner should be
            prepared to return these symbolic tokens Note that, since the
            symbolic tokens are defined in the parser's class and not in the
            scanner's class, the lexical scanner must prefix the parser's
            class name to the symbolic token names when they are
            returned. E.g., bf(return Parser::IDENT) should be used rather
            than bf(return IDENT).
    it() bf(int parse()):nl()
           The parser's parsing member function. It returns 0 when parsing has
            completed successfully, 1 if errors were encountered while parsing
            the input.
    it() bf(void setDebug(bool mode)):nl()
       This member can be used to activate or deactivate the debug-code
        compiled into the parsing function. It is always available but is only
        operational if the tt(%debug) directive or tt(--debug) option was
        specified.When debugging code has been compiled into the parsing
        function, it is em(not) active by default. To activate the debugging
        code, use bf(setDebug(true)).
       This member can be used to activate or deactivate the debug-code
        compiled into the parsing function. It is available but has no
        effect if no debug code has been compiled into the parsing
        function. When debugging code has been compiled into the parsing
        function, it is active by default, but debug-code is suppressed by
        calling bf(setDebug(false)).
    )
    
manpagesection(PROTECTED ENUMS AND -TYPES)

    The following enumerations and types can be used by members of parser
classes generated by bic(). They are actually protected members inherited from
the parser's base class.
    itemization(
    it() bf(Base::ErrorRecovery__):nl()
        This enumeration defines two values:
        verb(
    DEFAULT_RECOVERY_MODE__,
    UNEXPECTED_TOKEN__
        )
       bf(DEFAULT_RECOVERY_MODE__) consists of terminating the parsing
        process. bf(UNEXPECTED_TOKEN__) activates the recovery procedure
        whenever an error is encountered. The recovery procedure consists of
        looking for the first state on the state-stack having an
        error-production, and then skipping subsequent tokens until (in that
        state) a token is retrieved which may follow the bf(error) terminal
        token in that production rule. If this error recovery procedure fails
        (i.e., if no acceptable token is ever encountered) error recovery
        falls back to the default recovery mode, terminating the parsing
        process. 
    it() bf(Base::Return__):nl()
        This enumeration defines two values:
        verb(
    PARSE_ACCEPT = 0,
    PARSE_ABORT = 1
        )
        (which are of course the bf(parse()) function's return values).
     ))


manpagesection(PRIVATE MEMBER FUNCTIONS)

    The following members can be used by members of parser classes generated
by bic(). When prefixed by bf(Base::) they are actually protected members
inherited from the parser's base class.  Members for which the phrase ``Used
internally'' is used should not be called by user-defined code.
    itemization(
    it() bf(Base::ParserBase()):nl()
        The default base-class constructor. Used internally.
    it() bf(void Base::ABORT() const throw(Return__)):nl()
       This member can be called from any member function (called from any of
        the parser's action blocks) to indicate a failure while parsing thus
        terminating the parsing function with an error value 1. Note that this
        offers a marked extension and improvement of the macro bf(YYABORT)
        defined by bf(bison++) in that bf(YYABORT) could not be called from
        outside of the parsing member function.
    it() bf(void Base::ACCEPT() const throw(Return__)):nl()
       This member can be called from any member function (called from any of
        the parser's action blocks) to indicate successful parsing and thus
        terminating the parsing function. Note that this offers a marked
        extension and improvement of the macro bf(YYACCEPT) defined by
        bf(bison++) in that bf(YYACCEPT) could not be called from outside of
        the parsing member function.
    it() bf(void Base::checkEOF__+nop()()):nl()
       Used internally.
    it() bf(void Base::clearin+nop()()):nl()
       This member replaces bf(bison)(++)'s macro bf(yyclearin) and causes
        bf(bisonc++) to request another token from its tt(lex+nop()()) member,
        even if the current token has not yet been processed. It is a useful
        member when the parser should be reset to its initial state, e.g.,
        between successive calls of tt(parse()). In this situation the scanner
        will probably be reloaded with new information too (in the context of
        a tt(flex)-generated scanner by, e.g., calling the scanner's
        tt(yyrestart()) member.
    it() bf(bool Base::debug() const):nl()
       This member returns the current value of the debug variable.
    it() bf(void Base::ERROR+nop()() const throw(ErrorRecovery__)):nl()
       This member can be called from any member function (called from any of
        the parser's action blocks) to generate an error, and thus initiate
        the parser's error recovery code. Note that this offers a marked
        extension and improvement of the macro bf(YYERROR) defined by
        bf(bison++) in that bf(YYERROR) could not be called from outside of
        the parsing member function.
    it() bf(void error(char const *msg)):nl()
       This member may be redefined in the parser class. Its default (inline)
        implementation is to write a simple message to the standard error
        stream. It is called when a syntactical error is encountered.
    it() bf(void errorRecovery__+nop()()):nl()
       Used internally.
    it() bf(void Base::errorVerbose__+nop()()):nl()
       Used internally.
    it() bf(void executeAction+nop()()):nl()
       Used internally.
    it() bf(int lex()):nl()
       This member may be pre-implemented using the bf(scanner) option or
        directive (see above) or it em(must) be implemented by the
        programmer. It interfaces to the lexical scanner, and should
        return the next token produced by the lexical scanner, either as a
        plain character or as one of the symbolic tokens defined in the
        bf(Parser::Tokens__) enumeration. Zero or negative token values are
        interpreted as `end of input'.
    it() bf(int lookup+nop()()):nl()
       Used internally.
       otherwise. See also below, section bf(BUGS).
    it() bf(void nextToken+nop()()):nl()
       Used internally.
       otherwise. See also below, section bf(BUGS).
    it() bf(void Base::pop__+nop()()):nl()
       Used internally.
    it() bf(void Base::popToken__+nop()()):nl()
       Used internally.
    it() bf(void print())):nl()
       This member can be redefined in the parser class to print information
        about the parser's state. It is called by the parser immediately after
        retrieving a token from bf(lex()). As it is a member function it has
        access to all the parser's members, in particular bf(d_token), the
        current token value and bf(d_loc__), the current token location
        information (if bf(%lsp-needed, %ltype) or bf(%locationstruct) has
        been specified).
    it() bf(void Base::push__+nop()()):nl()
       Used internally.
    it() bf(void Base::pushToken__+nop()()):nl()
       Used internally.
    it() bf(void Base::reduce__+nop()()):nl()
       Used internally.
    it() bf(void Base::top__+nop()()):nl()
       Used internally.
    )

manpagesection(PROTECTED DATA MEMBERS)

    The following private members can be used by members of parser classes
generated by bic(). All data members are actually protected
members inherited from the parser's base class. 
    itemization(
    it() bf(size_t d_acceptedTokens__):nl()
       Counts the number of accepted tokens since the start of the tt(parse())
        function or since the last detected syntactic error. It is initialized
        to tt(d_requiredTokens__) to allow an early error to be detected as
        well. 
    it() bf(bool d_debug__):nl()
       When the bf(debug) option has been specified, this variable (bf(true)
        by default) determines whether debug information is actually
        displayed.
    it() bf(LTYPE__ d_loc__):nl()
       The location type value associated with a terminal token. It can be
        used by, e.g., lexical scanners to pass location information of a
        matched token to the parser in parallel with a returned token. It is
        available only when bf(%lsp-needed, %ltype) or bf(%locationstruct) has
        been defined. nl()
       Lexical scanners may be offered the facility to assign
        a value to this variable in parallel with a returned
        token. In order to allow a scanner access to bf(d_loc__), bf(d_loc__)'s
        address should be passed to the scanner. This can be realized, for
        example, by defining a member bf(void setLoc(STYPE__ *)) in the lexical
        scanner, which is then called from the parser's constructor as
        follows:
       verb(
            d_scanner.setSLoc(&d_loc__);
       )
       Subsequently, the lexical scanner may assign a value to the parser's
        bf(d_loc__) variable through the pointer to bf(d_loc__) stored inside
        the lexical scanner.
    it() bf(LTYPE__ d_lsp__):nl()
       The location stack pointer.
        Do not modify.
    it() bf(size_t d_nErrors__):nl()
       The number of errors counted by bf(parse()). It is initialized by the
        parser's base class initializer, and is updated while bf(parse())
        executes. When bf(parse()) has returned it contains the total number
        of errors counted by bf(parse()). Errors are not counted if suppressed
        (i.e., if tt(d_acceptedTokens__) is less than tt(d_requiredTokens__)).
    it() bf(size_t d_nextToken__):nl()
       A pending token. 
        Do not modify.
    it() bf(size_t d_requiredTokens__):nl()
       Defines the minimum number of accepted tokens that the tt(parse())
        function must have processed before a syntactic error can be
        generated. 
    it() bf(int d_state__):nl()
       The current parsing state. 
        Do not modify.
    it() bf(int d_token__):nl()
       The current token.
        Do not modify.
    it() bf(STYPE__ d_val__):nl()
       The semantic value of a returned token or non-terminal symbol. With
        non-terminal tokens it is assigned a value through the action rule's
        symbol bf($$). Lexical scanners may be offered the facility to assign
        a semantic value to this variable in parallel with a returned
        token. In order to allow a scanner access to bf(d_val__),
        bf(d_val__)'s address should be passed to the scanner. This can be
        realized, for example, by defining a member bf(void setSval(STYPE__
        *)) in the lexical scanner, which is then called from the parser's
        constructor as follows:
       verb(
            d_scanner.setSval(&d_val__);
       )
       Subsequently, the lexical scanner may assign a value to the parser's
        bf(d_val__) variable through the pointer to bf(d_val__) stored inside
        the lexical scanner.
    it() bf(LTYPE__ d_vsp__):nl()
       The semantic value stack pointer. 
        Do not modify.
    )

manpagesection(TYPES AND VARIABLES IN THE ANONYMOUS NAMESPACE)
    
    In the file defining the bf(parse()) function the following types and
variables are defined in the anonymous namespace. These are mentioned here for
the sake of completeness, and are not normally accessible to other parts of
the parser.

    itemization(
    it() bf(char const author[]):nl()
       Defining the name and e-mail address of Bic()'s author.
    it() bf(ReservedTokens):nl()
       This enumeration defines some token values used internally by the
        parsing functions. They are:
        verb(
    PARSE_ACCEPT   =  0,
    _UNDETERMINED_ = -2,
    _EOF_          = -1,
    _error_        = 256,
       )
       These tokens are used by the parser to determine whether another token
        should be requested from the lexical scanner, and to handle
        error-conditions. 
    it() bf(StateType):nl()
       This enumeration defines several moe token values used internally by
        the parsing functions. They are:
        verb(
        NORMAL,
        ERR_ITEM,
        REQ_TOKEN,
        ERR_REQ,    // ERR_ITEM | REQ_TOKEN
        DEF_RED,    // state having default reduction
        ERR_DEF,    // ERR_ITEM | DEF_RED
        REQ_DEF,    // REQ_TOKEN | DEF_RED
        ERR_REQ_DEF // ERR_ITEM | REQ_TOKEN | DEF_RED
       )
       These tokens are used by the parser to define the types of the various
        states of the analyzed grammar.
    it() bf(PI__) (Production Info):nl()
       The type defines a struct containing information about the production
        rules that were used by a grammar.nl()
       Its first field contains the identification number of a production's
        defining non-terminal;nl()
       Its second field defines the number of elements of a production
    it() bf(SR__) (Shift-Reduce Info):nl()
       This bf(struct) provides the shift/reduce information for the various
        grammatical states. bf(SR__) values are collected in arrays, one array
        per grammatical state. These array, named bf(s_)tt(<nr>), 
        where tt<nr> is a state number are defined in the anonymous namespace
        as well. The bf(SR__) elements consist of two unions,
        defining fields that are applicable to, respectively, the first,
        intermediate and the last array elements.nl()
       The first element of each array consists of (1st field) a bf(StateType)
        and (2nd field) the index of the last array element;
       intermediate elements consist of (1st field) a symbol value and (2nd
        field) (if negative) the production rule number reducing to the
        indicated symbol value or (if positive) the next state when the symbol
        given in the 1st field is the current token; 
       the last element of each array consists of (1st field) a placeholder for
        the current token and (2nd field) the (negative) rule number to reduce
        to by default or the (positive) number of an error-state to go to when
        an erroneous token has been retrieved. If the 2nd field is zero, no
        error or default action has been defined for the state, and
        error-recovery is attepted.
    it() bf(STACK_EXPANSION):nl()
       An enumeration value specifying the number of additional elements that
        are added to the state- and semantic value stacks when full.
    it() bf(PI__) (Production Info):nl()
       This bf(struct) provides information about production rules. It has two
        fields: bf(d_nonTerm) is the identification number of the production's
        non-terminal, bf(d_size) represents the number of elements of the
        productin rule.
    it() bf(static PI__ s_productionInfo):nl()
       Used internally by the parsing function.
    it() bf(static SR__ s_<nr>[]):nl()
       Here, tt(<nr>) is a numerical value representing a state number.
       Used internally by the parsing function.
    it() bf(static SR__ *s_state[]):nl()
       Used internally by the parsing function.
    )

manpagesection(RESTRICTIONS ON TOKEN NAMES)

    To avoid collisions with names defined by the parser's (base) class, the
following identifiers should not be used as token nams:
    itemization(
    it() Identifiers ending in two underscores;
    it() Any of the following identifiers: tt(ABORT, ACCEPT, ERROR, clearin,
        debug), or tt(setDebug).
    )

manpagesection(OBSOLETE SYMBOLS)

    All bf(DECLARATIONS) and bf(DEFINE) symbols not listed above but defined
in bf(bison++) are obsolete with bic(). In particular, there is no bf(%header{
... %}) section anymore. Also, all bf(DEFINE) symbols related to member
functions are now obsolete. There is no need for these symbols anymore as they
can simply be declared in the class header file and defined elsewhere.
                    
manpagesection(EXAMPLE)

    Using a fairly worn-out example, we'll construct a simple calculator
below. The basic operators as well as parentheses can be used to specify
expressions, and each expression should be terminated by a newline. The
program terminates when a tt(q) is entered. Empty lines result in a mere
prompt. 

    First an associated grammar is constructed. When a syntactical error is
encountered all tokens are skipped until then next newline and a simple
message is printed using the default bf(error()) function. It is assumed that
no semantic errors occur (in particular, no divisions by zero). The grammar is
decorated with actions performed when the corresponding grammatical production
rule is recognized. The grammar itself is rather standard and straightforward,
but note the first part of the specification file, containing various other
directives, among which the bf(%scanner) directive, resulting in a
composed bf(d_scanner) object as well as an implementation of the member
function bf(int lex()). In this example, a common bf(Scanner) class
construction strategy was used: the class bf(Scanner) was derived from the
class bf(yyFlexLexer) generated by bf(flex++)(1). The actual process of
constructing a class using bf(flex++)(1) is beyond the scope of this man-page,
but bf(flex++)(1)'s specification file is mentioned below, to further complete
the example. Here is bf(bisonc++)'s input file:
        verbinclude(calculator/parser/grammar)
    Next, bic() processes this file. In the process, bic() generates the
following files from its skeletons:
    itemization(
    it() The parser's base class, which is not modified by the programmer at
all: 
        verbinclude(calculator/parser/parserbase.h)
    it() The parser class tt(parser.h) itself. In the grammar
specification various member functions are used (e.g., bf(done())) and
bf(prompt()). These functions are so small that they can very well be
implemented inline. Note that bf(done()) calls bf(ACCEPT()) to terminate
further parsing. bf(ACCEPT()) and related members (e.g., bf(ABORT())) can be
called from any member called by bf(parse()). As a consequence, action blocks
could contain mere function calls, rather than several statements, thus
minimizing the need to rerun bic() when an action is modified.

    Once bic() had created bf(parser.h) it was augmented with the required
additional members, resulting in the following final version:
        verbinclude(calculator/parser/parser.h)
    it() To complete the example, the following lexical scanner specification
was used:
        verbinclude(calculator/scanner/lexer)
    it() Since no member functions other than bf(parse()) were defined in
separate source files, only bf(parse()) includes bf(parser.ih). Since
bf(cerr) and bf(endl) are used in the grammar's actions, a tt(using namespace
std) or comparable statement is required. This was effectuated from
bf(parser.ih) Here is the implementation header declaring the standard
namespace:
        verbinclude(calculator/parser/parser.ih)
    The implementation of the parsing member function bf(parse()) is basically
irrelevant, since it should not be modified by the programmer. It was written
on the file tt(parse.cc).
    it() Finally, here is the program offering our simple calculator:
        verbinclude(calculator/calculator.cc)
    )

manpagesection(USING PARSER-CLASS SYMBOLS IN LEXICAL SCANNERS)

        Note here that although the file bf(parserbase.h), defining the
parser class' base-class, rather than the header file bf(parser.h)
defining the parser class is included, the lexical scanner may simply return
tokens of the class bf(Calculator) (e.g., bf(Calculator::NUMBER) rather than
bf(CalculatorBase::NUMBER)). In fact, using a simple bf(#define - #undef)
pair generated by the bic() respectively at the end of the base class header
the file and just before the definition of the parser class itself it is
the possible to assume in the lexical scanner that all symbols defined in the
the parser's base class are actually defined in the parser class itself. It
the should be noted that this feature can only be used to access base class
the bf(enum) and types. The actual parser class is not available by the time
the the lexical scanner is defined, thus avoiding circular class dependencies.
        
manpagefiles()
    itemization(
    it() bf(bisonc++base.h): skeleton of the parser's base class;
    it() bf(bisonc++.h): skeleton of the parser class;
    it() bf(bisonc++.ih): skeleton of the implementation header;
    it() bf(bisonc++.cc): skeleton of the member bf(parse()).
    )
manpageseealso()
    bf(bison)(1), bf(bison++)(1), bf(bison.info) (using texinfo),
    bf(flex++)(1)

    Lakos, J. (2001) bf(Large Scale C++ Software Design), Addison Wesley.nl()
    Aho, A.V., Sethi, R., Ullman, J.D. (1986) bf(Compilers), Addison Wesley.

manpagebugs()

    To avoid collisions with names defined by the parser's (base) class, the
following identifiers should not be used as token nams:
    itemization(
    it() Identifiers ending in two underscores;
    it() Any of the following identifiers: tt(ABORT, ACCEPT, ERROR, clearin,
        debug, error), or tt(setDebug).
    )

    When re-using files generated by bic() before version 2.0.0, minor
hand-modification might be necessary. The identifiers in the following list
(defined in the parser's base class) now have two underscores affixed to them:
tt(LTYPE, STYPE) and tt(Tokens). When using classes derived from the generated
parser class, the following identifiers are available in such derived classes:
tt(DEFAULT_RECOVERY_MODE, ErrorRecovery, Return, UNEXPECTED_TOKEN, d_debug,
d_loc, d_lsp, d_nErrors, d_nextToken, d_state, d_token, d_val), and tt(d_vsp).
When used in derived classes, they too need two underscores affixed to them.

    The member function tt(void lookup) (< 1.00) was replaced by tt(int
lookup). When regenerating parsers created by early versions of bf(bisonc++)
(versions before version 1.00), bf(lookup)'s prototype should be corrected by
hand, since bf(bisonc++) will not by itself rewrite the parser class's header
file.

    The em(Semantic) parser, mentioned in bf(bison++)(1) is not implemented in
bf(bisonc++)(1). According to bf(bison++)(1) the semantic parser was not
available in bf(bison++) either. It is possible that the em(Pure) parser is
now available via the tt(--thread-safe) option.

manpagesection(ABOUT bisonc++)

bf(Bisonc++) was based on bf(bison++), originally developed by Alain
Coetmeur (coetmeur@icdc.fr), R&D department (RDT), Informatique-CDC, France,
who based his work on bf(bison), GNU version 1.21. 

    Bic() version 0.98 and beyond is a complete rewrite of an LALR-1 parser
generator, closely following the construction process as described in Aho,
Sethi and Ullman's (1986) book bf(Compilers) (i.e., the em(Dragon book)).  It
the uses same grammar specification as bf(bison) and bf(bison++), and it uses
practically the same options and directives as bic() versions earlier than
0.98. Variables, declarations and macros that are obsolete were removed. 
Since bic() is a completely new program, it will most likely contain
bugs. Please report bugs to the author:
    
manpageauthor()

Frank B. Brokken (f.b.brokken@rug.nl).
