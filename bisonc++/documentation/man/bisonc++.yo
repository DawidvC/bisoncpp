NOUSERMACRO(yyparse parse lex yylex error setDebug ParserBase throw ACCEPT
        ABORT errok RECOVERING print done prompt Parse 
        debug setSval setLoc)

includefile(../../release.yo)

htmlbodyopt(text)(#27408B)
htmlbodyopt(bgcolor)(#FFFAF0)
whenhtml(mailto(Frank B. Brokken: f.b.brokken@rug.nl))

DEFINEMACRO(lsoption)(3)(\
    bf(--ARG1)=tt(ARG3) (bf(-ARG2))\
)
DEFINEMACRO(loption)(1)(\
    bf(--ARG1)\
)
DEFINEMACRO(soption)(1)(\
    bf(-ARG1)\
)

DEFINEMACRO(bic)(0)(bf(bisonc++))
DEFINEMACRO(Bic)(0)(bf(Bisonc++))
DEFINEMACRO(Cpp)(0)(bf(C++))
DEFINEMACRO(prot)(0)(tt((prot)))

DELETEMACRO(tt)
DEFINEMACRO(tt)(1)(em(ARG1))

COMMENT( man-request, section, date, distribution file, general name)
manpage(bisonc++)(1)(_CurYrs_)(bisonc++._CurVers_.tar.gz)
        (bisonc++ parser generator)

COMMENT( man-request, larger title )
manpagename(bisonc++)(Generate a C++ parser class and parsing function)

COMMENT( all other: add after () )
manpagesynopsis()
       bf(bisonc++) [OPTIONS] tt(grammar-file)

manpagedescription()

    The program bic() is based on previous work on bf(bison) by Alain Coetmeur
(coetmeur@icdc.fr), who created in the early '90s a Cpp() class encapsulating
the bf(yyparse()) function as generated by the GNU-bf(bison) parser generator.

    Initial versions of bic() (up to version 0.92) wrapped Alain's program in
a program offering a more modern user-interface, removing all old-style
(bf(C)) bf(%define) directives from bf(bison++)'s input specification file
(see below for an in-depth discussion of the differences between bf(bison++)
and bic()). Starting with version 0.98, bic() is compiled from a complete 
rebuilt of the parser generator, closely following the description of Aho,
Sethi and Ullman's em(Dragon Book). Moreover, starting with version 0.98 
bic() is now a Cpp() program, rather than a bf(C) program generating bf(C++)
code. 

    Bic() expands the concepts initially implemented in bf(bison) and
bf(bison++), offering a cleaner setup of the generated parser class. The
parser class is derived from a base-class, mainly containing the parser's
token- and type-definitions as well as several member functions which should
not be (re)defined by the programmer. 

    Most of these base-class members might also be defined directly in the
parser class, but were defined in the parser's base-class. This design results
in a very lean parser class, declaring only members that are actually defined
by the programmer or that em(must) be defined by bic() itself (e.g., the
member function bf(parse()) as well as those support functions requiring access
to facilities that are only available in the parser class itself, rather than
in the parser's base class).  

    Moreover, this design does not require the use of virtual members: the
members which are not involved in the actual parsing process may always be
(re)implemented directly by the programmer. Thus there is no need to apply or
define virtual member functions.

    Actually, bf(parse()) is initially the only public member of the parser
class generated by bic(). Remaining members are private, and those that can be
redefined by the programmer using bic() usually receive initial, very simple
default in-line implementations. The (partial) exception to this rule is the
member function bf(lex()), producing the next lexical token. For bf(lex())
either a standardized interface or a mere declaration is offerered (requiring
the programmer to provide a tailor-made implementation for bf(lex())). 

    To enforce a primitive namespace, bf(bison) used a well-known
naming-convention: all its public symbols started with tt(yy) or tt(YY).
bf(Bison++) followed bf(bison) in this respect, even though a class by itself
offers enough protection of its identifiers. Consequently, the present author
feels that these tt(yy) and tt(YY) conventions are outdated, and consequently
bic() does not generate any symbols defined in either the parser (base) class
or in the parser function starting with tt(yy) or tt(YY). Instead, all data
members have names, following a suggestion by Lakos (2001), starting with
tt(d_), and all static data members have names starting with tt(s_). This
convention was not introduced to enforce identifier protection, but to clarify
the storage type of variables. Other (local) symbols lack specific
prefixes. Furthermore, bic() allows its users to define the parser class in a
particular namespace of their own choice.


    Bic() should be used as follows:
    itemization(
    it() As usual, a grammar must be defined. Using bic() this is no
different, and the reader is referred to bf(bison)'s documentation for details
about specifying and decorating grammars.
    it() The number and function of the various bf(%define) declarations as
used by bf(bison++), however, is greatly modified. Actually, all bf(%define)
declarations are replaced by their (former) first arguments. Furthermore,
`macro-style' declarations are no longer supported or required. Finally, all
directives use lower-case characters only and do not contain underscore
characters (but sometimes hyphens). E.g., bf(%define DEBUG) is now declared as
bf(%debug); bf(%define LSP_NEEDED) is now declared as bf(%lsp-needed) (note
the hyphen).
    it() As noted, no `macro style' bf(%define) declarations are required
anymore. Instead, the normal practice of defining class members in source
files and declaring them in a class header files can be adhered to using
bic().  Basically, bic() concentrates on its main tasks: the definition of an
initial parser class and the implementation of its parsing function bf(int
parse()), leaving all other parts of the parser class' definition to the
programmer.
    it() Having specified the grammar and (usually) some directives bic() is
able to generate files defining the parser class and the implementation of the
member function bf(parse()) and its support functions. See the next section
for details about the various files that may be written by bic().
    it() All members (except for the member bf(parse())) and its support
functions must be implemented by the programmer. Of course, additional member
functions should also be declared in the parser class' header.  At the very
least the member bf(int lex()) em(must) be implemented (although a
standardized implementation can also be generated by bic()). The member
bf(lex()) is called by bf(parse()) (support functions) to obtain the next
available token. The member function bf(void error(char const *msg)) may also
be re-implemented by the programmer, but a basic in-line implementation is
provided by default. The member function bf(error()) is called when
bf(parse()) detects (syntactical) errors.
    it() The parser can now be used in a program. A very simple example would
be: 
        verb(
    int main()
    {
        Parser parser;
        return parser.parse();
    }
        )
    )

    manpagesection(GENERATED FILES)

    Bic() may create the following files:
    itemization(
    it() A file containing the implementation of the member function
bf(parse()) and its support functions. The member bf(parse()) is a public
member that can be called to parse a token-sequence according to a specified
LALR1 type grammar. The implementations of these members is by default written
on the file bf(parse.cc). There should be em(no) need for the programmer to
alter the contents of this file, as its contents change whenever the grammar
is modified. Hence it is rewritten by default. The option
bf(--no-parse-member) may be specified to prevent this file from being
(re)written. In normal circumstances, however, this option should be avoided.
    it() A file containing an initial setup of the parser class, containing
the declaration of the public member bf(parse()) and of its (private) support
members. The members bf(error()) and bf(print()) receive default in-line
implementations which may be altered by the programmer. The member bf(lex())
may receive a standard in-line implementation (see below), or it will merely
be declared, in which case the programmer em(must) provide an implementation. 
Furthermore, new members may be added to the parser class as well. By
default this file will only be created if not yet existing, using the filename
tt(<parser-class>.h) (where tt(<parser-class>) is the the name of the defined
parser class). The option bf(--force-class-header) may be used to (re)write
this file, even if already existing.
        it() A file containing the parser class' em(base class). This base
class should not be modified by the programmer. It contains types defined by
bic(), as well as several (protected) data members and member functions, which
should not be redefined by the programmer. All symbolic parser terminal tokens
are defined in this class, so it escalates these definitions in a separate
class (cf. Lakos, (2001)), thus preventing circular dependencies between the
lexical scanner and the parser (circular dependencies occur in situations
where the parser needs access to the lexical scanner class to define a lexical
scanner as one of its data members, whereas the lexical scanner, in turn,
needs access to the parser class to know about the grammar's symbolic terminal
tokens. Escalation is a way out of such circular dependencies). By default
this file will be (re)written any time bic() is called, using the filename
tt(<parser-class>base.h). The option bf(--no-baseclass-header) may be
specified to prevent the base class header file from being (re)written. In
normal circumstances, however, this option should be avoided.
        it() A file containing an em(implementation header). An implementation
header may be included by source files implementing the various member
functions of a class. The implementation header first includes its associated
class header file, followed by any directives (formerly defined in the
bf(%{header ... %}) section of the bf(bison++) parser specification file) that
are required for the proper compilation of these member functions. The
implementation header is included by the file defining bf(parse()). By default
the implementation header will be created if not yet existing, receiving the
filename tt(<parser-class>.ih).  The option bf(--force-implementation-header)
may be used to (re)write this file, even if already existing.
        it() A verbose description of the generated parser. This file is
comparable to the verbose ouput file originally generated by bf(bison++). It
is generated when the option bf(--verbose) or bf(-V) is provided. When
generated, it will use the filename tt(<parse>.output), where tt(<parse>) is
the filename (without the tt(.cc) extension) of the file containing
bf(parse())'s implementation.
        )

manpageoptions()
    If available, single letter options are listed between parentheses
following their associated long-option variants. Single letter options require
arguments if their associated long options require arguments as well.
    itemization(
    it() lsoption(baseclass-preinclude)(H)(header)nl()
           Use tt(header) as the pathname to the file preincluded in the
            parser's base-class header. This option is useful in situations
            where the base class header file refers to types which might not
            yet be known. E.g., with bf(%union) a bf(std::string *) field
            might be used. Since the class bf(std::string) might not yet be
            known to the compiler once it processes the base class header file
            we need a way to inform the compiler about these classes and
            types. The suggested procedure is to use a pre-include header file
            declaring the required types. By default tt(header) will be
            surrounded by double quotes (using, e.g., tt(#include "header")).
            When the argument is surrounded by pointed brackets
            tt(#include <header>) will be included. In the latter case,
            quotes might be required to escape interpretation by the shell
            (e.g., using tt(-H '<header>')).
    it() lsoption(baseclass-header)(b)(header)nl()
           Use tt(header) as the pathname of the file containing the parser's
            base class. This class defines, e.g., the parser's symbolic
            tokens. Defaults to the name of the parser class plus the suffix
            tt(base.h). It is generated, unless otherwise indicated (see
            bf(--no-baseclass-header) and bf(--dont-rewrite-baseclass-header)
            below).
    it() lsoption(baseclass-skeleton)(B)(skeleton)nl() 
           Use tt(skeleton) as the pathname of the file containing the
            skeleton of the parser's base class. Its filename defaults to
            tt(bisonc++base.h).
    it() lsoption(class-header)(c)(header)nl()
           Use tt(header) as the pathname of the file containing the parser
            class. Defaults to the name of the parser class plus the suffix
            tt(.h)
    it() lsoption(class-skeleton)(C)(skeleton)nl()
           Use tt(skeleton) as the pathname of the file containing the
            skeleton of the parser class. Its filename defaults to
            tt(bisonc++.h). The environment variable tt(BISON_SIMPLE_H)
            is not inspected anymore.
    it() loption(construction)nl() 
           This option may be specified to write details about the
            construction of the parsing tables to the standard output
            stream. This information is primarily useful for developers, and
            augments the information written to the verbose grammar output
            file, produced by the bf(--verbose) option.
    it() loption(debug)nl() 
           Provide bf(parse()) and its support functions with debugging code,
            showing the actual parsing process on the standard output
            stream. When included, the debugging output is active by default,
            but its activity may be controlled using the bf(setDebug(bool
            on-off)) member. Note that no tt(#ifdef DEBUG) macros are used
            anymore. By rerunning bic() without the bf(--debug) option an
            equivalent parser is generated not containing the debugging
            code. 
    it() lsoption(filenames)(f)(filename)nl()
           Specify a filename to use for all files produced by bic(). 
            Specific options overriding particular filenames are also
            available (which then, in turn, overide the name specified by this
            option).
    it() loption(force-class-header)nl()
           By default the generated class header is not overwritten once it
            has been created. This option can be used to force the
            (re)writing of the file containing the parser's class.
    it() loption(force-implementation-header)nl()
           By default the generated implementation header is not overwritten
            once it has been created. This option can be used to force the
            (re)writing of the implementation header file.
    it() loption(help) (soption(h))nl()
            Write basic usage information to the standard output stream and
            terminate. 
    it() lsoption(implementation-header)(i)(header)nl()
           Use tt(header) as the pathname of the file containing the
            implementation header. Defaults to the name of the generated
            parser class plus the suffix tt(.ih). The implementation header
            should contain all directives and declarations em(only) used by
            the implementations of the parser's member functions. It is the
            only header file that is included by the source file containing
            bf(parse())'s implementation . User defined implementation of
            other class members may use the same convention, thus
            concentrating all directives and declarations that are required
            for the compilation of other source files belonging to the parser
            class in one header file.
    it() lsoption(implementation-skeleton)(I)(skeleton)nl()
           Use tt(skeleton) as the pathname of the file containing the
            skeleton of the implementation header. Its filename defaults to
            tt(bisonc++.ih).
    it() loption(lines) (soption(l))nl() 
           Put bf(#line) preprocessor directives in the file containing the
            parser's bf(parse()) function. By including this option the
            compiler and debuggers will associate errors with lines in your
            grammar specification file, rather than with the source file
            containing the bf(parse()) function itself.
    it() loption(no-lines)nl() 
           Do not put bf(#line) preprocessor directives in the file containing
            the parser's bf(parse()) function. This option is primarily useful
            in combination with the bf(%lines) directive, to suppress that
            directive. It also overrides option bf(--lines), though.
    it() lsoption(namespace)(n)(namespace)nl()
           Define the parser base class, the paser class and the parser
            implentations in the namespace tt(namespace). By default
            no namespace is defined. If this options is used the
            implementation header will contain a commented out tt(using
            namespace) declaration for the requested namespace. 
    it() loption(no-baseclass-header)nl()
           Do not write the file containing the parser class' base class, even
            if that file doesn't yet exist. By default the file containing the
            parser's base class is (re)written each time bic() is called. Note
            that this option should normally be avoided, as the base class
            defines the symbolic terminal tokens that are returned by the
            lexical scanner. By suppressing the construction of this file any
            modification in these terminal tokens will not be communicated to
            the lexical scanner.
    it() loption(no-parse-member)nl()
           Do not write the file containing the parser's predefined parser
            member functions, even if that file doesn't yet exist. By default
            the file containing the parser's bf(parse()) member function is
            (re)written each time bic() is called. Note that this option
            should normally be avoided, as this file contains parsing
            tables which are altered whenever the grammar definition is
            modified. 
    it() lsoption(parsefun-source)(p)(source)nl()
           Define tt(source) as the name of the source file containing the
            parser member function bf(parse()). Defaults to tt(parse.cc).
    it() lsoption(parsefun-skeleton)(P)(skeleton)nl()
           Use tt(skeleton) as the pathname of the file containing the parsing
            member function's skeleton. Its filename defaults to
            tt(bisonc++.cc). The environment variable tt(BISON_SIMPLE) is not
            inspected anymore.
    it() lsoption(scanner)(s)(header)nl()
           Use tt(header) as the pathname to the file defining a class
            bf(Scanner), offering a member bf(int yylex()) producing the next
            token from the input stream to be analyzed by the parser generated
            by bic(). When this option is used the parser's member bf(int
            lex()) will be predefined as 
                verb(
    int lex()
    {
        return d_scanner.yylex();
    }
                )
           and an object tt(Scanner d_scanner) will be composed into the
            parser. The tt(d_scanner) object will be constructed using its
            default constructor. If another constructor is required, the
            parser class may be provided with an appropriate (overloaded)
            parser constructor after having constructed the default parser
            class header file using bic().  By default tt(header) will be
            surrounded by double quotes (using, e.g., tt(#include "header")).
            When the argument is surrounded by pointed brackets tt(#include
            <header>) will be included. In the latter case, quotes might be
            required to escape interpretation by the shell (e.g., using tt(-s
            '<header>')).
    it() loption(show-filenames)nl() 
           Write the names of the files that are generated to the 
            standard error stream.
    it() loption(verbose) (soption(V))nl() 
           Write a file containing verbose descriptions of
            the parser states and what is done for each type of look-ahead
            token in that state.  This file also describes all conflicts
            detected in the grammar, both those resolved by operator
            precedence and those that remain unresolved.  By default it will
            not be created, but if requested it will receive the filename
            tt(<parse>.output), where tt(<parse>) is the filename (without the
            tt(.cc) extension) of the file containing bf(parse())'s
            implementation.
    it() loption(version) (soption(v))nl()
            Display bic()'s version number and terminate.
    )

manpagesection(DIRECTIVES)

    The following directives can be used in the initial section of the
grammar specification file. When command-line options for directives exist,
they overrule the corresponding directives given in the grammar
specification file.
    itemization(
    it() bf(%baseclass-header) tt(header) nl()
           Defines the pathname of the file containing the parser's base
            class. This directive is overridden by the
            bf(--baseclass-header) or bf(-b) command-line options.
    it() bf(%baseclass-preinclude) tt(header)nl()
           Use tt(header) as the pathname to the file pre-included in the
            parser's base-class header. See the description of the
            bf(--baseclass-preinclude) option for details about this option.
            Like the convention adopted for this argument, tt(header) will (by
            default) be surrounded by double quotes.  However, when the
            argument is surrounded by pointed brackets tt(#include <header>)
            will be included.
    it() bf(%class-header) tt(header) nl()
           Defines the pathname of the file containing the parser 
            class. This directive is overridden by the
            bf(--class-header) or bf(-c) command-line options.
    it() bf(%class-name) tt(parser-class-name) nl()
           Declares the name of this parser. This directive replaces the
            bf(%name) declaration previously used by bf(bison++). It defines
            the name of the bf(C++) class that will be generated. Contrary to
            bf(bison++)'s bf(%name) declaration, bf(%class-name) may appear
            anywhere in the first section of the grammar specification
            file. However, it may be defined only once. If no bf(%class-name)
            is specified the default class name tt(Parser) will be used.
    it() bf(%debug) nl() 
           Provide bf(parse()) and its support functions with debugging code,
            showing the actual parsing process on the standard output
            stream. When included, the debugging output is active by default,
            but its activity may be controlled using the bf(setDebug(bool
            on-off)) member. Note that no tt(#ifdef DEBUG) macros are used
            anymore. By rerunning bic() without the bf(--debug) option an
            equivalent parser is generated not containing the debugging
            code. 
    it() bf(%error-verbose) nl()    
            (to do)
            if defined the parser stack is dumped when an error is detected
            by the bf(parse()) member function.
    it() bf(%filenames) tt(header) nl()
           Defines the generic name of all generated files, unless overridden
            by specific names. This directive is overridden by the
            bf(--filenames) or bf(-f) command-line options.
    it() bf(%implementation-header) tt(header) nl()
           Defines the pathname of the file containing the implementation
            header.  This directive is overridden by the
            bf(--implementation-header) or bf(-i) command-line options.
    it() bf(%lines) nl() 
           Put bf(#line) preprocessor directives in the file containing the
            parser's bf(parse()) function. It acts identically to the bf(-l)
            command line option, and is suppressed by the bf(--no-lines)
            option.
    it() bf(%lsp-needed) nl()    
           Defining this causes bic() to include code into the generated
            parser using the standard location stack.  The token-location type
            defaults to the following struct, defined in the parser's base
            class when this directive is specified: 
           verb(
    struct LTYPE
    {
        int timestamp;
        int first_line;
        int first_column;
        int last_line;
        int last_column;
        char *text;
    };
           )
    it() bf(%ltype typename) nl()    
           Specifies a user-defined token location type. 
           If bf(%ltype) is used, tt(typename) should be the name of an
            alternate (predefined) type (e.g., bf(unsigned)). It should not be
            used if a bf(%locationstruct) specification is defined (see
            below). Within the parser class, this type will be available as
            the type `bf(LTYPE)'.  All text on the line following bf(%ltype)
            is used for the tt(typename) specification. It should therefore
            not contain comment or any other characters that are not part of
            the actual type definition.
    it() bf(%namespace) tt(namespace) nl()
           Define the parser class in the namespace tt(namespace). By default
            no namespace is defined. If this options is used the
            implementation header will contain a commented out tt(using
            namespace) declaration for the requested namespace.  This
            directive is overridden by the bf(--namespace) command-line
            option.
    it() bf(%negative-dollar-indices) nl()
           Do not generate warnings when zero- or negative dollar-indices are
            used in the grammar's action blocks. Zero or negative
            dollar-indices are commonly used to implement inherited
            attributes, and should normally be avoided. When used, they can be
            specified like tt($-1) or tt($<type>-1), where tt(type) is a
            tt(%union) field-name.
    it() bf(%parsefun-source) tt(source) nl()
           Defines the pathname of the file containing the parser member
            bf(parse()). This directive is overridden by the 
            bf(--parse-source) or bf(-p) command-line options.
    it() bf(%scanner) tt(header)nl()
           Use tt(header) as the pathname to the file pre-included in the
            parser's class header. See the description of the bf(--scanner)
            option for details about this option.  Similar to the convention
            adopted for this argument, tt(header) will (by default) be
            surrounded by double quotes.  However, when the argument is
            surrounded by pointed brackets tt(#include <header>) will be
            included. Note that using this directive implies the definition
            of a composed tt(Scanner d_scanner) data member into the generated
            parser, as well as a predefined bf(int lex()) member, returning
            tt(d_scanner.yylex()). If this is inappropriate, a user defined
            implementation of bf(int lex()) must be provided.
    it() bf(%stype typename) nl()    
           The type of the semantic value of tokens.  The specification
            tt(typename) should be the name of an unstructured type (e.g.,
            bf(unsigned)). By default it is bf(int). See bf(YYSTYPE) in
            bf(bison).  It should not be used if a bf(%union) specification is
            defined.  Within the parser class, this type will be available as
            the type `bf(STYPE)'. All text on the line following bf(%stype) is
            used for the tt(typename) specification. It should therefore not
            contain comment or any other characters that are not part of the
            actual type definition.
    it() bf(%locationstruct) tt(struct-definition) nl() 
           Defines the organization of the location-struct data type
            bf(LTYPE). This struct should be specified analogously to the way
            the parser's stacktype is defined using bf(%union) (see
            below). The location struct is named bf(LTYPE). If neither
            bf(locationstruct) nor bf(LTYPE) is specified, the aforementioned
            default struct is used. 
    it() bf(%union) tt(union-definition) nl()    
            Acts identically to the bf(bison) and bf(bison++) declaration. 
            as with bison generate a union for semantic type. 
            The union is named bf(STYPE). If no bf(%union) is
            declared, a simple stack-type may be defined using the bf(%stype)
            directive. If no bf(%stype) directive is used, the default
            stacktype (bf(int)) is used.
    )

manpagesection(PUBLIC MEMBERS AND -TYPES)

    The following public members can be used by users of the parser classes
generated by bic() (tt(`Parser Class'::) prefixes are silently implied):
    itemization(
    it() bf(LTYPE):nl() 
           The parser's location type (user-definable). Available only when
            either bf(%lsp-needed, %ltype) or bf(%locationstruct) has been
            declared. 
    it() bf(STYPE):nl()
            The parser's stack-type (user-definable), defaults to bf(int).
    it() bf(Tokens):nl()
           The enumeration type of all the symbolic tokens defined in the
            grammar file (i.e., bic()'s input file). The scanner should be
            prepared to return these symbolic tokens Note that, since the
            symbolic tokens are defined in the parser's class and not in the
            scanner's class, the lexical scanner must prefix the parser's
            class name to the symbolic token names when they are
            returned. E.g., bf(return Parser::IDENT) should be used rather
            than bf(return IDENT).
    it() bf(int parse()):nl()
           The parser's parsing member function. It returns 0 when parsing has
            completed successfully, 1 if errors were encountered while parsing
            the input.
    )
    
manpagesection(PRIVATE ENUMS AND -TYPES)

    The following enumerations and types can be used by members of parser
classes generated by bic(). When prefixed by bf(Base::) they are actually
protected members inherited from the parser's base class.
    itemization(
    it() bf(Base::ErrorRecovery):nl()
        This enumeration defines two values:
        verb(
    DEFAULT_RECOVERY_MODE,
    UNEXPECTED_TOKEN
        )
       bf(DEFAULT_RECOVERY_MODE) consists of terminating the parsing
        process. bf(UNEXPECTED_TOKEN) activates the recovery procedure
        whenever an error is encountered. The recovery procedure consists of
        looking for the first state on the state-stack having an
        error-production, and then skipping subsequent tokens until (in that
        state) a token is retrieved which may follow the bf(error) terminal
        token in that production rule. If this error recovery procedure fails
        (i.e., if no acceptable token is ever encountered) error recovery
        falls back to the default recovery mode, terminating the parsing
        process. 
    it() bf(Base::Return):nl()
        This enumeration defines two values:
        verb(
    PARSE_ACCEPT = 0,
    PARSE_ABORT = 1
        )
        (which are of course the bf(parse()) function's return values).
     ))


manpagesection(PRIVATE MEMBER FUNCTIONS)

    The following private members can be used by members of parser classes
generated by bic(). When prefixed by bf(Base::) they are actually protected
members inherited from the parser's base class. 
    itemization(
    it() bf(Base::ParserBase()):nl()
        The default base-class constructor. Can be ignored in practical
            situations.
    it() bf(void Base::ABORT() const throw(Return)):nl()
       This member can be called from any member function (called from any of
        the parser's action blocks) to indicate a failure while parsing thus
        terminating the parsing function with an error value 1. Note that this
        offers a marked extension and improvement of the macro bf(YYABORT)
        defined by bf(bison++) in that bf(YYABORT) could not be called from
        outside of the parsing member function.
    it() bf(void Base::ACCEPT() const throw(Return)):nl()
       This member can be called from any member function (called from any of
        the parser's action blocks) to indicate successful parsing and thus
        terminating the parsing function. Note that this offers a marked
        extension and improvement of the macro bf(YYACCEPT) defined by
        bf(bison++) in that bf(YYACCEPT) could not be called from outside of
        the parsing member function.
    it() bf(bool Base::debug() const):nl()
       This member returns the current value of the debug variable. See
        bf(setDebug()) below.
    it() bf(void Base::ERROR+nop()() const throw(ErrorRecovery)):nl()
       This member can be called from any member function (called from any of
        the parser's action blocks) to generate an error, and thus initiate
        the parser's error recovery code. Note that this offers a marked
        extension and improvement of the macro bf(YYERROR) defined by
        bf(bison++) in that bf(YYERROR) could not be called from outside of
        the parsing member function.
    it() bf(void error(char const *msg)):nl()
       This member may be redefined in the parser class. Its default (inline)
        implementation is to write a simple message to the standard error
        stream. It is called when a syntactical error is encountered.
    it() bf(void errorRecovery+nop()()):nl()
       Used internally by the parsing function. Not to be called otherwise.
    it() bf(void executeAction+nop()()):nl()
       Used internally by the parsing function. Not to be called otherwise.
    it() bf(int lex()):nl()
       This member may be pre-implemented using the bf(scanner) option or
        directive (see above) or it em(must) be implemented by the
        programmer. It interfaces to the lexical scanner, and should
        return the next token produced by the lexical scanner, either as a
        plain character or as one of the symbolic tokens defined in the
        bf(Parser::Tokens) enumeration. Zero or negative token values are
        interpreted as `end of input'.
    it() bf(int lookup+nop()()):nl()
       Used internally by the parsing function. Not to be called
       otherwise. See also below, section bf(BUGS).
    it() bf(void nextToken+nop()()):nl()
       This member replaces bf(bison)(++)'s macro bf(yyclearin). It retrieves
        the next token from the lexical scanner, even if the current token
        hasn't been processed yet. See also below, section bf(BUGS).
    it() bf(void Base::pop+nop()()):nl()
       Used internally by the parsing function. Not to be called otherwise.
    it() bf(void print())):nl()
       This member can be redefined in the parser class to print information
        about the parser's state. It is called by the parser immediately after
        retrieving a token from bf(lex()). As it is a member function it has
        access to all the parser's members, in particular bf(d_token), the
        current token value and bf(d_loc), the current token location
        information (if bf(%lsp-needed, %ltype) or bf(%locationstruct) has
        been specified).
    it() bf(void Base::push+nop()()):nl()
       Used internally by the parsing function. Not to be called otherwise.
    it() bf(void Base::reduce+nop()()):nl()
       Used internally by the parsing function. Not to be called otherwise.
    it() bf(void Base::setDebug(bool mode)):nl()
       This member can be used to activate or deactivate the debug-code
        compiled into the parsing function. It is available, but has no
        effect, if no debug code has been compiled into the parsing
        function. When debugging code has been compiled into the parsing
        function, it is active by default, but it may be suppressed by calling
        bf(setDebug(false)).
    it() bf(void Base::top+nop()()):nl()
       Used internally by the parsing function. Not to be called otherwise.
    )

manpagesection(PRIVATE DATA MEMBERS)

    The following private members can be used by members of parser classes
generated by bic(). All data members are actually protected
members inherited from the parser's base class. 
    itemization(
    it() bf(bool d_debug):nl()
       When the bf(debug) option has been specified, this variable (bf(true)
        by default) determines whether debug information is actually
        displayed.
    it() bf(LTYPE d_loc):nl()
       The location type value associated with a terminal token. It can be
        used by, e.g., lexical scanners to pass location information of a
        matched token to the parser in parallel with a returned token. It is
        available only when bf(%lsp-needed, %ltype) or bf(%locationstruct) has
        been defined. nl()
       Lexical scanners may be offered the facility to assign
        a value to this variable in parallel with a returned
        token. In order to allow a scanner access to bf(d_loc), bf(d_loc)'s
        address should be passed to the scanner. This can be realized, for
        example, by defining a member bf(void setLoc(STYPE *)) in the lexical
        scanner, which is then called from the parser's constructor as
        follows:
       verb(
            d_scanner.setSLoc(&d_loc);
       )
       Subsequently, the lexical scanner may assign a value to the parser's
        bf(d_loc) variable through the pointer to bf(d_loc) stored inside the
        lexical scanner. 
    it() bf(LTYPE d_lsp):nl()
       The location stack pointer. Used internally by the parser. Not to be
        used otherwise.
    it() bf(STYPE d_val):nl()
       The semantic value of a returned token or non-terminal symbol. With
        non-terminal tokens it is assigned a value through the action rule's
        symbol bf($$). Lexical scanners may be offered the facility to assign
        a semantic value to this variable in parallel with a returned
        token. In order to allow a scanner access to bf(d_val), bf(d_val)'s
        address should be passed to the scanner. This can be realized, for
        example, by defining a member bf(void setSval(STYPE *)) in the lexical
        scanner, which is then called from the parser's constructor as
        follows:
       verb(
            d_scanner.setSval(&d_val);
       )
       Subsequently, the lexical scanner may assign a value to the parser's
        bf(d_val) variable through the pointer to bf(d_val) stored inside the
        lexical scanner. 
    it() bf(LTYPE d_vsp):nl()
       The semantic value stack pointer. Used internally by the parser. Not to
        be used otherwise.
    it() bf(unsigned d_nErrors):nl()
       The number of errors counted by bf(parse()). It is initialized by the
        parser's base class initializer, and is updated while bf(parse())
        executes. When bf(parse()) has returned it contains the total number
        of errors counted by bf(parse()).
    it() bf(int d_state):nl()
       The current parsing state. Used internally by the parsing function. Not
        to be used otherwise.
    it() bf(int d_token):nl()
       The current token used internally by the parser. The parser may modify
        the token value retrieved via bf(lex()), so bf(d_token) may not be the
        value of the last token actually retrieved by bf(lex()).
    it() bf(static PI s_productionInfo):nl()
       Used internally by the parsing function. Not to be used otherwise.
    it() bf(static SR s_<nr>[]):nl()
       Here, tt(<nr>) is a numerical value representing a state number.
       Used internally by the parsing function. Not to be used otherwise.
    it() bf(static SR *s_state[]):nl()
       Used internally by the parsing function. Not to be used otherwise.
    )

manpagesection(TYPES AND VARIABLES IN THE ANONYMOUS NAMESPACE)
    
    In the file defining the bf(parse()) function the following types and
variables are defined in the anonymous namespace. These are mentioned here for
the sake of completeness, and are not normally accessible to other parts of
the parser.

    itemization(
    it() bf(ReservedTokens):nl()
       This enumeration defines some token values used internally by the
        parsing functions. They are:
        verb(
    _UNDETERMINED_ = -2,
    _EOF_          = -1,
    _error_        = 256,
       )
       These tokens are used by the parser to determine whether another token
        should be requested from the lexical scanner, and to handle
        error-conditions. 
    it() bf(SR) (Shift-Reduce Info):nl()
       This bf(struct) provides the shift/reduce information for the various
        grammatical states. bf(SR) values are collected in arrays, one array
        per grammatical state. These array, named bf(s_)tt(<nr>), 
        where tt<nr> is a state number are defined in the anonymous namespace
        as well. The bf(SR) elements consist of two unions,
        defining fields that are applicable to, respectively, the first,
        intermediate and the last array elements.nl()
       The first element of each array consists of (1st field) a bf(StateType)
        and (2nd field) the index of the last array element;
       intermediate elements consist of (1st field) a symbol value and (2nd
        field) (if negative) the production rule number reducing to the
        indicated symbol value or (if positive) the next state when the symbol
        given in the 1st field is the current token; 
       the last element of each array consists of (1st field) a placeholder for
        the current token and (2nd field) the (negative) rule number to reduce
        to by default or the (positive) number of an error-state to go to when
        an erroneous token has been retrieved. If the 2nd field is zero, no
        error or default action has been defined for the state, and
        error-recovery is attepted.
    it() bf(StateType):nl()
       This enumeration defines the type of the various grammar-states. They
        are: 
        verb(
    NORMAL,
    HAS_ERROR_ITEM,
    IS_ERROR_STATE,
       )
       bf(HAS_ERROR_ITEM) is used for a state having at least one
        error-production. bf(IS_ERROR_STATE) is used for a state from which
        error recovery is attempted. So, while in these states tokens are
        retrieved until a token from where parsing may continue is seen by the
        parser. All other states are bf(NORMAL) states.
    it() bf(PI) (Production Info):nl()
       This bf(struct) provides information about production rules. It has two
        fields: bf(d_nonTerm) is the identification number of the production's
        non-terminal, bf(d_size) represents the number of elements of the
        productin rule.
    )

manpagesection(OBSOLETE SYMBOLS)

    All bf(DECLARATIONS) and bf(DEFINE) symbols not listed above but defined
in bf(bison++) are obsolete with bic(). In particular, there is no bf(%header{
... %}) section anymore. Also, all bf(DEFINE) symbols related to member
functions are now obsolete. There is no need for these symbols anymore as they
can simply be declared in the class header file and defined elsewhere.
                    
manpagesection(EXAMPLE)

    Using a fairly worn-out example, we'll construct a simple calculator
below. The basic operators as well as parentheses can be used to specify
expressions, and each expression should be terminated by a newline. The
program terminates when a tt(q) is entered. Empty lines result in a mere
prompt. 

    First an associated grammar is constructed. When a syntactical error is
encountered all tokens are skipped until then next newline and a simple
message is printed using the default bf(error()) function. It is assumed that
no semantic errors occur (in particular, no divisions by zero). The grammar is
decorated with actions performed when the corresponding grammatical production
rule is recognized. The grammar itself is rather standard and straightforward,
but note the first part of the specification file, containing various other
directives, among which the bf(%scanner) directive, resulting in a
composed bf(d_scanner) object as well as an implementation of the member
function bf(int lex()). In this example, a common bf(Scanner) class
construction strategy was used: the class bf(Scanner) was derived from the
class bf(yyFlexLexer) generated by bf(flex++)(1). The actual process of
constructing a class using bf(flex++)(1) is beyond the scope of this man-page,
but bf(flex++)(1)'s specification file is mentioned below, to further complete
the example. Here is bf(bisonc++)'s input file:
        verbinclude(calculator/parser/grammar)
    Next, bic() processes this file. In the process, bic() generates the
following files from its skeletons:
    itemization(
    it() The parser's base class, which is not modified by the programmer at
all: 
        verbinclude(calculator/parser/calculatorbase.h)
    it() The parser class tt(calculator.h) itself. In the grammar
specification various member functions are used (e.g., bf(done())) and
bf(prompt()). These functions are so small that they can very well be
implemented inline. Note that bf(done()) calls bf(ACCEPT()) to terminate
further parsing. bf(ACCEPT()) and related members (e.g., bf(ABORT())) can be
called from any member called by bf(parse()). As a consequence, action blocks
could contain mere function calls, rather than several statements, thus
minimizing the need to rerun bic() when an action is modified.

    Once bic() had created bf(calculator.h) it was augmented with the required
additional members, resulting in the following final version:
        verbinclude(calculator/parser/calculator.h)
    it() To complete the example, the following lexical scanner specification
was used:
        verbinclude(calculator/scanner/lexer)
    it() Since no member functions other than bf(parse()) were defined in
separate source files, only bf(parse()) includes bf(calculator.ih). Since
bf(cerr) and bf(endl) are used in the grammar's actions, a tt(using namespace
std) or comparable statement is required. This was effectuated from
bf(calculator.ih) Here is the implementation header declaring the standard
namespace:
        verbinclude(calculator/parser/calculator.ih)
    The implementation of the parsing member function bf(parse()) is basically
irrelevant, since it should not be modified by the programmer. It was written
on the file tt(parse.cc).
    it() Finally, here is the program offering our simple calculator:
        verbinclude(calculator/calculator.cc)
    )

manpagesection(USING PARSER-CLASS SYMBOLS IN LEXICAL SCANNERS)

        Note here that although the file bf(calculatorbase.h), defining the
parser class' base-class, rather than the header file bf(calculator.h)
defining the parser class is included, the lexical scanner may simply return
tokens of the class bf(Calculator) (e.g., bf(Calculator::NUMBER) rather than
bf(CalculatorBase::NUMBER)). In fact, using a simple bf(#define - #undef)
pair generated by the bic() respectively at the end of the base class header
the file and just before the definition of the parser class itself it is
the possible to assume in the lexical scanner that all symbols defined in the
the parser's base class are actually defined in the parser class itself. It
the should be noted that this feature can only be used to access base class
the bf(enum) and types. The actual parser class is not available by the time
the the lexical scanner is defined, thus avoiding circular class dependencies.
        
manpagefiles()
    itemization(
    it() bf(bisonc++base.h): skeleton of the parser's base class;
    it() bf(bisonc++.h): skeleton of the parser class;
    it() bf(bisonc++.ih): skeleton of the implementation header;
    it() bf(bisonc++.cc): skeleton of the member bf(parse()).
    )
manpageseealso()
    bf(bison)(1), bf(bison++)(1), bf(bison.info) (using texinfo),
    bf(flex++)(1)

    Lakos, J. (2001) bf(Large Scale C++ Software Design), Addison Wesley.nl()
    Aho, A.V., Sethi, R., Ullman, J.D. (1986) bf(Compilers), Addison Wesley.

manpagebugs()
    The em(Semantic)- and em(Pure) parsers, mentioned in bf(bison++)(1) are
not implemented in bf(bisonc++)(1). According to bf(bison++)(1) the semantic
parser was not available in bf(bison++) either, while the pure parser was
deemed `not very useful'.

    The previously (< 1.00) defined function bf(clearin) is removed from the
private interface. Instead, bf(void nextToken) should be used. Note that this
member now has a bf(void) return type. When regenerating parsers created by
early versions of bf(bisonc++) (versions before version 1.00), bf(nextToken)'s
prototype should be corrected by hand, since bf(bisonc++) will not by itself
rewrite the parser class's header file.

    The member function tt(void lookup) (< 1.00) was replaced by tt(int
lookup). When regenerating parsers created by early versions of bf(bisonc++)
(versions before version 1.00), bf(lookup)'s prototype should be corrected by
hand, since bf(bisonc++) will not by itself rewrite the parser class's header
file.

manpagesection(ABOUT bisonc++)

bf(Bisonc++) was based on bf(bison++), originally developed by Alain
Coetmeur (coetmeur@icdc.fr), R&D department (RDT), Informatique-CDC, France,
who based his work on bf(bison), GNU version 1.21. 

    Bic() version 0.98 and beyond is a complete rewrite of an LALR-1 parser
generator, closely following the construction process as described in Aho,
Sethi and Ullman's (1986) book bf(Compilers) (i.e., the em(Dragon book)).  It
the uses same grammar specification as bf(bison) and bf(bison++), and it uses
practically the same options and directives as bic() versions earlier than
0.98. Variables, declarations and macros that are obsolete were removed. 
Since bic() is a completely new program, it will most likely contain
bugs. Please report bugs to the author:
    
manpageauthor()

Frank B. Brokken (f.b.brokken@rug.nl).
