NOUSERMACRO(yyparse parse lex yylex error setDebug ParserBase throw ACCEPT
        ABORT errok RECOVERING print done prompt Parse yyrestart
        debug setSval setLoc)

includefile(../../release.yo)

htmlbodyopt(text)(#27408B)
htmlbodyopt(bgcolor)(#FFFAF0)
whenhtml(mailto(Frank B. Brokken: f.b.brokken@rug.nl))

DEFINEMACRO(lsoption)(3)(\
    bf(--ARG1)=tt(ARG3) (bf(-ARG2))\
)
DEFINEMACRO(laoption)(2)(\
    bf(--ARG1)=tt(ARG2)\
)
DEFINEMACRO(loption)(1)(\
    bf(--ARG1)\
)
DEFINEMACRO(soption)(1)(\
    bf(-ARG1)\
)

DEFINEMACRO(bic)(0)(bf(bisonc++))
DEFINEMACRO(Bic)(0)(bf(Bisonc++))
DEFINEMACRO(Cpp)(0)(bf(C++))
DEFINEMACRO(prot)(0)(tt((prot)))

DELETEMACRO(tt)
DEFINEMACRO(tt)(1)(em(ARG1))

COMMENT( man-request, section, date, distribution file, general name)
manpage(bisonc++)(1)(_CurYrs_)(bisonc++._CurVers_.tar.gz)
        (bisonc++ parser generator)

COMMENT( man-request, larger title )
manpagename(bisonc++)(Generate a C++ parser class and parsing function)

COMMENT( all other: add after () )
manpagesynopsis()
       bf(bisonc++) [OPTIONS] tt(grammar-file)

manpagedescription()

    The program bic() is based on previous work on bf(bison) by Alain Coetmeur
(coetmeur@icdc.fr), who created in the early '90s a Cpp() class encapsulating
the tt(yyparse) function as generated by the GNU-bf(bison) parser generator.

    Initial versions of bic() (up to version 0.92) wrapped Alain's program in
a program offering a more modern user-interface, removing all old-style
(bf(C)) tt(%define) directives from bf(bison++)'s input specification file
(see below for an in-depth discussion of the differences between bf(bison++)
and bic()). Starting with version 0.98, bic() is compiled from a complete 
rebuilt of the parser generator, closely following the description of Aho,
Sethi and Ullman's em(Dragon Book). Moreover, starting with version 0.98 
bic() is now a Cpp() program, rather than a bf(C) program generating bf(C++)
code. 

    Bic() expands the concepts initially implemented in bf(bison) and
bf(bison++), offering a cleaner setup of the generated parser class. The
parser class is derived from a base-class, mainly containing the parser's
token- and type-definitions as well as several member functions which should
not be (re)defined by the programmer. 

    Most of these base-class members might also be defined directly in the
parser class, but were defined in the parser's base-class. This design results
in a very lean parser class, declaring only members that are actually defined
by the programmer or that em(must) be defined by bic() itself (e.g., the
member function tt(parse) as well as those support functions requiring access
to facilities that are only available in the parser class itself, rather than
in the parser's base class).  

    Moreover, this design does not require the use of virtual members: the
members which are not involved in the actual parsing process may always be
(re)implemented directly by the programmer. Thus there is no need to apply or
define virtual member functions.

    In fact, there are only two public members in the parser class generated
by bic(): tt(setDebug) (see below) and tt(parse). Remaining members are
private, and those that can be redefined by the programmer using bic() usually
receive initial, very simple default in-line implementations. The (partial)
exception to this rule is the member function tt(lex), producing the next
lexical token. For tt(lex) either a standardized interface or a mere
declaration is offerered (requiring the programmer to provide a tailor-made
implementation for tt(lex)).

    To enforce a primitive namespace, bf(bison) used a well-known
naming-convention: all its public symbols started with tt(yy) or tt(YY).
bf(Bison++) followed bf(bison) in this respect, even though a class by itself
offers enough protection of its identifiers. Consequently, the present author
feels that these tt(yy) and tt(YY) conventions are outdated, and consequently
bic() does not generate any symbols defined in either the parser (base) class
or in the parser function starting with tt(yy) or tt(YY). Instead, all data
members have names, following a suggestion by Lakos (2001), starting with
tt(d_), and all static data members have names starting with tt(s_). This
convention was not introduced to enforce identifier protection, but to clarify
the storage type of variables. Other (local) symbols lack specific
prefixes. Furthermore, bic() allows its users to define the parser class in a
particular namespace of their own choice.

    Bic() should be used as follows:
    itemization(
    it() As usual, a grammar must be defined. Using bic() this is no
different, and the reader is referred to bf(bison)'s documentation for details
about specifying and decorating grammars.
    it() The number and function of the various tt(%define) declarations as
used by bf(bison++), however, is greatly modified. Actually, all tt(%define)
declarations are replaced by their (former) first arguments. Furthermore,
`macro-style' declarations are no longer supported or required. Finally, all
directives use lower-case characters only and do not contain underscore
characters (but sometimes hyphens). E.g., tt(%define DEBUG) is now declared as
tt(%debug); tt(%define LSP_NEEDED) is now declared as tt(%lsp-needed) (note
the hyphen).
    it() As noted, no `macro style' tt(%define) declarations are required
anymore. Instead, the normal practice of defining class members in source
files and declaring them in a class header files can be adhered to using
bic().  Basically, bic() concentrates on its main tasks: the definition of an
initial parser class and the implementation of its parsing function tt(int
parse), leaving all other parts of the parser class' definition to the
programmer.
    it() Having specified the grammar and (usually) some directives bic() is
able to generate files defining the parser class and the implementation of the
member function tt(parse) and its support functions. See the next section
for details about the various files that may be written by bic().
    it() All members (except for the member tt(parse)) and its support
functions must be implemented by the programmer. Of course, additional member
functions should also be declared in the parser class' header.  At the very
least the member tt(int lex()) em(must) be implemented (although a
standardized implementation can also be generated by bic()). The member
tt(lex) is called by tt(parse) (support functions) to obtain the next
available token. The member function tt(void error(char const *msg)) may also
be re-implemented by the programmer, but a basic in-line implementation is
provided by default. The member function tt(error) is called when
tt(parse) detects (syntactic) errors.
    it() The parser can now be used in a program. A very simple example would
be: 
        verb(
    int main()
    {
        Parser parser;
        return parser.parse();
    }
        )
    )

    manpagesection(GENERATED FILES)

    Bic() may create the following files:
    itemization(
    it() A file containing the implementation of the member function
tt(parse) and its support functions. The member tt(parse) is a public
member that can be called to parse a token-sequence according to a specified
LALR1 type grammar. The implementations of these members is by default written
on the file tt(parse.cc). There should be em(no) need for the programmer to
alter the contents of this file, as its contents change whenever the grammar
is modified. Hence it is rewritten by default. The option
tt(--no-parse-member) may be specified to prevent this file from being
(re)written. In normal circumstances, however, this option should be avoided.
    it() A file containing an initial setup of the parser class, containing
the declaration of the public member tt(parse) and of its (private) support
members. The members tt(error) and tt(print) receive default in-line
implementations which may be altered by the programmer. The member tt(lex)
may receive a standard in-line implementation (see below), or it will merely
be declared, in which case the programmer em(must) provide an implementation. 
Furthermore, new members may be added to the parser class as well. By
default this file will only be created if not yet existing, using the filename
tt(<parser-class>.h) (where tt(<parser-class>) is the the name of the defined
parser class). The option tt(--force-class-header) may be used to (re)write
this file, even if already existing.
        it() A file containing the parser class' em(base class). This base
class should not be modified by the programmer. It contains types defined by
bic(), as well as several (protected) data members and member functions, which
should not be redefined by the programmer. All symbolic parser terminal tokens
are defined in this class, so it escalates these definitions in a separate
class (cf. Lakos, (2001)), thus preventing circular dependencies between the
lexical scanner and the parser (circular dependencies occur in situations
where the parser needs access to the lexical scanner class to define a lexical
scanner as one of its data members, whereas the lexical scanner, in turn,
needs access to the parser class to know about the grammar's symbolic terminal
tokens. Escalation is a way out of such circular dependencies). By default
this file is (re)written any time bic() is called, using the filename
tt(<parser-class>base.h). The option tt(--no-baseclass-header) may be
specified to prevent the base class header file from being (re)written. In
normal circumstances, however, this option should be avoided.
        it() A file containing an em(implementation header). An implementation
header may be included by source files implementing the various member
functions of a class. The implementation header first includes its associated
class header file, followed by any directives (formerly defined in the
tt(%{header ... %}) section of the bf(bison++) parser specification file) that
are required for the proper compilation of these member functions. The
implementation header is included by the file defining tt(parse). By default
the implementation header is created if not yet existing, receiving the
filename tt(<parser-class>.ih).  The option tt(--force-implementation-header)
may be used to (re)write this file, even if already existing.
        it() A verbose description of the generated parser. This file is
comparable to the verbose ouput file originally generated by bf(bison++). It
is generated when the option tt(--verbose) or tt(-V) is provided. When
generated, it will use the filename tt(<grammar>.output), where tt(<grammar>)
is the name of the file containing the grammar definition.
        )

manpageoptions()
    include(../manual/invoking/options.yo)

manpagesection(DIRECTIVES)

    The following directives can be used in the initial section of the grammar
specification file. When command-line options for directives exist, they
overrule the corresponding directives given in the grammar specification file.
Directives affecting the class header or implementation header file are
ignored if these files already exist.  
    itemization(
    it() bf(%baseclass-header) tt(header) nl()
           Defines the pathname of the file containing the parser's base
            class. This directive is overridden by the
            tt(--baseclass-header) or tt(-b) command-line options.
    it() bf(%baseclass-preinclude) tt(header)nl()
           Use tt(header) as the pathname to the file pre-included in the
            parser's base-class header. See the description of the
            tt(--baseclass-preinclude) option for details about this option.
            Like the convention adopted for this argument, tt(header) will (by
            default) be surrounded by double quotes.  However, when the
            argument is surrounded by pointed brackets tt(#include <header>)
            is included.
    it() bf(%class-header) tt(header) nl()
           Defines the pathname of the file containing the parser 
            class. This directive is overridden by the
            tt(--class-header) or tt(-c) command-line options.
    it() bf(%class-name) tt(parser-class-name) nl()
           Declares the name of this parser. This directive replaces the
            tt(%name) declaration previously used by bf(bison++). It defines
            the name of the bf(C++) class that is generated. Contrary to
            bf(bison++)'s tt(%name) declaration, tt(%class-name) may appear
            anywhere in the first section of the grammar specification
            file. However, it may be defined only once. If no tt(%class-name)
            is specified the default class name tt(Parser) is used.
    it() bf(%debug) nl() 
           Provide tt(parse) and its support functions with debugging code,
            showing the actual parsing process on the standard output
            stream. When included, the debugging output is active by default,
            but its activity may be controlled using the tt(setDebug(bool
            on-off)) member. Note that no tt(#ifdef DEBUG) macros are used
            anymore. By rerunning bic() without the tt(--debug) option an
            equivalent parser is generated not containing the debugging
            code. 
    it() bf(%error-verbose) nl()    
           When a syntactic error is reported, the generated parse function
            will dump the parser's state stack to the standard output
            stream. The stack dump shows on separate lines a stack index
            followed by the state stored at the indicated stack element. The
            first stack element is the stack's top element.
    it() bf(%expect) tt(number) nl()    
            If defined the parser will not report encountered shift/reduce and
            reduce/reduce conflicts if all detected conflicts are equal to the
            number following tt(%expect). Conflicts are mentioned in the
            tt(.output) file and the number of encountered conflicts is shown
            on the standard output if the actual number of conflicts deviates
            from tt(number).
    it() bf(%filenames) tt(header) nl()
           Defines the generic name of all generated files, unless overridden
            by specific names. This directive is overridden by the
            tt(--filenames) or tt(-f) command-line options.
    it() bf(%flex) nl()
           When provided, the scanner matched text function is called as
            tt(d_scanner.YYText()), and the scanner token function is called
            as tt(d_scanner.yylex()). This directive is only interpreted if
            the tt(%scanner) directive is also provided.
    it() bf(%implementation-header) tt(header) nl()
           Defines the pathname of the file containing the implementation
            header.  This directive is overridden by the
            tt(--implementation-header) or tt(-i) command-line options.
    it() bf(%include) tt(path) nl() 
            This directive may be used to read part of the grammar
            specification file from the file specified at tt(path). Unless
            tt(path) is an absolute file-path, tt(path) is searched relative
            to the location of bic()'s grammar specification file. This
            directive can be used to split long grammar specification files in
            shorter, meaningful units. 
    it() bf(%left) tt(terminal ...) nl()    
            Defines the names of symbolic terminal tokens that should be
            treated as left-associative. I.e., in case of a shift/reduce
            conflict, a reduction is preferred over a shift.
            Sequences of tt(%left, %nonassoc, %right) and tt(%token)
            directives may be used to define the precedence of operators. In
            expressions, the first used directive will have the lowest
            precedence, the last used the highest. See also tt(%token) below.
    it() bf(%locationstruct) tt(struct-definition) nl() 
       Defines the organization of the location-struct data type
        tt(LTYPE__). This struct should be specified analogously to the way
        the parser's stacktype is defined using tt(%union) (see below). The
        location struct is named tt(LTYPE__). If neither tt(locationstruct)
        nor tt(LTYPE__) is specified, the aforementioned default struct is
        used.
    it() bf(%lsp-needed) nl()    
           Defining this causes bic() to include code into the generated
            parser using the standard location stack.  The token-location type
            defaults to the following struct, defined in the parser's base
            class when this directive is specified: 
           verb(
    struct LTYPE__
    {
        int timestamp;
        int first_line;
        int first_column;
        int last_line;
        int last_column;
        char *text;
    };
           )
    it() bf(%ltype typename) nl()    
           Specifies a user-defined token location type. 
           If tt(%ltype) is used, tt(typename) should be the name of an
            alternate (predefined) type (e.g., tt(size_t)). It should not be
            used if a tt(%locationstruct) specification is defined (see
                below). Within the parser class, this type is available as
            the type `tt(LTYPE__)'.  All text on the line following tt(%ltype)
            is used for the tt(typename) specification. It should therefore
            not contain comment or any other characters that are not part of
            the actual type definition.
    it() bf(%namespace) tt(namespace) nl()
           Define the parser class in the namespace tt(namespace). By default
            no namespace is defined. If this options is used the
            implementation header will contain a commented out tt(using
            namespace) declaration for the requested namespace.  This
            directive is overridden by the tt(--namespace) command-line
            option.
    it() bf(%negative-dollar-indices) nl()
           Do not generate warnings when zero- or negative dollar-indices are
            used in the grammar's action blocks. Zero or negative
            dollar-indices are commonly used to implement inherited
            attributes, and should normally be avoided. When used, they can be
            specified like tt($-1) or tt($<type>-1), where tt(type) is a
            tt(%union) field-name.
    it() bf(%no-lines) nl() 
           By default tt(#line) preprocessor directives are inserted just
            before action statements in the file containing the parser's
            tt(parse) function. These directives are suppressed by the
            tt(%no-lines) directive.
    it() bf(%nonassoc) tt(terminal ...) nl()    
            Defines the names of symbolic terminal tokens that should be
            treated as non-associative. I.e., in case of a shift/reduce
            conflict, a reduction is preferred over a shift.
            Sequences of tt(%left, %nonassoc, %right) and tt(%token)
            directives may be used to define the precedence of operators. In
            expressions, the first used directive will have the lowest
            precedence, the last used the highest. See also tt(%token) below.
    it() bf(%parsefun-source) tt(source) nl()
           Defines the pathname of the file containing the parser member
            tt(parse). This directive is overridden by the 
            tt(--parse-source) or tt(-p) command-line options.
    it() bf(%polymorphic) tt(polymorphic-specification(s))

            Bison's traditional way to handle multiple semantic values is to
            use a tt(%union) specification (see below). Although tt(%union) is
            still supported by bic(), a polymorphic semantic value class is
            actually preferred due to its improved type safety.

            The tt(%polymorphic) directive defines such a polymorphic semantic
            value class and can be used instead of a tt(%union)
            specification. Refer to section bf(POLYMORPHIC SEMANTIC VALUES)
            below for a detailed description of the specification,
            characteristics, and use of polymorphic semantic values as defined
            by bic.

    it() bf(%prec) tt(token) nl()    
            Overrules the defined precendence of an operator for a particular
            grammatic rule. Well known is the construction
                verb(
    expression:
        '-' expression %prec UMINUS
        {
            ...
        }
                )
            Here, the default priority and precedence of the `tt(-)' token as
            the subtraction operator is overruled by the precedence and
            priority of the tt(UMINUS) token, which is commonly defined as 
                verb(
    %right UMINUS
                )
            (see below) following, e.g., the tt('*') and tt('/') operators.

    it() bf(%print-tokens) nl()
           The tt(print) directive provides an implementation of the Parser
            class's tt(print__) function displaying the current token value
            and the text matched by the lexical scanner as received by the
            generated tt(parse) function.
    it() bf(%required-tokens) tt(number)nl()
           Following a syntactic error, require at least tt(number)
            successfully processed tokens before another syntactic error can
            be reported. By default tt(number) is zero.
    it() bf(%right) tt(terminal ...) nl()    
            Defines the names of symbolic terminal tokens that should be
            treated as right-associative. I.e., in case of a shift/reduce
            conflict, a shift is preferred over a reduction.
            Sequences of tt(%left, %nonassoc, %right) and tt(%token)
            directives may be used to define the precedence of operators. In
            expressions, the first used directive will have the lowest
            precedence, the last used the highest. See also tt(%token) below.
    it() bf(%scanner) tt(header)nl()
           Use tt(header) as the pathname to the file pre-included in the
            parser's class header. See the description of the tt(--scanner)
            option for details about this option.  Similar to the convention
            adopted for this argument, tt(header) will (by default) be
            surrounded by double quotes.  However, when the argument is
            surrounded by pointed brackets tt(#include <header>) is
            included. Note that using this directive implies the definition
            of a composed tt(Scanner d_scanner) data member into the generated
            parser, as well as a predefined tt(int lex()) member, returning
            tt(d_scanner.lex()). 

            By specifying the tt(%flex) directive the function
            tt(d_scanner.yylex()) is called. Any other function to call can be
            specified using the tt(--scanner-token-function) option (or
            tt(%scanner-token-function) directive).

    it() bf(%scanner-matched-text-function) tt(function-call) nl() 
           The scanner function returning the text that was matched by the
            lexical scanner after its token function (see below) has
            returned. A complete function call expression should be provided
            (including a scanner object, if used).  Example: 
                verb(
    %scanner-matched-text-function myScanner.matchedText()
                )
           By specifying the tt(%flex) directive the function
            tt(d_scanner.YYText()) is called.

           If the function call contains white space
            tt(scanner-token-function) should be surrounded by double quotes.

    it() bf(%scanner-token-function) tt(function-call) nl() 
           The scanner function returning the next token, called from the
            generated parser's tt(lex) function. A complete function
            call expression should be provided (including a scanner object, if
            used). Example: 
            verb(
    %scanner-token-function d_scanner.lex()
                )
           If the function call contains white space
            tt(scanner-token-function) should be surrounded by double quotes.
    it() bf(%start) tt(non-terminal) nl()    
            The non-terminal tt(non-terminal) should be used as the grammar's 
            start-symbol. If omitted, the first grammatic rule is used
            as the grammar's starting rule. All syntactically correct
            sentences must be derivable from this starting rule.
    it() bf(%stype typename) nl() 
       The type of the semantic value of tokens.  The specification
        tt(typename) should be the name of an unstructured type (e.g.,
        tt(size_t)). By default it is tt(int). See tt(YYSTYPE) in bf(bison).
        It should not be used if a tt(%union) specification is defined.
        Within the parser class, this type is available as the type
        `tt(STYPE__)'. All text on the line following tt(%stype) is used for
        the tt(typename) specification. It should therefore not contain
        comment or any other characters that are not part of the actual type
        definition.

    it() bf(%target-directory directory) nl() 
           Specifies the directory where generated files should be written.
            By default this is the directory of bic()'s input file.  The
            tt(%target-directory) directive does not affect files that were
            explicitly named (either as option or as directive).

    it() bf(%token) tt(terminal ...) nl()    
            Defines the names of symbolic terminal tokens.
            Sequences of tt(%left, %nonassoc, %right) and tt(%token)
            directives may be used to define the precedence of operators. In
            expressions, the first used directive will have the lowest
            precedence, the last used the highest.nl()
            bf(NOTE:) Symbolic tokens are defined as tt(enum)-values in the
            parser's base class. The names of symbolic tokens may not be equal
            to the names of the members and types defined by bic()
            itself (see the next sections). This requirement is em(not)
            currently enforced by bic(), but unexpected compilation errors may
            result if this requirement is violated.
    it() bf(%type) tt(<type> non-terminal ...) nl()    
            In combination with tt(%union): associate the semantical value of
            a non-terminal symbol with a union field defined by the tt(%union)
            directive.
    it() bf(%union) tt(union-definition) nl()    
            Acts identically to the bf(bison) and bf(bison++) declaration. 
            as with bison generate a union for semantic type. 
            The union type is named bf(STYPE__). If no tt(%union) is
            declared, a simple stack-type may be defined using the tt(%stype)
            directive. If no tt(%stype) directive is used, the default
            stacktype (bf(int)) is used.
    )

manpagesection(POLYMORPHIC SEMANTIC VALUES)

manpagesection(PUBLIC MEMBERS AND -TYPES)

    includefile(../manual/class/public.yo)
    
manpagesection(PROTECTED ENUMS AND -TYPES)

    includefile(../manual/class/privenum.yo)

manpagesection(PRIVATE MEMBER FUNCTIONS)

    includefile(../manual/class/privmembers.yo)

manpagesection(PROTECTED DATA MEMBERS)

    The following private members can be used by members of parser classes
generated by bic(). All data members are actually protected
members inherited from the parser's base class. 
    itemization(
    it() bf(size_t d_acceptedTokens__):nl()
       Counts the number of accepted tokens since the start of the tt(parse())
        function or since the last detected syntactic error. It is initialized
        to tt(d_requiredTokens__) to allow an early error to be detected as
        well. 
    it() bf(bool d_debug__):nl()
       When the tt(debug) option has been specified, this variable (tt(true)
        by default) determines whether debug information is actually
        displayed.
    it() bf(LTYPE__ d_loc__):nl()
       The location type value associated with a terminal token. It can be
        used by, e.g., lexical scanners to pass location information of a
        matched token to the parser in parallel with a returned token. It is
        available only when tt(%lsp-needed, %ltype) or tt(%locationstruct) has
        been defined. nl()
       Lexical scanners may be offered the facility to assign
        a value to this variable in parallel with a returned
        token. In order to allow a scanner access to tt(d_loc__), tt(d_loc__)'s
        address should be passed to the scanner. This can be realized, for
        example, by defining a member tt(void setLoc(STYPE__ *)) in the lexical
        scanner, which is then called from the parser's constructor as
        follows:
       verb(
            d_scanner.setSLoc(&d_loc__);
       )
       Subsequently, the lexical scanner may assign a value to the parser's
        tt(d_loc__) variable through the pointer to tt(d_loc__) stored inside
        the lexical scanner.
    it() bf(LTYPE__ d_lsp__):nl()
       The location stack pointer.
        Do not modify.
    it() bf(size_t d_nErrors__):nl()
       The number of errors counted by tt(parse). It is initialized by the
        parser's base class initializer, and is updated while tt(parse)
        executes. When tt(parse) has returned it contains the total number
        of errors counted by tt(parse). Errors are not counted if suppressed
        (i.e., if tt(d_acceptedTokens__) is less than tt(d_requiredTokens__)).
    it() bf(size_t d_nextToken__):nl()
       A pending token. 
        Do not modify.
    it() bf(size_t d_requiredTokens__):nl()
       Defines the minimum number of accepted tokens that the tt(parse)
        function must have processed before a syntactic error can be
        generated. 
    it() bf(int d_state__):nl()
       The current parsing state. 
        Do not modify.
    it() bf(int d_token__):nl()
       The current token.
        Do not modify.
    it() bf(STYPE__ d_val__):nl()
       The semantic value of a returned token or non-terminal symbol. With
        non-terminal tokens it is assigned a value through the action rule's
        symbol tt($$). Lexical scanners may be offered the facility to assign
        a semantic value to this variable in parallel with a returned
        token. In order to allow a scanner access to tt(d_val__),
        tt(d_val__)'s address should be passed to the scanner. This can be
        realized, for example, by passing tt(d_val__)'s address to the lexical
        scanner's constructor.
       Subsequently, the lexical scanner may assign a value to the parser's
        tt(d_val__) variable through the pointer to tt(d_val__) stored in a
        data member of the lexical scanner.
       Note that in some cases this approach em(must) be used to make
        available the correct semantic value to the parser. In particular,
        when a grammar state defines multiple reductions, depending on the
        next token, the reduction's action only takes place following the
        retrieval of the next token, thus losing the initially matched token
        text. 
    it() bf(LTYPE__ d_vsp__):nl()
       The semantic value stack pointer. 
        Do not modify.
    )

manpagesection(TYPES AND VARIABLES IN THE ANONYMOUS NAMESPACE)
    
    includefile(../manual/class/anonymous.yo)

manpagesection(RESTRICTIONS ON TOKEN NAMES)

    To avoid collisions with names defined by the parser's (base) class, the
following identifiers should not be used as token names:
    itemization(
    it() Identifiers ending in two underscores;
    it() Any of the following identifiers: tt(ABORT, ACCEPT, ERROR, clearin,
        debug), or tt(setDebug).
    )

manpagesection(OBSOLETE SYMBOLS)

    All bf(DECLARATIONS) and bf(DEFINE) symbols not listed above but defined
in bf(bison++) are obsolete with bic(). In particular, there is no tt(%header{
... %}) section anymore. Also, all bf(DEFINE) symbols related to member
functions are now obsolete. There is no need for these symbols anymore as they
can simply be declared in the class header file and defined elsewhere.
                    
manpagesection(EXAMPLE)

    Using a fairly worn-out example, we'll construct a simple calculator
below. The basic operators as well as parentheses can be used to specify
expressions, and each expression should be terminated by a newline. The
program terminates when a tt(q) is entered. Empty lines result in a mere
prompt. 

    First an associated grammar is constructed. When a syntactic error is
encountered all tokens are skipped until then next newline and a simple
message is printed using the default tt(error) function. It is assumed that
no semantic errors occur (in particular, no divisions by zero). The grammar is
decorated with actions performed when the corresponding grammatic production
rule is recognized. The grammar itself is rather standard and straightforward,
but note the first part of the specification file, containing various other
directives, among which the tt(%scanner) directive, resulting in a
composed tt(d_scanner) object as well as an implementation of the member
function tt(int lex). In this example, a common tt(Scanner) class
construction strategy was used: the class tt(Scanner) was derived from the
class tt(yyFlexLexer) generated by bf(flex++)(1). The actual process of
constructing a class using bf(flex++)(1) is beyond the scope of this man-page,
but bf(flex++)(1)'s specification file is mentioned below, to further complete
the example. Here is bf(bisonc++)'s input file:
        verbinclude(calculator/parser/grammar)
    Next, bic() processes this file. In the process, bic() generates the
following files from its skeletons:
    itemization(
    it() The parser's base class, which is not modified by the programmer at
all: 
        verbinclude(calculator/parser/parserbase.h)
    it() The parser class tt(parser.h) itself. In the grammar
specification various member functions are used (e.g., tt(done)) and
tt(prompt). These functions are so small that they can very well be
implemented inline. Note that tt(done) calls tt(ACCEPT) to terminate
further parsing. tt(ACCEPT) and related members (e.g., tt(ABORT)) can be
called from any member called by tt(parse). As a consequence, action blocks
could contain mere function calls, rather than several statements, thus
minimizing the need to rerun bic() when an action is modified.

    Once bic() had created tt(parser.h) it was augmented with the required
additional members, resulting in the following final version:
        verbinclude(calculator/parser/parser.h)
    it() To complete the example, the following lexical scanner specification
was used:
        verbinclude(calculator/scanner/lexer)
    it() Since no member functions other than tt(parse) were defined in
separate source files, only tt(parse) includes tt(parser.ih). Since
tt(cerr) is used in the grammar's actions, a tt(using namespace
std) or comparable statement is required. This was effectuated from
tt(parser.ih) Here is the implementation header declaring the standard
namespace:
        verbinclude(calculator/parser/parser.ih)
    The implementation of the parsing member function tt(parse) is basically
irrelevant, since it should not be modified by the programmer. It was written
on the file tt(parse.cc).
    it() Finally, here is the program offering our simple calculator:
        verbinclude(calculator/calculator.cc)
    )

manpagesection(USING PARSER-CLASS SYMBOLS IN LEXICAL SCANNERS)

        Note here that although the file tt(parserbase.h), defining the
parser class' base-class, rather than the header file tt(parser.h)
defining the parser class is included, the lexical scanner may simply return
tokens of the class tt(Calculator) (e.g., tt(Calculator::NUMBER) rather than
tt(CalculatorBase::NUMBER)). In fact, using a simple tt(#define - #undef)
pair generated by the bic() respectively at the end of the base class header
the file and just before the definition of the parser class itself it is
the possible to assume in the lexical scanner that all symbols defined in the
the parser's base class are actually defined in the parser class itself. It
the should be noted that this feature can only be used to access base class
the tt(enum) and types. The actual parser class is not available by the time
the the lexical scanner is defined, thus avoiding circular class dependencies.
        
manpagefiles()
    itemization(
    it() bf(bisonc++base.h): skeleton of the parser's base class;
    it() bf(bisonc++.h): skeleton of the parser class;
    it() bf(bisonc++.ih): skeleton of the implementation header;
    it() bf(bisonc++.cc): skeleton of the member tt(parse).
    )
manpageseealso()
    bf(bison)(1), bf(bison++)(1), bf(bison.info) (using texinfo),
    bf(flex++)(1)

    Lakos, J. (2001) bf(Large Scale C++ Software Design), Addison Wesley.nl()
    Aho, A.V., Sethi, R., Ullman, J.D. (1986) bf(Compilers), Addison Wesley.

manpagebugs()

    Discontinued option:
    itemization(
        it() loption(include-only)
    )

    To avoid collisions with names defined by the parser's (base) class, the
following identifiers should not be used as token nams:
    itemization(
    it() Identifiers ending in two underscores;
    it() Any of the following identifiers: tt(ABORT, ACCEPT, ERROR, clearin,
        debug, error), or tt(setDebug).
    )

    When re-using files generated by bic() before version 2.0.0, minor
hand-modification might be necessary. The identifiers in the following list
(defined in the parser's base class) now have two underscores affixed to them:
tt(LTYPE, STYPE) and tt(Tokens). When using classes derived from the generated
parser class, the following identifiers are available in such derived classes:
tt(DEFAULT_RECOVERY_MODE, ErrorRecovery, Return, UNEXPECTED_TOKEN, d_debug,
d_loc, d_lsp, d_nErrors, d_nextToken, d_state, d_token, d_val), and tt(d_vsp).
When used in derived classes, they too need two underscores affixed to them.

    The member function tt(void lookup) (< 1.00) was replaced by tt(int
lookup). When regenerating parsers created by early versions of bf(bisonc++)
(versions before version 1.00), tt(lookup)'s prototype should be corrected by
hand, since bf(bisonc++) will not by itself rewrite the parser class's header
file.

    The em(Semantic) parser, mentioned in bf(bison++)(1) is not implemented in
bf(bisonc++)(1). According to bf(bison++)(1) the semantic parser was not
available in bf(bison++) either. It is possible that the em(Pure) parser is
now available via the tt(--thread-safe) option.

manpagesection(ABOUT bisonc++)

bf(Bisonc++) was based on bf(bison++), originally developed by Alain
Coetmeur (coetmeur@icdc.fr), R&D department (RDT), Informatique-CDC, France,
who based his work on bf(bison), GNU version 1.21. 

    Bic() version 0.98 and beyond is a complete rewrite of an LALR-1 parser
generator, closely following the construction process as described in Aho,
Sethi and Ullman's (1986) book bf(Compilers) (i.e., the em(Dragon book)).  It
the uses same grammar specification as bf(bison) and bf(bison++), and it uses
practically the same options and directives as bic() versions earlier than
0.98. Variables, declarations and macros that are obsolete were removed. 
Since bic() is a completely new program, it will most likely contain
bugs. Please report bugs to the author:
    
manpageauthor()

Frank B. Brokken (f.b.brokken@rug.nl).
