.TH "bisonc++" "1" "2005" "bisonc++\&.tar\&.gz" "bisonc++ parser generator"

.PP 
.SH "NAME"
bisonc++ \- Generate a C++ parser class and parsing function
.PP 
.SH "SYNOPSIS"
\fBbisonc++\fP [OPTIONS] \fIgrammar-file\fP
.PP 
.SH "DESCRIPTION"

.PP 
The program \fBbisonc++\fP is based on previous work on \fBbison\fP by Alain Coetmeur
(coetmeur@icdc\&.fr), who created in the early \&'90s a \fBC++\fP class encapsulating
the \fByyparse()\fP function as generated by the GNU-\fBbison\fP parser generator\&.
.PP 
Initial versions of \fBbisonc++\fP (up to version 0\&.92) wrapped Alain\&'s program in
a program offering a more modern user-interface, removing all old-style
(\fBC\fP) \fB%define\fP directives from \fBbison++\fP\&'s input specification file
(see below for an in-depth discussion of the differences between \fBbison++\fP
and \fBbisonc++\fP)\&. Starting with version 0\&.98, \fBbisonc++\fP is compiled from a complete 
rebuilt of the parser generator, closely following the description of Aho,
Sethi and Ullman\&'s \fIDragon Book\fP\&. Moreover, starting with version 0\&.98 
\fBbisonc++\fP is now a \fBC++\fP program, rather than a \fBC\fP program generating \fBC++\fP
code\&. 
.PP 
\fBBisonc++\fP expands the concepts initially implemented in \fBbison\fP and
\fBbison++\fP, offering a cleaner setup of the generated parser class\&. The
parser class is derived from a base-class, mainly containing the parser\&'s
token- and type-definitions as well as several member functions which should
not be (re)defined by the programmer\&. 
.PP 
Most of these base-class members might also be defined directly in the
parser class, but were defined in the parser\&'s base-class\&. This design results
in a very lean parser class, declaring only members that are actually defined
by the programmer or that \fImust\fP be defined by \fBbisonc++\fP itself (e\&.g\&., the
member function \fBparse()\fP as well as those support functions requiring access
to facilities that are only available in the parser class itself, rather than
in the parser\&'s base class)\&.  
.PP 
Moreover, this design does not require the use of virtual members: the
members which are not involved in the actual parsing process may always be
(re)implemented directly by the programmer\&. Thus there is no need to apply or
define virtual member functions\&.
.PP 
Actually, \fBparse()\fP is initially the only public member of the parser
class generated by \fBbisonc++\fP\&. Remaining members are private, and those that can be
redefined by the programmer using \fBbisonc++\fP usually receive initial, very simple
default in-line implementations\&. The (partial) exception to this rule is the
member function \fBlex()\fP, producing the next lexical token\&. For \fBlex()\fP
either a standardized interface or a mere declaration is offerered (requiring
the programmer to provide a tailor-made implementation for \fBlex()\fP)\&. 
.PP 
To enforce a primitive namespace, \fBbison\fP used a well-known
naming-convention: all its public symbols started with \fIyy\fP or \fIYY\fP\&.
\fBBison++\fP followed \fBbison\fP in this respect, even though a class by itself
offers enough protection of its identifiers\&. Consequently, the present author
feels that these \fIyy\fP and \fIYY\fP conventions are outdated, and consequently
\fBbisonc++\fP does not generate any symbols defined in either the parser (base) class
or in the parser function starting with \fIyy\fP or \fIYY\fP\&. Instead, all data
members have names, following a suggestion by Lakos (2001), starting with
\fId_\fP, and all static data members have names starting with \fIs_\fP\&. This
convention was not introduced to enforce identifier protection, but to clarify
the storage type of variables\&. Other (local) symbols lack specific
prefixes\&. Furthermore, \fBbisonc++\fP allows its users to define the parser class in a
particular namespace of their own choice\&.
.PP 
\fBBisonc++\fP should be used as follows:
.IP o 
As usual, a grammar must be defined\&. Using \fBbisonc++\fP this is no
different, and the reader is referred to \fBbison\fP\&'s documentation for details
about specifying and decorating grammars\&.
.IP o 
The number and function of the various \fB%define\fP declarations as
used by \fBbison++\fP, however, is greatly modified\&. Actually, all \fB%define\fP
declarations are replaced by their (former) first arguments\&. Furthermore,
`macro-style\&' declarations are no longer supported or required\&. Finally, all
declarations use lower-case characters only and do not contain underscore
characters (but sometimes hyphens)\&. E\&.g\&., \fB%define DEBUG\fP is now declared as
\fB%debug\fP; \fB%define LSP_NEEDED\fP is now declared as \fB%lsp-needed\fP (note
the hyphen)\&.
.IP o 
As noted, no `macro style\&' \fB%define\fP declarations are required
anymore\&. Instead, the normal practice of defining class members in source
files and declaring them in a class header files can be adhered to using
\fBbisonc++\fP\&.  Basically, \fBbisonc++\fP concentrates on its main tasks: the definition of an
initial parser class and the implementation of its parsing function \fBint
parse()\fP, leaving all other parts of the parser class\&' definition to the
programmer\&.
.IP o 
Having specified the grammar and (usually) some declarations \fBbisonc++\fP is
able to generate files defining the parser class and the implementation of the
member function \fBparse()\fP and its support functions\&. See the next section
for details about the various files that may be written by \fBbisonc++\fP\&.
.IP o 
All members (except for the member \fBparse()\fP) and its support
functions must be implemented by the programmer\&. Of course, additional member
functions should also be declared in the parser class\&' header\&.  At the very
least the member \fBint lex()\fP \fImust\fP be implemented (although a
standardized implementation can also be generated by \fBbisonc++\fP)\&. The member
\fBlex()\fP is called by \fBparse()\fP (support functions) to obtain the next
available token\&. The member function \fBvoid error(char const *msg)\fP may also
be re-implemented by the programmer, but a basic in-line implementation is
provided by default\&. The member function \fBerror()\fP is called when
\fBparse()\fP detects (syntactical) errors\&.
.IP o 
The parser can now be used in a program\&. A very simple example would
be: 
.nf 

    int main()
    {
        Parser parser;
        return parser\&.parse();
    }
        
.fi 

.PP 
.SH "GENERATED FILES"

.PP 
\fBBisonc++\fP may create the following files:
.IP o 
A file containing the implementation of the member function
\fBparse()\fP and its support functions\&. The member \fBparse()\fP is a public
member that can be called to parse a token-sequence according to a specified
LALR1 type grammar\&. The implementations of these members is by default written
on the file \fBparse\&.cc\fP\&. There should be \fIno\fP need for the programmer to
alter the contents of this file, as its contents change whenever the grammar
is modified\&. Hence it is rewritten by default\&. The option
\fB--no-parse-member\fP may be specified to prevent this file from being
(re)written\&. In normal circumstances, however, this option should be avoided\&.
.IP o 
A file containing an initial setup of the parser class, containing
the declaration of the public member \fBparse()\fP and of its (private) support
members\&. The members \fBerror()\fP and \fBprint()\fP receive default in-line
implementations which may be altered by the programmer\&. The member \fBlex()\fP
may receive a standard in-line implementation (see below), or it will merely
be declared, in which case the programmer \fImust\fP provide an implementation\&. 
Furthermore, new members may be added to the parser class as well\&. By
default this file will only be created if not yet existing, using the filename
\fI<parser-class>\&.h\fP (where \fI<parser-class>\fP is the the name of the defined
parser class)\&. The option \fB--force-class-header\fP may be used to (re)write
this file, even if already existing\&.
.IP o 
A file containing the parser class\&' \fIbase class\fP\&. This base
class should not be modified by the programmer\&. It contains types defined by
\fBbisonc++\fP, as well as several (protected) data members and member functions, which
should not be redefined by the programmer\&. All symbolic parser terminal tokens
are defined in this class, so it escalates these definitions in a separate
class (cf\&. Lakos, (2001)), thus preventing circular dependencies between the
lexical scanner and the parser (circular dependencies occur in situations
where the parser needs access to the lexical scanner class to define a lexical
scanner as one of its data members, whereas the lexical scanner, in turn,
needs access to the parser class to know about the grammar\&'s symbolic terminal
tokens\&. Escalation is a way out of such circular dependencies)\&. By default
this file will be (re)written any time \fBbisonc++\fP is called, using the filename
\fI<parser-class>base\&.h\fP\&. The option \fB--no-baseclass-header\fP may be
specified to prevent the base class header file from being (re)written\&. In
normal circumstances, however, this option should be avoided\&.
.IP o 
A file containing an \fIimplementation header\fP\&. An implementation
header may be included by source files implementing the various member
functions of a class\&. The implementation header first includes its associated
class header file, followed by any directives (formerly defined in the
\fB%{header \&.\&.\&. %}\fP section of the \fBbison++\fP parser specification file) that
are required for the proper compilation of these member functions\&. The
implementation header is included by the file defining \fBparse()\fP\&. By default
the implementation header will be created if not yet existing, receiving the
filename \fI<parser-class>\&.ih\fP\&.  The option \fB--force-implementation-header\fP
may be used to (re)write this file, even if already existing\&.
.IP o 
A verbose description of the generated parser\&. This file is
comparable to the verbose ouput file originally generated by \fBbison++\fP\&. It
is generated when the option \fB--verbose\fP or \fB-V\fP is provided\&. When
generated, it will use the filename \fI<parse>\&.output\fP, where \fI<parse>\fP is
the filename (without the \fI\&.cc\fP extension) of the file containing
\fBparse()\fP\&'s implementation\&.

.PP 
.SH "OPTIONS"
If available, single letter options are listed between parentheses
following their associated long-option variants\&. Single letter options require
arguments if their associated long options require arguments as well\&.
.IP o 
\fB--baseclass-preinclude\fP=\fIheader\fP (\fB-H\fP)
.br 
Use \fIheader\fP as the pathname to the file preincluded in the
parser\&'s base-class header\&. This option is useful in situations
where the base class heaer file refers to types which might not
yet be known\&. E\&.g\&., with \fB%union\fP a \fBstd::string *\fP field
might be used\&. Since the class \fBstd::string\fP might not yet be
known to the compiler once it processes the base class header file
we need a way to inform the compiler about these classes and
types\&. The suggested procedure is to use a pre-include header file
declaring the required types\&. By default \fIheader\fP will be
surrounded by double quotes (using, e\&.g\&., \fI#include "header"\fP)\&.
When the argument is surrounded by pointed brackets
\fI#include <header>\fP will be included\&. In the latter case,
quotes might be required to escape interpretation by the shell
(e\&.g\&., using \fI-H \&'<header>\&'\fP)\&.
.IP o 
\fB--baseclass-header\fP=\fIheader\fP (\fB-b\fP)
.br 
Use \fIheader\fP as the pathname of the file containing the parser\&'s
base class\&. This class defines, e\&.g\&., the parser\&'s symbolic
tokens\&. Defaults to the name of the parser class plus the suffix
\fIbase\&.h\fP\&. It is generated, unless otherwise indicated (see
\fB--no-baseclass-header\fP and \fB--dont-rewrite-baseclass-header\fP
below)\&.
.IP o 
\fB--baseclass-skeleton\fP=\fIskeleton\fP (\fB-B\fP)
.br 
Use \fIskeleton\fP as the pathname of the file containing the
skeleton of the parser\&'s base class\&. Its filename defaults to
\fIbisonc++base\&.h\fP\&.
.IP o 
\fB--class-header\fP=\fIheader\fP (\fB-c\fP)
.br 
Use \fIheader\fP as the pathname of the file containing the parser
class\&. Defaults to the name of the parser class plus the suffix
\fI\&.h\fP
.IP o 
\fB--class-skeleton\fP=\fIskeleton\fP (\fB-C\fP)
.br 
Use \fIskeleton\fP as the pathname of the file containing the
skeleton of the parser class\&. Its filename defaults to
\fIbisonc++\&.h\fP\&. The environment variable \fIBISON_SIMPLE_H\fP
is not inspected anymore\&.
.IP o 
\fB--construction\fP
.br 
This option may be specified to write details about the
construction of the parsing tables to the standard output
stream\&. This information is primarily useful for developers, and
augments the information written to the verbose grammar output
file, produced by the \fB--verbose\fP option\&.
.IP o 
\fB--debug\fP
.br 
Provide \fBparse()\fP and its support functions with debugging code,
showing the actual parsing process on the standard output
stream\&. When included, the debugging output is active by default,
but its activity may be controlled using the \fBsetDebug(bool
on-off)\fP member\&. Note that no \fI#ifdef DEBUG\fP macros are used
anymore\&. By rerunning \fBbisonc++\fP without the \fB--debug\fP option an
equivalent parser is generated not containing the debugging
code\&. 
.IP o 
\fB--filenames\fP=\fIfilename\fP (\fB-f\fP)
.br 
Specify a filename to use for all files produced by \fBbisonc++\fP\&. 
Specific options overriding particular filenames are also
available (which then, in turn, overide the name specified by this
option)\&.
.IP o 
\fB--force-class-header\fP
.br 
By default the generated class header is not overwritten once it
has been created\&. This option can be used to force the
(re)writing of the file containing the parser\&'s class\&.
.IP o 
\fB--force-implementation-header\fP
.br 
By default the generated implementation header is not overwritten
once it has been created\&. This option can be used to force the
(re)writing of the implementation header file\&.
.IP o 
\fB--help\fP (\fB-h\fP)
.br 
Write basic usage information to the standard output stream and
terminate\&. 
.IP o 
\fB--implementation-header\fP=\fIheader\fP (\fB-i\fP)
.br 
Use \fIheader\fP as the pathname of the file containing the
implementation header\&. Defaults to the name of the generated
parser class plus the suffix \fI\&.ih\fP\&. The implementation header
should contain all directives and declarations \fIonly\fP used by
the implementations of the parser\&'s member functions\&. It is the
only header file that is included by the source file containing
\fBparse()\fP\&'s implementation \&. User defined implementation of
other class members may use the same convention, thus
concentrating all directives and declarations that are required
for the compilation of other source files belonging to the parser
class in one header file\&.
.IP o 
\fB--implementation-skeleton\fP=\fIskeleton\fP (\fB-I\fP)
.br 
Use \fIskeleton\fP as the pathname of the file containing the
skeleton of the implementation header\&. Its filename defaults to
\fIbisonc++\&.ih\fP\&.
.IP o 
\fB--lines\fP (\fB-l\fP)
.br 
Put \fB#line\fP preprocessor directives in the file containing the
parser\&'s \fBparse()\fP function\&. By including this option the
compiler and debuggers will associate errors with lines in your
grammar specification file, rather than with the source file
containing the \fBparse()\fP function itself\&.
.IP o 
\fB--no-lines\fP
.br 
Do not put \fB#line\fP preprocessor directives in the file containing
the parser\&'s \fBparse()\fP function\&. This option is primarily useful
in combination with the \fB%lines\fP directive, to suppress that
declaration\&. It also overrides option \fB--lines\fP, though\&.
.IP o 
\fB--namespace\fP=\fInamespace\fP (\fB-n\fP)
.br 
Define the parser base class, the paser class and the parser
implentations in the namespace \fInamespace\fP\&. By default
no namespace is defined\&. If this options is used the
implementation header will contain a commented out \fIusing
namespace\fP declaration for the requested namespace\&. 
.IP o 
\fB--no-baseclass-header\fP
.br 
Do not write the file containing the parser class\&' base class, even
if that file doesn\&'t yet exist\&. By default the file containing the
parser\&'s base class is (re)written each time \fBbisonc++\fP is called\&. Note
that this option should normally be avoided, as the base class
defines the symbolic terminal tokens that are returned by the
lexical scanner\&. By suppressing the construction of this file any
modification in these terminal tokens will not be communicated to
the lexical scanner\&.
.IP o 
\fB--no-parse-member\fP
.br 
Do not write the file containing the parser\&'s predefined parser
member functions, even if that file doesn\&'t yet exist\&. By default
the file containing the parser\&'s \fBparse()\fP member function is
(re)written each time \fBbisonc++\fP is called\&. Note that this option
should normally be avoided, as this file contains parsing
tables which are altered whenever the grammar definition is
modified\&. 
.IP o 
\fB--parsefun-source\fP=\fIsource\fP (\fB-p\fP)
.br 
Define \fIsource\fP as the name of the source file containing the
parser member function \fBparse()\fP\&. Defaults to \fIparse\&.cc\fP\&.
.IP o 
\fB--parsefun-skeleton\fP=\fIskeleton\fP (\fB-P\fP)
.br 
Use \fIskeleton\fP as the pathname of the file containing the parsing
member function\&'s skeleton\&. Its filename defaults to
\fIbisonc++\&.cc\fP\&. The environment variable \fIBISON_SIMPLE\fP is not
inspected anymore\&.
.IP o 
\fB--scanner\fP=\fIheader\fP (\fB-s\fP)
.br 
Use \fIheader\fP as the pathname to the file defining a class
\fBScanner\fP, offering a member \fBint yylex()\fP producing the next
token from the input stream to be analyzed by the parser generated
by \fBbisonc++\fP\&. When this option is used the parser\&'s member \fBint
lex()\fP will be predefined as 
.nf 

    int lex()
    {
        return d_scanner\&.yylex();
    }
                
.fi 
and an object \fIScanner d_scanner\fP will be composed into the
parser\&. The \fId_scanner\fP object will be constructed using its
default constructor\&. If another constructor is required, the
parser class may be provided with an appropriate (overloaded)
parser constructor after having constructed the default parser
class header file using \fBbisonc++\fP\&.  By default \fIheader\fP will be
surrounded by double quotes (using, e\&.g\&., \fI#include "header"\fP)\&.
When the argument is surrounded by pointed brackets \fI#include
<header>\fP will be included\&. In the latter case, quotes might be
required to escape interpretation by the shell (e\&.g\&., using \fI-s
\&'<header>\&'\fP)\&.
.IP o 
\fB--show-filenames\fP
.br 
Write the names of the files that are generated to the 
standard error stream\&.
.IP o 
\fB--verbose\fP (\fB-V\fP)
.br 
Write a file containing verbose descriptions of
the parser states and what is done for each type of look-ahead
token in that state\&.  This file also describes all conflicts
detected in the grammar, both those resolved by operator
precedence and those that remain unresolved\&.  By default it will
not be created, but if requested it will receive the filename
\fI<parse>\&.output\fP, where \fI<parse>\fP is the filename (without the
\fI\&.cc\fP extension) of the file containing \fBparse()\fP\&'s
implementation\&.
.IP o 
\fB--version\fP (\fB-v\fP)
.br 
Display \fBbisonc++\fP\&'s version number and terminate\&.

.PP 
.SH "DECLARATIONS"

.PP 
The following declarations can be used in the initial section of the
grammar specification file\&. When command-line options for declarations exist,
they overrule the corresponding declarations given in the grammar
specification file\&.
.IP o 
\fB%baseclass-header\fP \fIheader\fP 
.br 
Defines the pathname of the file containing the parser\&'s base
class\&. This directive is overridden by the
\fB--baseclass-header\fP or \fB-b\fP command-line options\&.
.IP o 
\fB%baseclass-preinclude\fP \fIheader\fP
.br 
Use \fIheader\fP as the pathname to the file pre-included in the
parser\&'s base-class header\&. See the description of the
\fB--baseclass-preinclude\fP option for details about this option\&.
Like the convention adopted for this argument, \fIheader\fP will (by
default) be surrounded by double quotes\&.  However, when the
argument is surrounded by pointed brackets \fI#include <header>\fP
will be included\&.
.IP o 
\fB%class-header\fP \fIheader\fP 
.br 
Defines the pathname of the file containing the parser 
class\&. This directive is overridden by the
\fB--class-header\fP or \fB-c\fP command-line options\&.
.IP o 
\fB%class-name\fP \fIparser-class-name\fP 
.br 
Declares the name of this parser\&. This declaration replaces the
\fB%name\fP declaration previously used by \fBbison++\fP\&. It defines
the name of the \fBC++\fP class that will be generated\&. Contrary to
\fBbison++\fP\&'s \fB%name\fP declaration, \fB%class-name\fP may appear
anywhere in the first section of the grammar specification
file\&. However, it may be defined only once\&. If no \fB%class-name\fP
is specified the default class name \fIParser\fP will be used\&.
.IP o 
\fB%debug\fP 
.br 
Provide \fBparse()\fP and its support functions with debugging code,
showing the actual parsing process on the standard output
stream\&. When included, the debugging output is active by default,
but its activity may be controlled using the \fBsetDebug(bool
on-off)\fP member\&. Note that no \fI#ifdef DEBUG\fP macros are used
anymore\&. By rerunning \fBbisonc++\fP without the \fB--debug\fP option an
equivalent parser is generated not containing the debugging
code\&. 
.IP o 
\fB%error-verbose\fP 
.br 
(to do)
if defined the parser stack is dumped when an error is detected
by the \fBparse()\fP member function\&.
.IP o 
\fB%filenames\fP \fIheader\fP 
.br 
Defines the generic name of all generated files, unless overridden
by specific names\&. This directive is overridden by the
\fB--filenames\fP or \fB-f\fP command-line options\&.
.IP o 
\fB%implementation-header\fP \fIheader\fP 
.br 
Defines the pathname of the file containing the implementation
header\&.  This directive is overridden by the
\fB--implementation-header\fP or \fB-i\fP command-line options\&.
.IP o 
\fB%lines\fP 
.br 
Put \fB#line\fP preprocessor directives in the file containing the
parser\&'s \fBparse()\fP function\&. It acts identically to the \fB-l\fP
command line option, and is suppressed by the \fB--no-lines\fP
option\&.
.IP o 
\fB%lsp-needed\fP 
.br 
Defining this causes \fBbisonc++\fP to include code into the generated
parser using the standard location stack\&.  The token-location type
defaults to the following struct, defined in the parser\&'s base
class when this declaration is specified: 
.nf 

    struct LTYPE
    {
        int timestamp;
        int first_line;
        int first_column;
        int last_line;
        int last_column;
        char *text;
    };
           
.fi 
.IP o 
\fB%ltype typename\fP 
.br 
Specifies a user-defined token location type\&. 
If \fB%ltype\fP is used, \fItypename\fP should be the name of an
alternate (predefined) type (e\&.g\&., \fBunsigned\fP)\&. It should not be
used if a \fB%locationstruct\fP specification is used (see
below)\&. Within the parser class, this type may be used as
\fBLTYPE\fP\&. 
.IP o 
\fB%namespace\fP \fInamespace\fP 
.br 
Define the parser class in the namespace \fInamespace\fP\&. By default
no namespace is defined\&. If this options is used the
implementation header will contain a commented out \fIusing
namespace\fP declaration for the requested namespace\&.  This
directive is overridden by the \fB--namespace\fP command-line
option\&.
.IP o 
\fB%parsefun-source\fP \fIsource\fP 
.br 
Defines the pathname of the file containing the parser member
\fBparse()\fP\&. This directive is overridden by the 
\fB--parse-source\fP or \fB-p\fP command-line options\&.
.IP o 
\fB%scanner\fP \fIheader\fP
.br 
Use \fIheader\fP as the pathname to the file pre-included in the
parser\&'s class header\&. See the description of the \fB--scanner\fP
option for details about this option\&.  Similar to the convention
adopted for this argument, \fIheader\fP will (by default) be
surrounded by double quotes\&.  However, when the argument is
surrounded by pointed brackets \fI#include <header>\fP will be
included\&. Note that using this declaration implies the definition
of a composed \fIScanner d_scanner\fP data member into the generated
parser, as well as a predefined \fBint lex()\fP member, returning
\fId_scanner\&.yylex()\fP\&. If this is inappropriate, a user defined
implementation of \fBint lex()\fP must be provided\&.
.IP o 
\fB%stype typename\fP 
.br 
The type of the semantic value of tokens\&.  The specification
\fItypename\fP should be the name of an unstructured type (e\&.g\&.,
\fBunsigned\fP)\&. By default it is \fBint\fP\&. See \fBYYSTYPE\fP in
\fBbison\fP\&.  It should not be used if a \fB%union\fP specification is
used\&.  Within the parser class, this type may be used as
\fBSTYPE\fP\&.
.IP o 
\fB%locationstruct\fP \fIstruct-definition\fP 
.br 
Defines the organization of the location-struct data type
\fBLTYPE\fP\&. This struct should be specified analogously to the way
the parser\&'s stacktype is defined using \fB%union\fP (see
below)\&. The location struct is named \fBLTYPE\fP\&. If neither
\fBlocationstruct\fP nor \fBLTYPE\fP is specified, the aforementioned
default struct is used\&. 
.IP o 
\fB%union\fP \fIunion-definition\fP 
.br 
Acts identically to the \fBbison\fP and \fBbison++\fP declaration\&. 
as with bison generate a union for semantic type\&. 
The union is named \fBSTYPE\fP\&. If no \fB%union\fP is
declared, a simple stack-type may be defined using the \fBSTYPE\fP
declaration\&. If no \fBSTYPE\fP declaration is used, the default
stacktype (\fBint\fP) is used\&.

.PP 
.SH "PUBLIC MEMBERS AND -TYPES"

.PP 
The following public members can be used by users of the parser classes
generated by \fBbisonc++\fP (\fI`Parser Class\&'::\fP prefixes are silently implied):
.IP o 
\fBLTYPE\fP:
.br 
The parser\&'s location type (user-definable)\&. Available only when
either \fB%lsp-needed, %ltype\fP or \fB%locationstruct\fP has been
declared\&. 
.IP o 
\fBSTYPE\fP:
.br 
The parser\&'s stack-type (user-definable), defaults to \fBint\fP\&.
.IP o 
\fBTokens\fP:
.br 
The enumeration type of all the symbolic tokens defined in the
grammar file (i\&.e\&., \fBbisonc++\fP\&'s input file)\&. The scanner should be
prepared to return these symbolic tokens (note that, since the
symbolic tokens are defined in the parser\&'s class and not in the
scanner\&'s class, the lexical scanner must prefix the parser\&'s
class name to the symbolic token names when they are
returned\&. E\&.g\&., \fBreturn Parser::IDENT\fP should be used rather
than \fBreturn IDENT\fP\&.
.IP o 
\fBint parse()\fP:
.br 
The parser\&'s parsing member function\&. It returns 0 when parsing has
completed successfully, 1 if errors were encountered while parsing
the input\&.
)
.IP 
.SH "PRIVATE ENUMS AND -TYPES"

.IP 
The following enumerations and types can be used by members of parser
classes generated by \fBbisonc++\fP\&. When prefixed by \fBBase::\fP they are actually
protected members inherited from the parser\&'s base class\&.
.IP o 
\fBBase::ErrorRecovery\fP:
.br 
This enumeration defines two values:
.nf 

    DEFAULT_RECOVERY_MODE,
    UNEXPECTED_TOKEN
        
.fi 
\fBDEFAULT_RECOVERY_MODE\fP consists of terminating the parsing
process\&. \fBUNEXPECTED_TOKEN\fP activates the recovery procedure
whenever an error is encountered\&. The recovery procedure consists of
looking for the first state on the state-stack having an
error-production, and then skipping subsequent tokens until (in that
state) a token is retrieved which may follow the \fBerror\fP terminal
token in that production rule\&. If this error recovery procedure fails
(i\&.e\&., if no acceptable token is ever encountered) error recovery
falls back to the default recovery mode, terminating the parsing
process\&. 
.IP o 
\fBBase::Return\fP:
.br 
This enumeration defines two values:
.nf 

    PARSE_ACCEPT = 0,
    PARSE_ABORT = 1
        
.fi 
(which are of course the \fBparse()\fP function\&'s return values)\&.

.IP 
.SH "PRIVATE MEMBER FUNCTIONS"

.IP 
The following private members can be used by members of parser classes
generated by \fBbisonc++\fP\&. When prefixed by \fBBase::\fP they are actually protected
members inherited from the parser\&'s base class\&. 
.IP o 
\fBBase::ParserBase()\fP:
.br 
The default base-class constructor\&. Can be ignored in practical
situations\&.
.IP o 
\fBvoid Base::ABORT() const throw(Return)\fP:
.br 
This member can be called from any member function (called from any of
the parser\&'s action blocks) to indicate a failure while parsing thus
terminating the parsing function with an error value 1\&. Note that this
offers a marked extension and improvement of the macro \fBYYABORT\fP
defined by \fBbison++\fP in that \fBYYABORT\fP could not be called from
outside of the parsing member function\&.
.IP o 
\fBvoid Base::ACCEPT() const throw(Return)\fP:
.br 
This member can be called from any member function (called from any of
the parser\&'s action blocks) to indicate successful parsing and thus
terminating the parsing function\&. Note that this offers a marked
extension and improvement of the macro \fBYYACCEPT\fP defined by
\fBbison++\fP in that \fBYYACCEPT\fP could not be called from outside of
the parsing member function\&.
.IP o 
\fBvoid Base::clearin()\fP:
.br 
This member replaces \fBbison\fP(++)\&'s macro \fByyclearin\fP, and sets the
current token to \fB_UNDETERMINED_\fP, causing the parser the retrieve
the next token from the lexical scanner\&.
.IP o 
\fBbool Base::debug() const\fP:
.br 
This member returns the current value of the debug variable\&. See
\fBsetDebug()\fP below\&.
.IP o 
\fBvoid Base::ERROR() const throw(ErrorRecovery)\fP:
.br 
This member can be called from any member function (called from any of
the parser\&'s action blocks) to generate an error, and thus initiate
the parser\&'s error recovery code\&. Note that this offers a marked
extension and improvement of the macro \fBYYERROR\fP defined by
\fBbison++\fP in that \fBYYERROR\fP could not be called from outside of
the parsing member function\&.
.IP o 
\fBvoid error(char const *msg)\fP:
.br 
This member may be redefined in the parser class\&. Its default (inline)
implementation is to write a simple message to the standard error
stream\&. It is called when a syntactical error is encountered\&.
.IP o 
\fBvoid errorRecovery()\fP:
.br 
Used internally by the parsing function\&. Not to be called otherwise\&.
.IP o 
\fBvoid executeAction()\fP:
.br 
Used internally by the parsing function\&. Not to be called otherwise\&.
.IP o 
\fBint lex()\fP:
.br 
This member may be pre-implemented using the \fBscanner\fP option or
declaration (see above) or it \fImust\fP be implemented by the
programmer\&. It interfaces to the lexical scanner, and should
return the next token produced by the lexical scanner, either as a
plain character or as one of the symbolic tokens defined in the
\fBParser::Tokens\fP enumeration\&. Zero or negative token values are
interpreted as `end of input\&'\&.
.IP o 
\fBvoid lookup()\fP:
.br 
Used internally by the parsing function\&. Not to be called otherwise\&.
.IP o 
\fBvoid nextToken()\fP:
.br 
Used internally by the parsing function\&. Not to be called otherwise\&.
.IP o 
\fBvoid Base::pop()\fP:
.br 
Used internally by the parsing function\&. Not to be called otherwise\&.
.IP o 
\fBvoid print()\fP:
.br 
This member can be redefined in the parser class to print information
about the parser\&'s state\&. It is called by the parser immediately after
retrieving a token from \fBlex()\fP\&. As it is a member function it has
access to all the parser\&'s members, in particular \fBd_token\fP, the
current token value and \fBd_loc\fP, the current token location
information (if \fB%lsp-needed, %ltype\fP or \fB%locationstruct\fP has
been specified)\&.
.IP o 
\fBvoid Base::push()\fP:
.br 
Used internally by the parsing function\&. Not to be called otherwise\&.
.IP o 
\fBvoid Base::reduce()\fP:
.br 
Used internally by the parsing function\&. Not to be called otherwise\&.
.IP o 
\fBvoid Base::setDebug(bool mode)\fP:
.br 
This member can be used to activate or deactivate the debug-code
compiled into the parsing function\&. It is available, but has no
effect, if no debug code has been compiled into the parsing
function\&. When debugging code has been compiled into the parsing
function, it is active by default, but it may be suppressed by calling
\fBsetDebug(false)\fP\&.
.IP o 
\fBvoid Base::top()\fP:
.br 
Used internally by the parsing function\&. Not to be called otherwise\&.

.PP 
.SH "PRIVATE DATA MEMBERS"

.PP 
The following private members can be used by members of parser classes
generated by \fBbisonc++\fP\&. All data members are actually protected
members inherited from the parser\&'s base class\&. 
.IP o 
\fBbool d_debug\fP:
.br 
When the \fBdebug\fP option has been specified, this variable (\fBtrue\fP
by default) determines whether debug information is actually
displayed\&.
.IP o 
\fBLTYPE d_loc\fP:
.br 
The location type value associated with a terminal token\&. It can be
used by, e\&.g\&., lexical scanners to pass location information of a
matched token to the parser in parallel with a returned token\&. It is
available only when \fB%lsp-needed, %ltype\fP or \fB%locationstruct\fP has
been defined\&. 
.br 
Lexical scanners may be offered the facility to assign
a value to this variable in parallel with a returned
token\&. In order to allow a scanner access to \fBd_loc\fP, \fBd_loc\fP\&'s
address should be passed to the scanner\&. This can be realized, for
example, by defining a member \fBvoid setLoc(STYPE *)\fP in the lexical
scanner, which is then called from the parser\&'s constructor as
follows:
.nf 

            d_scanner\&.setSLoc(&d_loc);
       
.fi 
Subsequently, the lexical scanner may assign a value to the parser\&'s
\fBd_loc\fP variable through the pointer to \fBd_loc\fP stored inside the
lexical scanner\&. 
.IP o 
\fBLTYPE d_lsp\fP:
.br 
The location stack pointer\&. Used internally by the parser\&. Not to be
used otherwise\&.
.IP o 
\fBSTYPE d_val\fP:
.br 
The semantic value of a returned token or non-terminal symbol\&. With
non-terminal tokens it is assigned a value through the action rule\&'s
symbol \fB$$\fP\&. Lexical scanners may be offered the facility to assign
a semantic value to this variable in parallel with a returned
token\&. In order to allow a scanner access to \fBd_val\fP, \fBd_val\fP\&'s
address should be passed to the scanner\&. This can be realized, for
example, by defining a member \fBvoid setSval(STYPE *)\fP in the lexical
scanner, which is then called from the parser\&'s constructor as
follows:
.nf 

            d_scanner\&.setSval(&d_val);
       
.fi 
Subsequently, the lexical scanner may assign a value to the parser\&'s
\fBd_val\fP variable through the pointer to \fBd_val\fP stored inside the
lexical scanner\&. 
.IP o 
\fBLTYPE d_vsp\fP:
.br 
The semantic value stack pointer\&. Used internally by the parser\&. Not to
be used otherwise\&.
.IP o 
\fBunsigned d_nErrors\fP:
.br 
The number of errors counted by \fBparse()\fP\&. It is initialized by the
parser\&'s base class initializer, and is updated while \fBparse()\fP
executes\&. When \fBparse()\fP has returned it contains the total number
of errors counted by \fBparse()\fP\&.
.IP o 
\fBint d_state\fP:
.br 
The current parsing state\&. Used internally by the parsing function\&. Not
to be used otherwise\&.
.IP o 
\fBint d_token\fP:
.br 
The current token used internally by the parser\&. The parser may modify
the token value retrieved via \fBlex()\fP, so \fBd_token\fP may not be the
value of the last token actually retrieved by \fBlex()\fP\&.
.IP o 
\fBstatic PI s_productionInfo\fP:
.br 
Used internally by the parsing function\&. Not to be used otherwise\&.
.IP o 
\fBstatic SR s_<nr>[]\fP:
.br 
Here, \fI<nr>\fP is a numerical value representing a state number\&.
Used internally by the parsing function\&. Not to be used otherwise\&.
.IP o 
\fBstatic SR *s_state[]\fP:
.br 
Used internally by the parsing function\&. Not to be used otherwise\&.

.PP 
.SH "TYPES AND VARIABLES IN THE ANONYMOUS NAMESPACE"

.PP 
In the file defining the \fBparse()\fP function the following types and
variables are defined in the anonymous namespace\&. These are mentioned here for
the sake of completeness, and are not normally accessible to other parts of
the parser\&.
.PP 
.IP o 
\fBReservedTokens\fP:
.br 
This enumeration defines some token values used internally by the
parsing functions\&. They are:
.nf 

    _UNDETERMINED_ = -2,
    _EOF_          = -1,
    _error_        = 256,
       
.fi 
These tokens are used by the parser to determine whether another token
should be requested from the lexical scanner, and to handle
error-conditions\&. 
.IP o 
\fBSR\fP (Shift-Reduce Info):
.br 
This \fBstruct\fP provides the shift/reduce information for the various
grammatical states\&. \fBSR\fP values are collected in arrays, one array
per grammatical state\&. These array, named \fBs_\fP\fI<nr>\fP, 
where tt<nr> is a state number are defined in the anonymous namespace
as well\&. The \fBSR\fP elements consist of two unions,
defining fields that are applicable to, respectively, the first,
intermediate and the last array elements\&.
.br 
The first element of each array consists of (1st field) a \fBStateType\fP
and (2nd field) the index of the last array element;
intermediate elements consist of (1st field) a symbol value and (2nd
field) (if negative) the production rule number reducing to the
indicated symbol value or (if positive) the next state when the symbol
given in the 1st field is the current token; 
the last element of each array consists of (1st field) a placeholder for
the current token and (2nd field) the (negative) rule number to reduce
to by default or the (positive) number of an error-state to go to when
an erroneous token has been retrieved\&. If the 2nd field is zero, no
error or default action has been defined for the state, and
error-recovery is attepted\&.
.IP o 
\fBStateType\fP:
.br 
This enumeration defines the type of the various grammar-states\&. They
are: 
.nf 

    NORMAL,
    HAS_ERROR_ITEM,
    IS_ERROR_STATE,
       
.fi 
\fBHAS_ERROR_ITEM\fP is used for a state having at least one
error-production\&. \fBIS_ERROR_STATE\fP is used for a state from which
error recovery is attempted\&. So, while in these states tokens are
retrieved until a token from where parsing may continue is seen by the
parser\&. All other states are \fBNORMAL\fP states\&.
.IP o 
\fBPI\fP (Production Info):
.br 
This \fBstruct\fP provides information about production rules\&. It has two
fields: \fBd_nonTerm\fP is the identification number of the production\&'s
non-terminal, \fBd_size\fP represents the number of elements of the
productin rule\&.

.PP 
.SH "OBSOLETE SYMBOLS"

.PP 
All \fBDECLARATIONS\fP and \fBDEFINE\fP symbols not listed above but defined
in \fBbison++\fP are obsolete with \fBbisonc++\fP\&. In particular, there is no \fB%header{
\&.\&.\&. %}\fP section anymore\&. Also, all \fBDEFINE\fP symbols related to member
functions are now obsolete\&. There is no need for these symbols anymore as they
can simply be declared in the class header file and defined elsewhere\&.
.PP 
.SH "EXAMPLE"

.PP 
Using a fairly worn-out example, we\&'ll construct a simple calculator
below\&. The basic operators as well as parentheses can be used to specify
expressions, and each expression should be terminated by a newline\&. The
program terminates when a \fIq\fP is entered\&. Empty lines result in a mere
prompt\&. 
.PP 
First an associated grammar is constructed\&. When a syntactical error is
encountered all tokens are skipped until then next newline and a simple
message is printed using the default \fBerror()\fP function\&. It is assumed that
no semantic errors occur (in particular, no divisions by zero)\&. The grammar is
decorated with actions performed when the corresponding grammatical production
rule is recognized\&. The grammar itself is rather standard and straightforward,
but note the first part of the specification file, containing various other
declarations, among which the \fB%scanner\fP declaration, resulting in a
composed \fBd_scanner\fP object as well as an implementation of the member
function \fBint lex()\fP\&. In this example, a common \fBScanner\fP class
construction strategy was used: the class \fBScanner\fP was derived from the
class \fByyFlexLexer\fP generated by \fBflex++\fP(1)\&. The actual process of
constructing a class using \fBflex++\fP(1) is beyond the scope of this man-page,
but \fBflex++\fP(1)\&'s specification file is mentioned below, to further complete
the example\&. Here is \fBbisonc++\fP\&'s input file:
.nf 
%class-name Calculator
%scanner \&.\&./scanner/scanner\&.h
%filenames calculator
%parsefun-source parse\&.cc

                                // lowest precedence
%token  NUMBER                  // integral numbers
        EOLN                    // newline

%left   \&'+\&' \&'-\&' 
%left   \&'*\&' \&'/\&' 
%right  UNARY
                                // highest precendence 

%%
expressions:
    expressions 
    evaluate
|
    prompt
;

evaluate:
    alternative
    prompt
;

prompt:
    {
        prompt();
    }
;

alternative:
    expression
    EOLN
    {
        cout << $1 << endl;
    }
|
    \&'q\&'
    done
|
    EOLN
|
    error
    EOLN
;

done:
    {
        cout << "Done\&.\en";
        ACCEPT();
    }
;

expression:
    expression 
    \&'+\&'
    expression
    {
        $$ = $1 + $3;
    }
|
    expression 
    \&'-\&'
    expression
    {
        $$ = $1 - $3;
    }
|
    expression 
    \&'*\&'
    expression
    {
        $$ = $1 * $3;
    }
|
    expression 
    \&'/\&'
    expression
    {
        $$ = $1 / $3;
    }
|
    \&'-\&'             
    expression      %prec UNARY
    {
        $$ = -$2;
    }
|
    \&'+\&'             
    expression      %prec UNARY
    {
        $$ = $2;
    }
|
    \&'(\&'
    expression
    \&')\&'
    {
        $$ = $2;
    }
|
    NUMBER
    {
        $$ = atoi(d_scanner\&.YYText());
    }
;

.fi 

Next, \fBbisonc++\fP processes this file\&. In the process, \fBbisonc++\fP generates the
following files from its skeletons:
.IP o 
The parser\&'s base class, which is not modified by the programmer at
all: 
.nf 
#ifndef CalculatorBase_h_included
#define CalculatorBase_h_included

#include <vector>


namespace // anonymous
{
    struct PI;
}


class CalculatorBase
{
    public:
// $insert tokens

    // Symbolic tokens:
    enum Tokens
    {
        NUMBER = 260,
        EOLN,
        UNARY,
    };

// $insert STYPE
    typedef int STYPE;

    private:
        int d_stackIdx;
        std::vector<unsigned>   d_stateStack;
        std::vector<STYPE>      d_valueStack;

    protected:
        enum Return
        {
            PARSE_ACCEPT = 0,   // values used as parse()\&'s return values
            PARSE_ABORT  = 1
        };
        enum ErrorRecovery
        {
            DEFAULT_RECOVERY_MODE,
            UNEXPECTED_TOKEN,
        };
        bool        d_debug;
        unsigned    d_nErrors;
        int         d_token;
        unsigned    d_state;
        STYPE      *d_vsp;
        STYPE       d_val;

        CalculatorBase();

        void ABORT() const throw(Return);
        void ACCEPT() const throw(Return);
        void ERROR() const throw(ErrorRecovery);
        void clearin();

        bool debug() const
        {
            return d_debug;
        }
        void pop(unsigned count = 1);
        void push(unsigned nextState);
        unsigned reduce(PI const &productionInfo);
        void setDebug(bool mode)
        {
            d_debug = mode;
        }
        unsigned top() const;

// class CalculatorBase ends
};


// As a convenience, when including ParserBase\&.h its symbols are available as
// symbols in the class Parser, too\&.

#define Calculator CalculatorBase


#endif



.fi 

.IP o 
The parser class \fIcalculator\&.h\fP itself\&. In the grammar
specification various member functions are used (e\&.g\&., \fBdone()\fP) and
\fBprompt()\fP\&. These functions are so small that they can very well be
implemented inline\&. Note that \fBdone()\fP calls \fBACCEPT()\fP to terminate
further parsing\&. \fBACCEPT()\fP and related members (e\&.g\&., \fBABORT()\fP) can be
called from any member called by \fBparse()\fP\&. As a consequence, action blocks
could contain mere function calls, rather than several statements, thus
minimizing the need to rerun \fBbisonc++\fP when an action is modified\&.
.IP 
Once \fBbisonc++\fP had created \fBcalculator\&.h\fP it was augmented with the required
additional members, resulting in the following final version:
.nf 
#ifndef Calculator_h_included
#define Calculator_h_included

// for error()\&'s inline implementation
#include <iostream>

// $insert baseclass
#include "calculatorbase\&.h"
// $insert scanner\&.h
#include "\&.\&./scanner/scanner\&.h"


#undef Calculator
class Calculator: public CalculatorBase
{
    // $insert scannerobject
    Scanner d_scanner;
        
    public:
        int parse();

    private:
        void prompt()
        {
            std::cout << "? " << std::flush;
        }

        void done()
        {
            std::cout << "Done\en";
            ACCEPT();
        }

        void error(char const *msg)
        {
            std::cerr << msg << std::endl;
        }

        // $insert lex
        int lex()
        {
            return d_scanner\&.yylex();
        }

        void print()    // d_token, d_lloc (?)
        {}

    // support functions for parse():

        void executeAction(int d_production);
        unsigned errorRecovery();
        int lookup(int token);
        int nextToken();
};


#endif

.fi 

.IP o 
To complete the example, the following lexical scanner specification
was used:
.nf 
%{
    #define _SKIP_YYFLEXLEXER_
    #include "scanner\&.ih"

    #include "\&.\&./parser/calculatorbase\&.h"
%}

%option yyclass="Scanner" outfile="yylex\&.cc"
%option c++ 8bit warn noyywrap yylineno

%%

[ \et]+                          // skip white space

\en                              return Calculator::EOLN;

[0-9]+                          return Calculator::NUMBER;

\&.                               return yytext[0];


%%



.fi 

.IP o 
Since no member functions other than \fBparse()\fP were defined in
separate source files, only \fBparse()\fP includes \fBcalculator\&.ih\fP\&. Since
\fBcerr\fP and \fBendl\fP are used in the grammar\&'s actions, a \fIusing namespace
std\fP or comparable statement is required\&. This was effectuated from
\fBcalculator\&.ih\fP Here is the implementation header declaring the standard
namespace:
.nf 
// include this file in the sources of the class Calculator, 
// and add any includes etc\&. that are only needed for 
// the compilation of these sources\&.

// include the file defining the parser class:
#include "calculator\&.h"

// UN-comment if you don\&'t want to prefix std:: 
// for every symbol defined in the std\&. namespace:

using namespace std;

.fi 

The implementation of the parsing member function \fBparse()\fP is basically
irrelevant, since it should not be modified by the programmer\&. It was written
on the file \fIparse\&.cc\fP\&.
.IP o 
Finally, here is the program offering our simple calculator:
.nf 
#include "parser/calculator\&.h"

int main()
{
    Calculator calculator;
    return calculator\&.parse();
}

.fi 


.PP 
.SH "USING PARSER-CLASS SYMBOLS IN LEXICAL SCANNERS"

.PP 
Note here that although the file \fBcalculatorbase\&.h\fP, defining the
parser class\&' base-class, rather than the header file \fBcalculator\&.h\fP
defining the parser class is included, the lexical scanner may simply return
tokens of the class \fBCalculator\fP (e\&.g\&., \fBCalculator::NUMBER\fP rather than
\fBCalculatorBase::NUMBER\fP)\&. In fact, using a simple \fB#define - #undef\fP
pair generated by the \fBbisonc++\fP respectively at the end of the base class header
the file and just before the definition of the parser class itself it is
the possible to assume in the lexical scanner that all symbols defined in the
the parser\&'s base class are actually defined in the parser class itself\&. It
the should be noted that this feature can only be used to access base class
the \fBenum\fP and types\&. The actual parser class is not available by the time
the the lexical scanner is defined, thus avoiding circular class dependencies\&.
.PP 
.SH "FILES"
.IP o 
\fBbisonc++base\&.h\fP: skeleton of the parser\&'s base class;
.IP o 
\fBbisonc++\&.h\fP: skeleton of the parser class;
.IP o 
\fBbisonc++\&.ih\fP: skeleton of the implementation header;
.IP o 
\fBbisonc++\&.cc\fP: skeleton of the member \fBparse()\fP\&.
.SH "SEE ALSO"
\fBbison\fP(1), \fBbison++\fP(1), \fBbison\&.info\fP (using texinfo),
\fBflex++\fP(1)
.PP 
Lakos, J\&. (2001) \fBLarge Scale C++ Software Design\fP, Addison Wesley\&.
.br 
Aho, A\&.V\&., Sethi, R\&., Ullman, J\&.D\&. (1986) \fBCompilers\fP, Addison Wesley\&.
.PP 
.SH "BUGS"
The \fISemantic\fP- and \fIPure\fP parsers, mentioned in \fBbison++\fP(1) are
not implemented in \fBbisonc++\fP(1)\&. According to \fBbison++\fP(1) the semantic
parser was not available in \fBbison++\fP either, while the pure parser was
deemed `not very useful\&'\&.
.PP 
.SH "ABOUT bisonc++"

.PP 
\fBBisonc++\fP was based on \fBbison++\fP, originally developed by Alain
Coetmeur (coetmeur@icdc\&.fr), R&D department (RDT), Informatique-CDC, France,
who based his work on \fBbison\fP, GNU version 1\&.21\&. 
.PP 
\fBBisonc++\fP version 0\&.98 and beyond is a complete rewrite of an LALR-1 parser
generator, closely following the construction process as described in Aho,
Sethi and Ullman\&'s (1986) book \fBCompilers\fP (i\&.e\&., the \fIDragon book\fP)\&.  It
the uses same grammar specification as \fBbison\fP and \fBbison++\fP, and it uses
practically the same options and declarations as \fBbisonc++\fP versions earlier than
0\&.98\&. Variables, declarations and macros that are obsolete were removed\&. 
Since \fBbisonc++\fP is a completely new program, it will most likely contain
bugs\&. Please report bugs to the author:
.PP 
.SH "AUTHOR"

.PP 
Frank B\&. Brokken (f\&.b\&.brokken@rug\&.nl)\&.
