// Generated by Flexc++ V0.09.50 on Wed, 08 Feb 2012 11:05:26 +0100

#ifndef Scanner_H_INCLUDED_
#define Scanner_H_INCLUDED_

// $insert baseclass_h
#include "scannerbase.h"

#include <iosfwd>

#include <string>
#include <utility>

#include "../block/block.h"

namespace FBB
{
    class Mstream;
}

// $insert classHead
class Scanner: public ScannerBase
{
    size_t      d_nKept;        // used by <xstring>
    int         d_ret;

    size_t      d_number;       // only valid after tokens NUMBER and
                                // after escape(), octal() and 
                                // hexadecimal(). Illegal (long)
                                // character constants (> 1 char) have bit
                                // 8 set.

    bool        d_include;      // set to true/false by lexer-actions
    bool        d_includeOnly;

    char        d_commentChar[2];   // set to ' ' in `lexer' when C
                                // comment without \n is matched,
                                // otherwise set to \n. See
                                // `lexer' for details

    std::string d_nextSource;   // with the %include directive

    Block       d_block;            // action block retrieved fm the input

    std::string d_canonicalQuote;   // canonical quoted ident.
    std::string const &d_matched;

    size_t          d_maxDepth;     // max. file inclusion depth


    public:
        Scanner(std::string const &infile);
        
        // $insert lexFunctionDecl
        int lex();

        Block &block();
        std::string const &canonicalQuote();
        void clearBlock();
        std::ostream &lineMsg(FBB::Mstream &mstream);
        size_t number() const;
        bool hasBlock() const;
        bool includeOnly() const;
        void undelimit(bool warn);  // remove delimiters warn: about < >

    private:
        int lex__();
        int executeAction__(size_t ruleNr);

        void preCode();     // re-implement this function for code that must 
                            // be exec'ed before the patternmatching starts

        int tokenOrPushStream();
        void pushSource();

        void checkZeroNumber();
//        void recursiveInclusion(); also check: popSource

        void escape();
        void multiLineString();
        void octal();
        void hexadecimal();
        int matchedCheck(size_t minLength, int retToken);
};

// $insert inlineLexFunction
inline int Scanner::lex()
{
    return lex__();
}

inline void Scanner::preCode() 
{
    if (d_includeOnly)
        begin(StartCondition__::includeOnly);
}

inline Block &Scanner::block()
{
    return d_block;
}

inline void Scanner::clearBlock()
{
    d_block.clear();
}

inline size_t Scanner::number() const
{
    return d_number;
}

inline bool Scanner::hasBlock() const
{
    return not d_block.empty();
}

inline bool Scanner::includeOnly() const
{
    return d_includeOnly;
}


#endif // Scanner_H_INCLUDED_

