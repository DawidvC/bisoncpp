This file describes the lookahead-propagation procedure as used by Bisonc++

Consider the following grammar (from AHO et al, p. 241, example 4.46)

    1.  S*: S
    2.  S:  L = R
    3.  S:  R
    4.  L:  * R
    5.  L:  i
    6.  R:  L

After analyzing the grammar, the following states are found:

    S0: 
        1.  S*: . S
    
    S1:
        1.  S*: S .
    
    S2: 
        2.  S:  L . = R
        6.  R:  L .
    
    S3:
        3.  S:  R .
    
    S4:
        4.  L:  * . R
    
    S5:
        5.  L:  i .
    
    S6:
        2.  S:  L = . R
        
    S7:
        4.  L:  * R .
    
    S8: 
        6.  R:  L .
    
    S9:
        2.  S:  L = R .



For state 0 the following transition table is available:

    -------------------------------------------------------
    Transit on  LA of   Next state  Next state  Dependent  
    Symbol X    Symbol  on X        Kernel      N-symbol(s)
    -------------------------------------------------------
        S*                                          S,R 
        S               1           S*: S .         L
        L               2           S:  L . = R
                                    R:  L .
        R               3           S:  R .         L
        *               4           L:  * . R
        i               5           L:  i .
    -------------------------------------------------------

The `Dependent N-symbols' are the entries containing next-state kernel rules
of the form A -> a X . b,   where X is a dependent symbol and A the X symbol
of the line containing the dependent symbol. These dependent N symbols refer
to those entries whose lookaheads must be reconsidered if the current line's
LA set changes. So, if S* changes, the LA sets of the S and R sets must be
re-inspected. 

When inspecting a state, an LAset is provided. If the provided LAset is equal
to the currently stored LAset then no further inspection is required. The
currenly stored LAset is stored in the state itself as one of its data
members. 


At this point LA(S*) is set to $, so LA(S*) changes. Therefore, LA(S) and
LA(R) must be inspected, in turn causing LA(L) to be inspected (the notation
=$ means that both = and $ is the LA-set). This continues until no more
changes were made. 
    Initially, set      LA(S*) to $ 
    Changed. So set     LA(S) to $
        Changed. So set:    LA(L) to = (using rule S:  L . = R, having LHS = S)

    Next set            LA(R) to $
        Changed. So set:    LA(L) to =$ (using rule S:  R .)


    --------------------------------------------------------
    Transit on  LA of   Next state  Next state  Dependent  
    Symbol X    Symbol  on X        Kernel      N-symbol(s) 
    --------------------------------------------------------
        S*      $                                   S,R     
        S       $       1           S*: S .         L       
        L       =$      2           S:  L . = R             
                                    R:  L .
        R       $       3           S:  R .         L       
        *               4           L:  * . R
        i               5           L:  i .
    --------------------------------------------------------

Next, all entries are inspected: if an entry has a next state, then the LA-set
for the next state is collected from its production rules. E.g., when going to
state 2, use LA = LA(S) + LA(R) = $. When going to state 4 use LA(L) = =$.


The inspect(la) algorithm:

    foreach kernel item:            e.g., S* -> . S
        inspect(item.lhs, la)           inspect(S*, $)

    foreach destination state s:
        foreach production rule p 
            la += transition[p.lhs].la)
        s.inspect(la)



The function inspect(lhs, la) operates as follows:   (e.g., inspect(S*, $))
    kla = transition[lhs].la                        kla = {}
    if kla < la)
        kla += la                                   kla = $

        foreach dependent symbol                    S, R
        foreach production rule                     e.g., S*: S .
            laDot = computeLA(rule from dot, kla)   laDot = cpt(., $) = $
            inspect(symbolbeforedot, laDot)         inspect(S, $)
        
==========================================================================

The abovementioned algorithm may produce various conflicts. Here is an
improved version:

Start with the following simple grammar:

    1   run$:   run
    
    2   run:    one
    3   run:    two X
    
    4   one:  

    5   two:    one

This grammar produces the following states:

    S0:     run$:   .   run     (kernel)    

            run:    .   one     (non-kernel)
            run:    .   two X

            one:    .   
            two:    .   one
    

    S1:     run$:   run .       (accept)


    S2:     run:    one .       (kernel)
            two:    one .


    S3:     run:    two .   X   (kernel)


    S4:     run:    two X   .   (kernel)

Notation: 
    The notation FIRST(d L) indicates the FIRST set of the sequence `d L'. The
    notation {} is used to indicate the empty set. Otherwise, the terminals
    are shown in a blank-delimited list, e.g., {X $}

Within an item, its non-kernel items are inspected to obtain the
lookaheads. The lookaheads are propagated, starting from the 
initial $, representing EOF. 

With a particular item (L being its LA set):

            a:  b . C d, L

all rules of C must be added to the item as non-kernel items. These items 
use LA FIRST(d, L). When transiting to the next state, an item in a new state
inherits it LA set of its `parent'

The initial set receives LA {$}. So:

    S0: 1   run$:   .   run, {$}

In this set, the `run' rules must be added, receiving LA FIRST({} $) = {$}. 
So, the `run' rules become:

        2   run:    .   one     , {$}
        3   run:    .   two X   , {$}

From (2) the `one' rule is added, using LA FIRST({}, $) = $.

        4   one:    .           , {$}

From (3) the `two' rule is aded, receiving LA FIRST(X $) = X

        5   two:    .   one     , {X}

From (5) the `one' rules are once again added, receiving LA FIRST({}, X) = X

        4   one:    .           , {X $}     (revised)
    

    This results in:

    S0: 1   run$:   .   run, {$}
        2   run:    .   one     , {$}
        3   run:    .   two X   , {$}
        4   one:    .           , {X $}
        5   two:    .   one     , {X}

        Transitions on: 
            run -> S1
            one -> S2
            two -> S3

        There is one reduction in this state (4), so it becomes the default
        reduction. A default reduction is executed immediately upon entering
        its state:

        Reduce: according to rule 4 (by default)


   Transition on run, inheriting the LA set:

    S1: 1   run$:   run .   {$} 

        There is one reduction in this state (4), so it becomes the default
        reduction. 
    
        Reduce: according to rule 1 (by default)


   Transition on one, inheriting the LA sets:

    S2: 2   run:    one .   , {$}
        5   two:    one .   , {X}

        There are two reductions in this state (2, 5). There is no conflict as
        they have different LA sets. So:

        Reduce on:
            $:  according to rule 2
            X:  according to rule 5

            (Optionally, define one as the default reduction).

   Transition on two, inheriting the LA set:

    S3: 3   run:    two .   X   , {$}

        Transition on
            X -> S4, LA remains unaltered:


    S4: 3   run:    two X   .   , {$}

        Reduce: according to rule 3 (by default)

==========================================================================

Now reconsider the first grammar in this file, reananalyzing its LA sets:

    Here's the grammar:

        1.  S*: S
        2.  S:  L = R
        3.  S:  R
        4.  L:  * R
        5.  L:  i
        6.  R:  L

Here are the states:

    S0: 1.  S*: . S
    
    S1: 1.  S*: S .
    
    S2: 2.  S:  L . = R
        6.  R:  L .
    
    S3: 3.  S:  R .
    
    S4: 4.  L:  * . R
    
    S5: 5.  L:  i .
    
    S6: 2.  S:  L = . R
        
    S7: 4.  L:  * R .
    
    S8: 6.  R:  L .
    
    S9: 2.  S:  L = R .


Start at state S0, LA {$}:


S0: 1.  S*: . S ,   {$}

    Adding the `S' rules, same LA, we get:
        2.  S:  .   L = R   {$}
        3.  S:  .   R       {$}

    Adding the `L' rules from (2), LA {=} is used:
        4.  L:  .   * R     {=}
        5.  L:  .   i       {=}

    Adding the `R' rule from (3), LA {$} is kept:
        6.  R:  .   L       {$}

    Revising the L rules from (6), LA {$} is added:
        4.  L:  .   * R     {= $}       (revised)
        5.  L:  .   i       {= $}       (revised)

    This results in:
        S0: 1.  S*: . S ,   {$}
            2.  S:  .   L = R   {$}
            3.  S:  .   R       {$}
            4.  L:  .   * R     {= $}     
            5.  L:  .   i       {= $}     
            6.  R:  .   L       {$}

    Transitions on: 
        S   -> S1
        L   -> S2
        R   -> S3
        *   -> S4
        i   -> S5

   Transition on S, inheriting the LA set:
        S1: 1.  S*: S . {$}     (accept)

   Transition on L, inheriting the LA set:
        S2: 2.  S:  L . = R     {$)     (LA inherited from 2)
            6.  R:  L .         ($)     (LA inherited from 6)

   Transition on R, inheriting the LA set:
        S3: 3.  S:  R .         {$}

   Transition on *, inheriting the LA set:
        S4: 4.  L:  * . R       {= $}

    Transition on i, inheriting the LA set:
        S5: 5.  L:  i .         {= $}


S1: 1.  S*: S . {$}     (accept)

    Reduce: according to rule 1 (by default)


S2: 2.  S:  L . = R     {$)
    6.  R:  L .         ($)

    Transition on:
        =   -> S6

    Reduce: according to (6) by default.

    Transition on =, inheriting the LA set:
        S6: 2.  S:  L = . R     {$)     (LA inherited from 2)


S3: 3.  S:  R .         {$}

    Reduce: according to rule 3 (by default)

     
S4: 4.  L:  * . R       {= $}

    Adding the R rules, LA unaltered:
        6.  R:  .   L       {= $}

    Adding the L rules from (6), LA unaltered:
        4.  L:  .   * R     {= $}
        5.  L:  .   i       {= $}

    This results in:
        S4: 4.  L:  * . R       {= $}
            6.  R:  .   L       {= $}
            4.  L:  .   * R     {= $}
            5.  L:  .   i       {= $}

    Transition on:
        R   -> S7
        L   -> S8
        *   -> S4
        i   -> S5

    Transition on  R, inheriting LA {= $}
        S7: 4.  L:  * R .   {$ =}

    Transition on  L, inheriting LA {= $}
        S8: 6.  R:  L . {= $}

   Transition on *, inheriting the LA set:
        S4: 4.  L:  * . R       {= $} 
        LA set at 4 already {= $}. No need to change. Done.


    Transition on i, inheriting the LA set:
        S5: 5.  L:  i .         {= $}
        LA set at 5 already {= $}. No need to change. Done.

        
S5: 5.  L:  i .             {= $}
    
    Reduce: according to rule 5 (by default)


S6: 2.  S:  L = . R     {$)

    Adding the R rules, LA unaltered:
        6.  R:  .   L       {$}

    Adding the L rules from (6), LA unaltered:
        4.  L:  .   * R     {$}
        5.  L:  .   i       {$}

    This results in:
        2.  S:  L = R .     {$}
        6.  R:  .   L       {$}
        4.  L:  .   * R     {$}
        5.  L:  .   i       {$}

    Transition on:
        R   -> S9
        L   -> S8
        *   -> S4
        i   -> S5

    Transition on  R, inheriting LA {= $}
        S9: 2.  S:  L = R . {$}
      
    Transition on  L, inheriting LA {= $}
        S8: 6.  R:  L . {$}
        LA set at S8 already contains {$}. No need to change. Done.
        
   Transition on *, inheriting the LA set:
        S4: 4.  L:  * . R       {$} 
        LA set at 4 already contains {$}. No need to change. Done.

    Transition on i, inheriting the LA set:
        S5: 5.  L:  i .         {$}
        LA set at 5 already contains {$}. No need to change. Done.


S7: 4.  L:  * R .       {= $}

    Reduce: according to rule 4 (by default)

S8: 6.  R:  L .         {= $}
    
    Reduce: according to rule 6 (by default)

S9: 2.  S:  L = R .     {$}

    Reduce: according to rule 2 (by default)

==========================================================================

Finally consider Aho's 4.42 grammar, p. 231:

    1.  S*:  S
    2.  S:   C C
    3.  C:   c C
    4.  C:   d

Starting at 1, using LA {$}

S0: 1.  S*: . S         {$}

    Add production rules from S, using LA {$}:
        2.  S: . C C    {$}
        
    Add production rules from C, using LA FIRST(C $} = {c d}
        3.  C: . c C    {c d}
        4.  C: . d      {c d}

    Resulting in:
        S0: 1.  S*: . S     {$}
            2.  S: . C C    {$}
            3.  C: . c C    {c d}
            4.  C: . d      {c d}

    Transitions on:
        S -> S1
        C -> S2
        c -> S3
        d -> S4

    Transition on S, inheriting LA:
        S1: 1.  S*: S .     {$}

    Transition on C, inheriting LA:
        S2: 2.  S: C . C    {$}

    Transition on c, inheriting LA:
        S3: 3.  C: c . C    {c d}

    Transition on d, inheriting LA:
        S4: 4.  C: d .      {c d}


S1: 1.  S*: S .     {$}

    Reduce: according to rule 1 (by default)

S2: 2.  S: C . C    {$}

    Add production rules from C, using LA FIRST($} = {$}
        3.  C: . c C    {$}
        4.  C: . d      {$}

    Resulting in:
        S2: 2.  S: C . C    {$}
            3.  C: . c C    {$}
            4.  C: . d      {$}

    Transition on C, inheriting LA:
        S5: 2.  S: C C .    {$}

    Transition on c, inheriting LA:
        S3: 3.  C: c . C    {$}
        Add $ to LA set of S3

    Transition on d, inheriting LA:
        S4: 4.  C: d .      {c d}
        Add $ to LA set of S4

S3: 3.  C: c . C    {c d $}
    Add production rules from C, using LA FIRST($} = {$}
        3.  C: . c C    {$}
        4.  C: . d      {$}


S4: 4.  C: d .      {c d $}
S5: 2.  S: C C .    {$}








