#include "itemsets.ih"

void ItemSets::define(Production const *startProduction)
{
        // start with S' -> . S, $ ($ meaning: EOF in subsequent comment)
    
        // $ is generated spontaneously by me. I'm not going to iterate over
        // all states to determine where the lookaheads propagate to, or which
        // lookaheads, generated spontaneously, end up in which states, but
        // instead I'm directly passing the proper lookaheads to the generated
        // states.

                                // Initial state lookahead (endmarker)
                                // generated by me.
    d_state.push_back(new State(Item(startProduction)));
    d_state.back()->setIdx(0);

        // a State() constructor does not construct its kernel/nonkernel
        // items. Those are determined by closure().
        // The gotos/actions take the lookaheads into account.

    d_state[0]->closure();

    unsigned nStates;
    unsigned begin = 0;

        // different from the dragon book's algorithm: once a state has been
        // inspected, it is not inspected again, since we have already
        // inspected it. If, after all, this turns out to be wrong, simply
        // remove the state-checks and have the for-loop state at 0 each time.
        // While working on a state, its action and goto tables are
        // constructed. Therefore, once I'm done with a state, so just before
        // incrementing `state' I can set its action and goto vectors. If the
        // abovementioned shorthand doesn't work, then I need to set the
        // state/goto pointers to the actual states stored in the State
        // objects, each time we redo the while-loop.

        // Adjusting reduce-actions may occur at the end if new lookaheadsets
        // were added to earlier states.

    while (true)
    {
        nStates = d_state.size();           // current number of states
            // Inspect each state. If its goto(x, i) is not empty, and 
            // unique, add it to dstate

            // can't use for_each() here, since insertions modify the 
            // locations of the data elements, thus invalidating the iterators
        for (unsigned idx = begin; idx < nStates; ++idx)
            inspect(idx);

        if (d_recheckState < nStates)
        {
            msg() << "\n"
            "Re-iterating from state  " << d_recheckState << " to state " <<
                    nStates << info;
            begin = d_recheckState;
            d_recheckState = COMPLETED;
            continue;
        }

        begin = nStates;

        msg() << "Completed an ItemSets::define() iteration: from " <<
                    nStates  << " to " << 
                    d_state.size() << " states" << info;

        if (nStates == d_state.size())
            break;
    }


    msg() << "\n"
            "Determined " << nStates << " states\n"
            "Overview of states:" << info;

    for (unsigned idx = 0; idx < nStates; ++idx)
    {
        msg() << "State " << idx << ":" << info;
        d_state[idx]->show();
    }
}



