    // Include this file in the sources of the class Parser.

// $insert class.h
#include "parser.h"

#include <bobcat/mstream>
#include <bobcat/ranger>

#include "../block/block.h"
#include "../options/options.h"


using namespace std;
using namespace FBB;

inline string const &Parser::productionTag(int nr) const
{
    return nr == numeric_limits<int>::max() ? d_rules.sType() :
                                              d_rules.sType(nr);
}

inline void Parser::checkEmptyBlocktype() 
{
    checkFirstType();
}

inline void Parser::warnTagMismatches() const
{
    d_options.setTagMismatches(d_scanner.matched(), 
                                d_scanner.filename(), d_scanner.lineNr());
}

inline void Parser::constructorChecks() const
{
    d_options.setConstructorChecks(d_scanner.matched(), 
                                d_scanner.filename(), d_scanner.lineNr());
}

inline void Parser::defaultAction() const
{
    d_options.setDefaultAction(d_scanner.matched(), 
                                d_scanner.filename(), d_scanner.lineNr());
}

//FBB inline bool Parser::noID(string const &) const
//FBB {
//FBB     return false;
//FBB }
//FBB 
//FBB inline bool Parser::idOK(string const &) const
//FBB {
//FBB     return true;
//FBB }
//FBB 
//FBB inline bool Parser::findTag(string const &tag) const
//FBB {
//FBB     return d_polymorphic.find(tag) != d_polymorphic.end();
//FBB }

inline int Parser::nComponents(int nElements)
{
    return nElements >= 0 ? nElements : -nElements - 1;
}

inline void Parser::print()
{
    if (d_arg.option('T'))
        print__();
}

inline void Parser::setNegativeDollarIndices()
{
    d_negativeDollarIndicesOK = true;
}        

inline void Parser::setExpectedConflicts()
{
    Rules::setExpectedConflicts(d_scanner.number());
}

// $insert lex
inline int Parser::lex()
{
    return d_scanner.lex();
}

inline void Parser::exceptionHandler__(std::exception const &exc)
{
    throw;  // re-implement to handle exceptions thrown by actions
}
