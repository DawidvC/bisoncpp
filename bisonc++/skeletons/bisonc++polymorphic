namespace Meta__
{
    template <Tag__ tag>
    struct TypeOf;

    template <typename Tp_>
    struct TagOf;

$insert polymorphicSpecializations

        // The Base class: 
        // Individual semantic value classes are derived from this class.
        // This class offers a member returning the value's Tag__,
        // a member cloning the object of its derived Semantic<Tag__> 
        // and a member returning a pointerr to its derived Semantic<Tag__> 
        // data, used by SType. Since SType's user knows what data type 
        // he/she looks at, the user can do a static cast to that type.
        // See also Bisonc++'s distribution file README.polymorphic-techical
    class Base
    {
        protected:

            Tag__ d_baseTag;    // Base should not be used for Tag__ values
                                // outside of the enum class Tag__ range.
    
                // these members implement polymorphism without using
                // virtual functions. 
            Base *(*d_baseClone)(Base const *thisObj) = error;
            void *(*d_baseData)(Base const *thisObj) = 0;

        public:
            Base();

            Base(Base const &other) = delete;

            Tag__ tag() const;
            Base *clone() const;
            void *data() const;        

        private:
            static Base *error(Base const *obj);
    };

        // The class Semantic is derived from Base. It stores a particular
        // semantic value type. 
    template <Tag__ tg_>
    class Semantic: public Base
    {
        typename TypeOf<tg_>::type d_data;
        
        public:
            Semantic();
            Semantic(Semantic<tg_> const &other);

                // The constructor member template forwards its arguments to
                // d_data, allowing it to be initialized using whatever
                // constructor is available for DataType
            template <typename ...Params>
            Semantic(Params &&...params);

        private:
            static Base *clone(Base const *obj);
            static void *data(Base const *obj);
    };

        // The class Stype wraps the shared_ptr holding a pointer to Base.  It
        // becomes the polymorphic STYPE__ It also defines a get member,
        // allowing constructions like $$.get<INT> to be used.  Instantiations
        // of its operator= member template are used to assign semantic values
        // to the SType object.
    class SType
    {
        Base *d_base;

        public:
            SType();
            SType(SType const &other);
            SType(SType &&tmp);
    
            ~SType();
    
                // Specific overloads are needed for SType = SType assignments
            SType &operator=(SType const &rhs);
            SType &operator=(SType &&tmp);
    
                // A template member operator= is used because it allows
                // the compiler to deduce the appropriate typename
            template <typename Type>
            SType &operator=(Type const &value);
    
                // this get()-member checks for invalid Semantic data and
                // (when initialized) for tags matching the tag of the stored
                // semantic value, or if the tag specified with get() does not
                // match the tag that's currently stored, then SType is
                // initialized to a default value of the type matching
                // 'tag'. If no default constructor for that type exists a
                // runtime error exception results. The option or directive 
                // warn-tag-mismatch can be specified to generate run-time 
                // warnings about tag mismatches to cerr.
            template <Tag__ tag>
            typename TypeOf<tag>::type &get();
    
                // the data()-member does not check, and may result in a 
                // segfault if used incorrectly
            template <Tag__ tag>
            typename TypeOf<tag>::type &data();
    
            template <Tag__ tag, typename ...Args>
            void emplace(Args &&...args);
        
            void swap(SType &other);
    };

}  // namespace Meta__


