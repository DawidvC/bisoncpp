namespace Meta__
{

inline Base::Base()
:
    d_baseTag(static_cast<Tag__>(sizeofTag__))
{}

inline Tag__ Base::tag() const
{
    return d_baseTag;
}

inline Base *Base::error(Base const *obj)
{
    std::runtime_error("Internal error: Base::clone() or Base::data() "
                       "called for default Base");
    return 0;           // to prevent `no return value' complaints
}

inline Base *Base::clone() const
{
    return d_baseClone(this);
}

inline void *Base::data() const
{
    return d_baseData(this);
}

template <Tag__ tg_>
Semantic<tg_>::Semantic()
{
        // Setting Base's data members:
    d_baseTag = tg_;
    d_baseClone = clone;
    d_baseData =  data;
}

template <Tag__ tg_>
Semantic<tg_>::Semantic(Semantic<tg_> const &other)
{
        // Setting Base's data members:
    d_baseTag = other.d_baseTag;
    d_baseClone = other.d_baseClone;
    d_baseData =  other.d_baseData;
}

template <Tag__ tg_>
template <typename ...Params>
Semantic<tg_>::Semantic(Params &&...params)
:
    d_data(std::forward<Params>(params) ...)
{
        // Setting Base's data members:
    d_baseTag = tg_;
    d_baseClone = clone;
    d_baseData =  data;
}

template <Tag__ tg_>
inline Base *Semantic<tg_>::clone(Base const *obj) // static
{
    return new Semantic<tg_>{*static_cast<Semantic<tg_> const *>(obj)};
}

template <Tag__ tg_>
inline void *Semantic<tg_>::data(Base const *obj) // static
{
    return &static_cast<Semantic<tg_> *>(const_cast<Base *>(obj))->d_data;
}


inline SType::SType()
:
    d_base(new Base)        // default Base object doesn't do anyting
{}                          // but prevents tests for d_base == 0

inline SType::SType(SType const &other)
:
    d_base(other.d_base->clone())
{}

inline SType::SType(SType &&tmp)
:
    d_base(tmp.d_base)
{
    tmp.d_base = 0;
}

inline SType::~SType()
{
    delete d_base;
}

inline SType &SType::operator=(SType &&tmp)
{
    swap(tmp);
    return *this;
}

    // A template assignment function is used because it allows
    // the compiler to deduce the appropriate typename
template <typename Type>
inline SType &SType::operator=(Type const &value)
{
    emplace< TagOf<Type>::tag >(value);
    return *this;
}

    // the data()-member does not check, and may result in a 
    // segfault if used incorrectly
template <Tag__ tag>
inline typename TypeOf<tag>::type &SType::data()
{
    return *static_cast<typename TypeOf<tag>::type *>(d_base->data());
}

} // namespace Meta__
