<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<title>bisonc++</title>
<style type="text/css">
    body {color: #27408B; background: #FFFAF0;}
    figure {text-align: center;}
    img {vertical-align: center;}
</style>
<link rev="made" href="mailto:Frank B. Brokken: f.b.brokken@rug.nl">
</head>
<body>
<hr/>
<h1 id="title">bisonc++</h1>
<h2 id="author">bisonc++.4.13.00.tar.gz</h2>
<h2 id="date">2005-2015</h2>

<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<style type="text/css">
    body {color: #27408B; background: #FFFAF0;}
    figure {text-align: center;}
    img {vertical-align: center;}
    figure {text-align: center;}
    img {vertical-align: center;}
</style>
<link rev="made" href="mailto:Frank B. Brokken: f.b.brokken@rug.nl">
</head>
<body>
<hr/>
<h1 id="title"></h1>

<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<title>bisonc++(1)</title>
<style type="text/css">
    body {color: #27408B; background: #FFFAF0;}
    figure {text-align: center;}
    img {vertical-align: center;}
    figure {text-align: center;}
    img {vertical-align: center;}
    figure {text-align: center;}
    img {vertical-align: center;}
</style>
<link rev="made" href="mailto:Frank B. Brokken: f.b.brokken@rug.nl">
</head>
<body>
<hr/>
<h1 id="title">bisonc++(1)</h1>
<h2 id="author">bisonc++.4.13.00.tar.gz bisonc++ parser generator</h2>
<h2 id="date">2005-2015</h2>


<p>

<h2>NAME</h2>bisonc++ - Generate a C++ parser class and parsing function
<p>

<h2>SYNOPSIS</h2>
       <strong>bisonc++</strong> [OPTIONS] <em>grammar-file</em>
<p>
<h2>SECTIONS</h2>
    This manual page contains the following sections:
    <dl>
    <dt><strong>1. DESCRIPTION</strong></dt> overview and short history of of <strong>bisonc++</strong>;
    <dt><strong>2. GENERATED FILES</strong></dt> files <strong>bisonc++</strong> may generate;
    <dt><strong>3. OPTIONS</strong></dt> <strong>Bisonc++</strong>'s command-line options;
    <dt><strong>4. DIRECTIVES</strong></dt> <strong>Bisonc++</strong>'s grammar-specification directives;
    <dt><strong>5. POLYMORPHIC SEMANTIC VALUES</strong></dt> How to use polymorphic semantic values
       in parsers generated by <strong>bisonc++</strong>;
    <dt><strong>6. PUBLIC MEMBERS AND -TYPES</strong></dt> Members and types that can be used by
        calling software;
    <dt><strong>7. PRIVATE ENUMS AND -TYPES</strong></dt> Enumerations and types only available
        to the <em>Parser</em> class;
    <dt><strong>8. PRIVATE MEMBER FUNCTIONS</strong></dt> Member functions that are only available
        to the <em>Parser</em> class;
    <dt><strong>9. PRIVATE DATA MEMBERS</strong></dt> Data members that are only available
        to the <em>Parser</em> class;
    <dt><strong>10. TYPES AND VARIABLES IN THE ANONYMOUS NAMESPACE</strong></dt> An overview of the
        types and variables that are used to define and store the
        grammar-tables generated by <strong>bisonc++</strong>;
    <dt><strong>11. RESTRICTIONS ON TOKEN NAMES</strong></dt> Name restrictions for user-defined
        symbols;
    <dt><strong>12. OBSOLETE SYMBOLS</strong></dt> Symbols available to <strong>bison</strong>(1), but not to
        <strong>bisonc++</strong>;
    <dt><strong>13. EXAMPLE</strong></dt> Guess what this is?
    <dt><strong>14. USING PARSER-CLASS SYMBOLS IN LEXICAL SCANNERS</strong></dt> How to refer to
        <em>Parser</em> tokens from within a lexical scanner;
    <dt><strong>15. FILES</strong></dt> (Skeleton) files used by <strong>bisonc++</strong>;
    <dt><strong>16. SEE ALSO</strong></dt> References to other programs and documentation;
    <dt><strong>17. BUGS</strong></dt> Some additional stuff that should not qualify as bugs.
    <dt><strong>18. ABOUT bisonc++</strong></dt> More history;
    <dt><strong>AUTHOR</strong></dt> At the end of this man-page.
    </dl>
<p>
Looking for a specific section? Search for its number + a dot.
<p>
<h2>1. DESCRIPTION</h2>
<p>
<strong>Bisonc++</strong> derives from previous work on <strong>bison</strong> by Alain Coetmeur
(coetmeur@icdc.fr), who created in the early '90s a <strong>C++</strong> class encapsulating
the <em>yyparse</em> function as generated by the GNU-<strong>bison</strong> parser generator.
<p>
Initial versions of <strong>bisonc++</strong> (up to version 0.92) wrapped Alain's program in
a program offering a more modern user-interface, removing all old-style
(<strong>C</strong>) <em>%define</em> directives from <strong>bison++</strong>'s input specification file
(see below for an in-depth discussion of the differences between <strong>bison++</strong>
and <strong>bisonc++</strong>). Starting with version 0.98, <strong>bisonc++</strong> represents a complete rebuilt of
the parser generator, closely following descriptions given in Aho, Sethi and
Ullman's <em>Dragon Book</em>. Since version 0.98 <strong>bisonc++</strong> is a <strong>C++</strong> program, rather
than a <strong>C</strong> program generating <strong>C++</strong> code.
<p>
<strong>Bisonc++</strong> expands the concepts initially implemented in <strong>bison</strong> and
<strong>bison++</strong>, offering a cleaner setup of the generated parser class. The
parser class is derived from a base-class, mainly containing the parser's
token- and type-definitions as well as several member functions which should
not be modified by the programmer. 
<p>
Most of these base-class members might also be defined directly in the
parser class, but were defined in the parser's base-class. This design results
in a very lean parser class, declaring only members that are actually defined
by the programmer or that have to be defined by <strong>bisonc++</strong> itself (e.g., the
member function <em>parse</em> as well as some support functions requiring access
to facilities that are only available in the parser class itself, rather than
in the parser's base class).  
<p>
This design does not require any virtual members: the members which are
not involved in the actual parsing process may always be (re)implemented
directly by the programmer. Thus there is no need to apply or define virtual
member functions.
<p>
In fact, there are only two public members in the parser class generated
by <strong>bisonc++</strong>: <em>setDebug</em> (see below) and <em>parse</em>. Remaining members are
private, and those that can be redefined by the programmer using <strong>bisonc++</strong> usually
receive initial, very simple default in-line implementations. The (partial)
exception to this rule is the member function <em>lex</em>, producing the next
lexical token. For <em>lex</em> either a standardized interface or a mere
declaration is offered (requiring the programmer to provide his/her own 
<em>lex</em> implementation).
<p>
To enforce a primitive namespace, <strong>bison</strong> used a well-known
naming-convention: all its public symbols started with <em>yy</em> or <em>YY</em>.
<strong>Bison++</strong> followed <strong>bison</strong> in this respect, even though a class by itself
offers enough protection of its identifiers. Consequently, these <em>yy</em> and
<em>YY</em> conventions are now outdated, and <strong>bisonc++</strong> does not generate or use
symbols defined in either the parser (base) class or in its member functions
starting with <em>yy</em> or <em>YY</em>. Instead, following a suggestion by Lakos
(2001), all data members start with <em>d_</em>, and all static data members start
with <em>s_</em>. This convention was not introduced to enforce identifier
protection, but to clarify the storage type of variables. Other (local)
symbols lack specific prefixes. Furthermore, <strong>bisonc++</strong> allows its users to define
the parser class in a particular namespace of their own choice.
<p>
<strong>Bisonc++</strong> should be used as follows:
    <ul>
    <li> As usual, a grammar must be defined. With <strong>bisonc++</strong> this is not
different, and the reader is referred to <strong>bisonc++</strong>'s manual and other sources
(like Aho, Sethi and Ullman's book) for details about how to specify and
decorate grammars.
    <li> The number and function of the various <em>%define</em> declarations as
used by <strong>bison++</strong>, however, is greatly modified. Actually, all of
<strong>bison</strong>'s <em>%define</em> declarations were replaced by their (former) first
arguments. Furthermore, `macro-style' declarations are no longer supported or
required. Finally, all directives use lower-case characters only and do not
contain underscore characters (but sometimes hyphens). E.g., <em>%define DEBUG</em>
is now declared as <em>%debug</em>; <em>%define LSP_NEEDED</em> is now declared as
<em>%lsp-needed</em> (note the hyphen).
    <li> As noted, no `macro style' <em>%define</em> declarations are required
anymore. Instead, the normal practice of defining class members in source
files and declaring them in a class header files can be adhered to using
<strong>bisonc++</strong>.  Basically, <strong>bisonc++</strong> concentrates on its main tasks: defining a
parser class and implementing its parsing function <em>int parse</em>,
leaving all other parts of the parser class' definition to the programmer.
    <li> Having specified the grammar and (usually) some directives <strong>bisonc++</strong> is
able to generate files defining the parser class and to implement the
member function <em>parse</em> and its support functions. See the next section
for details about the various files that may be generated by <strong>bisonc++</strong>.
    <li> All members (except for the member <em>parse</em> and its support
functions) must be implemented by the programmer. Additional member functions
should be declared in the parser class' header.  At the very least the member
<em>int lex()</em> <em>must</em> be implemented (although a standard implementation
can be generated by <strong>bisonc++</strong>). The member <em>lex</em> is called by <em>parse</em> to
obtain the next available token. The member function <em>void error(char const
*msg)</em> may also be re-implemented by the programmer, and a basic in-line
implementation is provided by default. The member function <em>error</em> is called
when <em>parse</em> detects (syntactic) errors.
    <li> The parser can now be used in a program. A very simple example would
be: 
        <pre>

    int main()
    {
        Parser parser;
        return parser.parse();
    }
        
</pre>

    </ul>
<p>
<h2>2. GENERATED FILES</h2>
<p>
<strong>Bisonc++</strong> may create the following files:
    <ul>
    <li> A file containing the implementation of the member function <em>parse</em>
and its support functions. The member <em>parse</em> is a public member that can be
called to parse a token-sequence according to a specified LALR1 type of
grammar. By default the implementations of these members are written on the
file <em>parse.cc</em>. The programmer should not modify the contents of this file;
it is rewritten every time <strong>bisonc++</strong> is called.
    <li> A file containing an initial setup of the parser class, containing
the declaration of the public member <em>parse</em> and of its (private) support
members. New members may safely be declared in the parser class, as it is only
created by <strong>bisonc++</strong> if not yet existing, using the filename <em>&lt;parser-class&gt;.h</em>
(where <em>&lt;parser-class&gt;</em> is the the name of the defined parser class).
        <li> A file containing the parser class' <em>base class</em>. This base
class should not be modified by the programmer. It contains types defined by
<strong>bisonc++</strong>, as well as several (protected) data members and member functions, which
should not be redefined by the programmer. All symbolic parser terminal tokens
are defined in this class, thereby escalating these definitions to a separate
class (cf. Lakos, (2001)), which in turn prevents circular dependencies
between the lexical scanner and the parser (here, circular dependencies may
easily be encountered, as the parser needs access to the lexical scanner class
when defining the lexical scanner as one of its data members, whereas the
lexical scanner needs access to the parser class to know about the grammar's
symbolic terminal tokens; escalation is a way out of such circular
dependencies). By default this file is (re)written any time <strong>bisonc++</strong> is called,
using the filename <em>&lt;parser-class&gt;base.h</em>.
        <li> A file containing an <em>implementation header</em>. The
implementation header rather than the parser's class header file should be
included by the parser's source files implementing member functions declared
by the programmer. The implementation header first includes the parser class's
header file, and then provides default in-line implementations for its members
<em>error</em> and <em>print</em> (which may be altered by the programmer). The member
<em>lex</em> may also receive a standard in-line implementation. Alternatively, its
implementation can be provided by the programmer (see below).  Any directives
and/or namespace directives required for the proper compilation of the
parser's additional member functions should be declared next. The
implementation header is included by the file defining <em>parse</em>. By default
the implementation header is created if not yet existing, receiving the
filename <em>&lt;parser-class&gt;.ih</em>.
        <li> A verbose description of the generated parser. This file is
comparable to the verbose ouput file originally generated by <strong>bison++</strong>. It
is generated when the option <em>--verbose</em> or <em>-V</em> is provided. If so, <strong>bisonc++</strong>
writes the file <em>&lt;grammar&gt;.output</em>, where <em>&lt;grammar&gt;</em> is the name of the
file containing the grammar definition.
        </ul>
<p>
<h2>3. OPTIONS</h2>
        Where available, single letter options are listed between parentheses
beyond their associated long-option variants. Single letter options require
arguments if their associated long options require arguments. Options
affecting the class header or implementation header file are ignored if these
files already exist. Options accepting a `filename' do not accept path names,
i.e., they cannot contain directory separators (<em>/</em>); options accepting a
'pathname' may contain directory separators. 
<p>
Some options may generate errors. This happens when an option conflicts with
the contents of a file which <strong>bisonc++</strong> cannot modify (e.g., a parser
class header file exists, but doesn't define a name space, but a
<em>--namespace</em> option was provided). 
<p>
To solve the error the offending option could be omitted, the existing file
could be removed, or the existing file could be hand-edited according to the
option's specification. Note that <strong>bisonc++</strong> currently does not handle the opposite
error condition: if a previously used option is omitted, then <strong>bisonc++</strong> does not
detect the inconsistency. In those cases compilation errors may be generated.
<p>
<ul>
    <li> <strong>--analyze-only</strong> (<strong>-A</strong>)<br/>
           Only analyze the grammar. No files are (re)written. This option can
            be used to test the grammatic correctness of modification `in
            situ', without overwriting previously generated files. If the
            grammar contains syntactic errors only syntax analysis is 
            performed.
<p>
<li> <strong>--baseclass-header</strong>=<em>filename</em> (<strong>-b</strong>)<br/>
           <em>Filename</em> defines the name of the file to contain the parser's
            base class. This class defines, e.g., the parser's symbolic
            tokens. Defaults to the name of the parser class plus the suffix
            <em>base.h</em>. It is generated, unless otherwise indicated (see
            <em>--no-baseclass-header</em> and <em>--dont-rewrite-baseclass-header</em>
            below).
<p>
It is an error if this option is used and an already
            existing parser class header file does not contain <em>#include
            "filename"</em>.
<p>
<li> <a name="PREINCLUDE"></a> <strong>--baseclass-preinclude</strong>=<em>pathname</em> (<strong>-H</strong>)<br/>
           <em>Pathname</em> defines  the path to the file preincluded in the
            parser's base-class header. This option is needed in situations
            where the base class header file refers to types which might not
            yet be known. E.g., with polymorphic semantic values a
            <em>std::string</em> value type might be used. Since the <em>string</em>
            header file is not by default included in <em>parserbase.h</em> we
            somehow need to inform the compiler about this and possibly other
            headers. The suggested procedure is to use a pre-include header
            file declaring the required types. By default `<em>header</em>' is
            surrounded by double quotes: <em>#include "header"</em> is used when
            the option <em>-H header</em> is specified.  When the argument is
            surrounded by pointed brackets <em>#include &lt;header&gt;</em> is
            included. In the latter case, quotes might be required to escape
            interpretation by the shell (e.g., using <em>-H '&lt;header&gt;'</em>).
<p>
<li> <strong>--baseclass-skeleton</strong>=<em>pathname</em> (<strong>-B</strong>)<br/> 
           <em>Pathname</em> defines the path name to the file containing the
            skeleton of the parser's base class. It defaults to the
            installation-defined default path name (e.g.,
            <em>/usr/share/bisonc++/</em> plus <em>bisonc++base.h</em>).
<p>
<li> <strong>--class-header</strong>=<em>filename</em> (<strong>-c</strong>)<br/>
           <em>Filename</em> defines the name of the file to contain the parser
            class. Defaults to the name of the parser class plus the suffix
            <em>.h</em>
<p>
It is an error if this option is used and an already
            existing implementation header file does not contain <em>#include
            "filename"</em>.
<p>
<li> <strong>--class-name</strong> <em>className</em> <br/>
           Defines the name of the <strong>C++</strong> class that is generated.  If
            neither this option, nor the <em>%class-name</em> directory is
            specified, then the default class name (<em>Parser</em>) is used.
<p>
It is an error if this option is used and an already
            existing parser-class header file does not define <em>class
            `className'</em> and/or if an already existing implementation header
            file does not define members of the class <em>`className'</em>.
<p>
<li> <strong>--class-skeleton</strong>=<em>pathname</em> (<strong>-C</strong>)<br/>
           <em>Pathname</em> defines the path name to the file containing the
            skeleton of the parser class. It defaults to the
            installation-defined default path name (e.g.,
            <em>/usr/share/bisonc++/</em> plus <em>bisonc++.h</em>).
<p>
<li> <strong>--construction</strong><br/> 
           Details about the construction of the parsing tables are written to
            the same file as written by the <em>--verbose</em> option (i.e.,
            <em>&lt;grammar&gt;.output</em>, where <em>&lt;grammar&gt;</em> is the input file read
            by <strong>bisonc++</strong>. This information is primarily useful for developers. It
            augments the information written to the verbose grammar output
            file, generated by the <em>--verbose</em> option.
<p>
<li> <strong>--debug</strong><br/> 
           Provide <em>parse</em> and its support functions with debugging code,
            showing the actual parsing process on the standard output
            stream. When included, the debugging output is active by default,
            but its activity may be controlled using the <em>setDebug(bool
            on-off)</em> member. An <em>#ifdef DEBUG</em> macro is not supported by
            <strong>bisonc++</strong>. Rerun <strong>bisonc++</strong> without the <em>--debug</em> option to remove the
            debugging code.
<p>
<li> <a name="ERRORVERBOSE"></a><strong>--error-verbose</strong><br/>
           When a syntactic error is reported, the generated parse function
            dumps the parser's state stack to the standard output
            stream. The stack dump shows on separate lines a stack index
            followed by the state stored at the indicated stack element. The
            first stack element is the stack's top element.
<p>
<li> <strong>--filenames</strong>=<em>filename</em> (<strong>-f</strong>)<br/>
           <em>Filename</em> is a generic file name that is used for all header
            files generated by <strong>bisonc++</strong>. Options defining specific file names are
            also available (which then, in turn, overrule the name specified
            by this option).
<p>
<li> <strong>--flex</strong><br/> 
           <strong>Bisonc++</strong> generates code calling <em>d_scanner.yylex()</em> to obtain the
            next lexical token, and calling <em>d_scanner.YYText()</em> for the
            matched text, unless overruled by options or directives explicitly
            defining these functions. By default, the interface defined by
            <strong>flexc++</strong>(1) is used. This option is only interpreted if the
            <em>--scanner</em> option or <em>%scanner</em> directive is also used.
<p>
<li> <strong>--help</strong> (<strong>-h</strong>)<br/>
            Write basic usage information to the standard output stream and
            terminate. 
<p>
<li> <strong>--implementation-header</strong>=<em>filename</em> (<strong>-i</strong>)<br/>
           <em>Filename</em> defines the name of the file to contain the
            implementation header. It defaults to the name of the generated
            parser class plus the suffix <em>.ih</em>.
<p>
The implementation header should contain all directives and
            declarations <em>only</em> used by the implementations of the parser's
            member functions. It is the only header file that is included by
            the source file containing <em>parse</em>'s implementation. User
            defined implementation of other class members may use the same
            convention, thus concentrating all directives and declarations
            that are required for the compilation of other source files
            belonging to the parser class in one header file.
<p>
<li> <strong>--implementation-skeleton</strong>=<em>pathname</em> (<strong>-I</strong>)<br/>
           <em>Pathname</em> defines the path name to the file containing the
            skeleton of the implementation header. t defaults to the
            installation-defined default path name (e.g.,
            <em>/usr/share/bisonc++/</em> plus <em>bisonc++.ih</em>).
<p>
<li> <strong>--insert-stype</strong><br/>
           This option is only effective if the <em>debug</em> option (or
            <em>%debug</em> directive) has also been specified. When
            <em>insert-stype</em> has been specified the parsing function's debug
            output also shows selected semantic values. It should only be used
            if objects or variables of the semantic value type <em>STYPE__</em> can
            be inserted into <em>ostreams</em>.
<p>
<li> <a name="MAXDEPTH"></a> <strong>--max-inclusion-depth</strong>=<em>value</em><br/>
           Set the maximum number of nested grammar files. Defaults to 10.
<p>
<li> <strong>--namespace</strong> <em>identifier</em> <br/>
           Define all of the code generated by <strong>bisonc++</strong> in the name space
            <em>identifier</em>. By default no name space is defined. If this
            options is used the implementation header is provided with a
            commented out <em>using namespace</em> declaration for the specified
            name space. In addition, the parser and parser base class
            header files also use the specified namespace to define their
            include guard directives.
<p>
It is an error if this option is used and an already existing
            parser-class header file and/or implementation header file does
            not define <em>namespace identifier</em>.
<p>
<li> <strong>--no-baseclass-header</strong><br/>
           Do not write the file containing the parser class' base class, even
            if that file doesn't yet exist. By default the file containing the
            parser's base class is (re)written each time <strong>bisonc++</strong> is called. Note
            that this option should normally be avoided, as the base class
            defines the symbolic terminal tokens that are returned by the
            lexical scanner. When the construction of this file is suppressed,
            modifications of these terminal tokens are not communicated to the
            lexical scanner.
<p>
<li> <strong>--no-decoration</strong> (<strong>-D</strong>)<br/>
           Do not include the user-defined actions when generating the
            parser's <em>parse</em> member. This effectively generates a parser
            which merely performs semantic checks, without performing the
            actions which are normally executed when rules have been
            matched. This may be useful in situations where a (partially or
            completely) decorated grammar is reorganized, and the syntactical
            correctness of the modified grammar must be verified, or in
            situations where the grammar has already been decorated, but
            functions which are called from the rules's actions have not yet
            been impleemented.
<p>
<li> <strong>--no-default-action-return</strong> (<strong>-N</strong>)<br/>
           Do not use the default <em>$$ = $1</em> assignment of semantic values
            when returning from an action block. When this option is specified
            then <strong>bisonc++</strong> generates a warning for typed rules (non-terminals)
            whose action blocks do not provide an explicit <em>$$</em> return
            value.
<p>
<li> <strong>--no-lines</strong><br/> 
           Do not put <em>#line</em> preprocessor directives in the file containing
            the parser's <em>parse</em> function. By default the file containing
            the parser's <em>parse</em> function also contains <em>#line</em>
            preprocessor directives. This option allows the compiler and
            debuggers to associate errors with lines in your grammar
            specification file, rather than with the source file containing
            the <em>parse</em> function itself.
<p>
<li> <strong>--no-parse-member</strong><br/>
           Do not write the file containing the parser's predefined parser
            member functions, even if that file doesn't yet exist. By default
            the file containing the parser's <em>parse</em> member function is
            (re)written each time <strong>bisonc++</strong> is called. Note that this option
            should normally be avoided, as this file contains parsing
            tables which are altered whenever the grammar definition is
            modified. 
<p>
<li> <strong>--own-debug</strong><br/>
           Extensively displays the actions performed by <strong>bisonc++</strong>'s parser when
            it processes the grammar specification <strong>s</strong>. This implies the
            <em>--verbose</em> option.
<p>
<li> <strong>--own-tokens</strong> (<strong>-T</strong>)<br/>
           The tokens returned as well as the text matched when <strong>bisonc++</strong> reads
            its input files(s) are shown when this option is used.
<p>
This option does <em>not</em> result in the generated parsing function
            displaying returned tokens and matched text. If that is what you
            want, use the <em>--print-tokens</em> option.
<p>
<li> <strong>--parsefun-skeleton</strong>=<em>pathname</em> (<strong>-P</strong>)<br/>
           <em>Pathname</em> defines the path name of the file containing the
            parsing member function's skeleton. It defaults to the
            installation-defined default path name (e.g.,
            <em>/usr/share/bisonc++/</em> plus <em>bisonc++.cc</em>).
<p>
<li> <strong>--parsefun-source</strong>=<em>filename</em> (<strong>-p</strong>)<br/>
           <em>Filename</em> defines the name of the source file to contain the
            parser member function <em>parse</em>. Defaults to <em>parse.cc</em>.
<p>
<li> <strong>--polymorphic-skeleton</strong>=<em>pathame</em> (<strong>-M</strong>)<br/>
           <em>Pathname</em> defines the path name of the file containing the
            skeleton of the polymorphic template classes. It defaults to the
            installation-defined default path name (e.g.,
            <em>/usr/share/bisonc++/</em> plus <em>bisonc++polymorphic</em>).
<p>
<li> <strong>--polymorphic-inline-skeleton</strong>=<em>pathname</em> (<strong>-m</strong>)<br/>
           <em>Pathname</em> defines the path name of the file containing the
            skeleton of the inline implementations of the members of the
            polymorphic template classes.  It defaults to the
            installation-defined default path name (e.g.,
            <em>/usr/share/bisonc++/</em> plus <em>bisonc++polymorphic</em>).
<p>
<li> <strong>--print-tokens</strong> (<strong>-t</strong>)<br/>
           The generated parsing function implements a function <em>print__</em>
            displaying (on the standard output stream) the tokens returned by
            the parser's scanner as well as the corresponding matched
            text. This implementation is suppressed when the parsing function
            is generated without using this option. The member <em>print__</em>) is
            called from <em>Parser::print</em>, which is defined in-line in the the
            parser's class header. Calling <em>Parser::print__</em> can thus easily
            be controlled from <em>print</em>, using, e.g., a variable that set by
            the program using the parser generated by <strong>bisonc++</strong>.
<p>
This option does <em>not</em> show the tokens returned and text matched
            by <strong>bisonc++</strong> itself when it is reading its input <strong>s</strong>. If
            that is what you want, use the <em>--own-tokens</em> option.
<p>
<li> <a name="REQUIRED"></a> <strong>--required-tokens</strong>=<em>number</em><br/>
           Following a syntactic error, require at least <em>number</em>
            successfully processed tokens before another syntactic error can
            be reported. By default <em>number</em> is zero.
<p>
<li> <a name="SCANOPT"></a> <strong>--scanner</strong>=<em>pathname</em> (<strong>-s</strong>)<br/>
           <em>Pathname</em> defines the path name to the file defining the
            scanner's class interface (e.g., <em>"../scanner/scanner.h"</em>). When
            this option is used the parser's member <em>int lex()</em> is
            predefined as
           <pre>

    int Parser::lex()
    {
        return d_scanner.lex();
    }
                
</pre>

           and an object <em>Scanner d_scanner</em> is composed into the parser
            (but see also option <em>scanner-class-name</em>). The example shows
            the function that's called by default. When the <em>--flex</em> option
            (or <em>%flex</em> directive) is specified the function
            <em>d_scanner.yylex()</em> is called. Any other function to call can be
            specified using the <em>--scanner-token-function</em> option (or
            <em>%scanner-token-function</em> directive).
<p>
By default <strong>bisonc++</strong> surrounds <em>pathname</em> by double quotes (using,
            e.g., <em>#include "pathname"</em>).  When <em>pathname</em> is surrounded
            by pointed brackets <em>#include &lt;pathname&gt;</em> is included.
<p>
It is an error if this option is used and an already existing
            parser class header file does not include <em>`pathname'</em>.
<p>
<li> <strong>--scanner-class-name</strong> <em>scannerClassName</em> <br/> 
           Defines the name of the scanner class, declared by the <em>pathname</em>
            header file that is specified at the <em>scanner</em> option or 
            directive. By default the class name <em>Scanner</em> is used.
<p>
It is an error if this option is used and either the
            <em>scanner</em> option was not provided, or the parser class interface
            in an already existing parser class header file does not declare a
            scanner class <em>d_scanner</em> object.
<p>
<li> <strong>--scanner-debug</strong><br/> 
           Show de scanner's matched rules and returned tokens. This offers an
            extensive display of the rules and tokens matched and returned by
            <strong>bisonc++</strong>'s scanner, not of just the tokens and matched text received
            by <strong>bisonc++</strong>. If that is what you want use the <em>--own-tokens</em>
            option.
<p>
<li> <strong>--scanner-matched-text-function</strong>=<em>function-call</em><br/> 
           The scanner function returning the text that was matched at the
            last call of the scanner's token function. A complete function
            call expression should be provided (including a scanner object, if
            used). This option overrules the <em>d_scanner.matched()</em> call used
            by default when the <em>%scanner</em> directive is specified, and it
            overrules the <em>d_scanner.YYText()</em> call used when the <em>%flex</em>
            directive is provided. Example:
           <pre>

    --scanner-matched-text-function "myScanner.matchedText()"
                
</pre>

<p>
<li> <strong>--scanner-token-function</strong>=<em>function-call</em><br/> 
           The scanner function returning the next token, called from the
            parser's <em>lex</em> function. A complete function
            call expression should be provided (including a scanner object, if
            used). This option overrules the <em>d_scanner.lex()</em> call used
            by default when the <em>%scanner</em> directive is specified, and it
            overrules the <em>d_scanner.yylex()</em> call used when the <em>%flex</em>
            directive is provided. Example:
           <pre>

    --scanner-token-function "myScanner.nextToken()"
                
</pre>

<p>
It is an error if this option is used and the scanner token
            function is not called from the code in an already
            existing implementation header.
<p>
<li> <strong>--show-filenames</strong><br/> 
           Writes the names of the generated files to the standard error
            stream.
<p>
<li> <strong>--skeleton-directory</strong>=<em>directory</em> (<strong>-S</strong>)<br/> 
           Specifies the directory containing the skeleton files. This option
            can be overridden by the specific skeleton-specifying options
            (<em>-B -C, -H, -I, -M</em> and <em>-m</em>).
<p>
<li> <strong>--target-directory</strong>=<em>pathname</em> <br/> 
           <em>Pathname</em> defines the directory where generated files should be
            written.  By default this is the directory where <strong>bisonc++</strong> is
            called. 
<p>
<li> <strong>--thread-safe</strong><br/> 
           No static data are modified, making <strong>bisonc++</strong> thread-safe.
<p>
<li> <strong>--usage</strong><br/>
            Write basic usage information to the standard output stream and
            terminate. 
<p>
<li> <strong>--verbose</strong> (<strong>-V</strong>)<br/> 
           Write a file containing verbose descriptions of the parser states
            and what is done for each type of look-ahead token in that state.
            This file also describes all conflicts detected in the grammar,
            both those resolved by operator precedence and those that remain
            unresolved.  It is not created by default, but if requested the
            information is written on <em>&lt;grammar&gt;.output</em>, where
            <em>&lt;grammar&gt;</em> is the grammar specification file passed to <strong>bisonc++</strong>.
<p>
<li> <strong>--version</strong> (<strong>-v</strong>)<br/>
            Display <strong>bisonc++</strong>'s version number and terminate.
<p>
</ul>
<p>
<h2>4. DIRECTIVES</h2>
<p>
The following directives can be specified in the initial section of the
grammar specification file. When command-line options for directives exist,
they overrule the corresponding directives given in the grammar specification
file.  Directives affecting the class header or implementation header file are
ignored if these files already exist.
<p>
Directives accepting a `filename' do not accept path names, i.e., they
cannot contain directory separators (<em>/</em>); directives accepting a 'pathname'
may contain directory separators. A 'pathname' using blank characters should
be surrounded by double quotes.
<p>
Some directives may generate errors. This happens when a directive
conflicts with the contents of a file which <strong>bisonc++</strong> cannot modify (e.g., a
parser class header file exists, but doesn't define a name space, but a
<em>%namespace</em> directive was provided). 
<p>
To solve such errore the offending directive could be omitted, the existing
file could be removed, or the existing file could be hand-edited according to
the directive's specification.
<p>
<ul>
    <li> <strong>%baseclass-header</strong> <em>filename</em> <br/>
           <em>Filename</em> defines the name of the file to contain the parser's
            base class. This class defines, e.g., the parser's symbolic
            tokens. Defaults to the name of the parser class plus the suffix
            <em>base.h</em>. This directive is overruled by the
            <strong>--baseclass-header</strong> (<strong>-b</strong>) command-line option.
<p>
It is an error if this directive is used and an already
            existing parser class header file does not contain <em>#include
            "filename"</em>.
    <li> <strong>%baseclass-preinclude</strong> <em>pathname</em><br/>
           <em>Pathname</em> defines the path to the file preincluded by the
            parser's base-class header.  See the description of the
            <em>--baseclass-preinclude</em> option for details about this
            directive.  By default, <strong>bisonc++</strong> surrounds <em>header</em> by double
            quotes.  However, when <em>header</em> itself is surrounded by pointed
            brackets <em>#include &lt;header&gt;</em> is included.
    <li> <strong>%class-header</strong> <em>filename</em> <br/>
           <em>Filename</em> defines the name of the file to contain the parser
            class. Defaults to the name of the parser class plus the suffix
            <em>.h</em> This directive is overruled by the <strong>--class-header</strong>
            (<strong>-c</strong>) command-line option.
<p>
It is an error if this directive is used and an already
            existing implementation header file does not contain <em>#include
            "filename"</em>.
    <li> <strong>%class-name</strong> <em>parser-class-name</em> <br/>
           Declares the name of the parser class. It defines the name of the
            <strong>C++</strong> class that is generated. If no <em>%class-name</em> is
            specified the default class name <em>Parser</em> is used.
<p>
It is an error if this directive is used and an already
            existing parser-class header file does not define <em>class
            `className'</em> and/or if an already existing implementation header
            file does not define members of the class <em>`className'</em>.
    <li> <strong>%debug</strong> <br/> 
           Provide <em>parse</em> and its support functions with debugging code,
            showing the actual parsing process on the standard output
            stream. When included, the debugging output is active by default,
            but its activity may be controlled using the <em>setDebug(bool
            on-off)</em> member. No <em>#ifdef DEBUG</em> macros are used anymore. To
            remove existing debugging code re-run <strong>bisonc++</strong> without the
            <em>--debug</em> option or <em>%debug</em> declaration.
    <li> <strong>%error-verbose</strong> <br/>    
           This directive can be specified to dump the parser's state stack to
            the standard output stream when the parser encounters a syntactic
            error.  The stack dump shows on separate lines a stack index
            followed by the state stored at the indicated stack element. The
            first stack element is the stack's top element.
    <li> <strong>%expect</strong> <em>number</em> <br/>    
           This directive specifies the exact number of shift/reduce and
            reduce/reduce conflicts for which no warnings are to be
            generated. Details of the conflicts are reported in the verbose
            output file (e.g., <em>grammar.output</em>). If the number of actually
            encountered conflicts deviates from `<em>number</em>', then this
            directive is ignored.
    <li> <strong>%filenames</strong> <em>filename</em> <br/>
           <em>Filename</em> is a generic filename that is used for all header
            files generated by <strong>bisonc++</strong>.  Options defining specific filenames are
            also available (which then, in turn, overrule the name specified
            by this directive).  This directive is overruled by the
            <strong>--filenames</strong> (<strong>-f</strong>) command-line option.
    <li> <strong>%flex</strong> <br/>
           When provided, the scanner member returning the matched text is
            called as <em>d_scanner.YYText()</em>, and the scanner member returning
            the next lexical token is called as <em>d_scanner.yylex()</em>. This
            directive is only interpreted if the <em>%scanner</em> directive is
            also provided.
    <li> <strong>%implementation-header</strong> <em>filename</em> <br/>
           <em>Filename</em> defines the name of the file to contain the
            implementation header. It defaults to the name of the generated
            parser class plus the suffix <em>.ih</em>. <br/>
           The implementation header should contain all directives and
            declarations that are <em>only</em> used by the parser's member
            functions. It is the only header file that is included by the
            source file containing <em>parse</em>'s implementation. User defined
            implementation of other class members may use the same convention,
            thus concentrating all directives and declarations that are
            required for the compilation of other source files belonging to
            the parser class in one header file.<br/>
           This directive is overruled by the
            <strong>--implementation-header</strong> (<strong>-i</strong>) command-line option.
    <li> <strong>%include</strong> <em>pathname</em> <br/> 
           This directive is used to switch to <em>pathname</em> while processing a
            grammar specification. Unless <em>pathname</em> defines an absolute
            file-path, <em>pathname</em> is searched relative to the location of
            <strong>bisonc++</strong>'s main grammar specification file (i.e., the grammar file
            that was specified as <strong>bisonc++</strong>'s command-line option). This directive
            can be used to split long grammar specification files in shorter,
            meaningful units. After processing <em>pathname</em> processing
            continues beyond the <em>%include pathname</em> directive.
    <li> <strong>%left</strong> <em>terminal ...</em> <br/> 
           Defines the names of symbolic terminal tokens that must be treated
            as left-associative. I.e., in case of a shift/reduce conflict, a
            reduction is preferred over a shift.  Sequences of <em>%left,
            %nonassoc, %right</em> and <em>%token</em> directives may be used to define
            the precedence of operators. In expressions, the first used
            directive defines the tokens having the lowest precedence, the
            last used defines the tokens having the highest priority. See also
            <em>%token</em> below.
    <li> <strong>%locationstruct</strong> <em>struct-definition</em> <br/> 
           Defines the organization of the location-struct data type
            <em>LTYPE__</em>. This struct should be specified analogously to the
            way the parser's stacktype is defined using <em>%union</em> (see
            below). The location struct is named <em>LTYPE__</em>. By default (if
            neither <em>locationstruct</em> nor <em>LTYPE__</em> is specified) the
            standard location struct (see the next directive) is used:
    <li> <strong>%lsp-needed</strong> <br/>    
           This directive results in <strong>bisonc++</strong> generating a parser using 
            the standard location stack.  This stack's default type is:
           <pre>

    struct LTYPE__
    {
        int timestamp;
        int first_line;
        int first_column;
        int last_line;
        int last_column;
        char *text;
    };
           
</pre>

           <strong>Bisonc++</strong> does <em>not</em> provide the elements of the <em>LTYPE__</em> struct
            with values. Action blocks of production rules may refer to the
            location stack element associated with a production element using
            <em>@</em> variables, like <em>@1.timestamp, @3.text, @5</em>. The rule's
            location struct itself may be referred to as either <em>d_loc__</em> or
            <em>@@</em>.
    <li> <strong>%ltype typename</strong> <br/>    
           Specifies a user-defined token location type. 
           If <em>%ltype</em> is used, <em>typename</em> should be the name of an
            alternate (predefined) type (e.g., <em>size_t</em>). It should not be
            used if a <em>%locationstruct</em> specification is defined (see
            below). Within the parser class, this type is available as the
            type `<em>LTYPE__</em>'.  All text on the line following <em>%ltype</em>
            is used for the <em>typename</em> specification. It should therefore
            not contain comment or any other characters that are not part of
            the actual type definition.
    <li> <strong>%namespace</strong> <em>namespace</em> <br/>
           Define all of the code generated by <strong>bisonc++</strong> in the name space
            <em>namespace</em>. By default no name space is defined. If this
            directive is used the implementation header is provided with a
            commented out <em>using namespace</em> declaration for the specified
            name space. In addition, the parser and parser base class
            header files also use the specified namespace to define their
            include guard directives.
<p>
It is an error if this directive is used and an already
            existing parser-class header file and/or implementation header
            file does not define <em>namespace identifier</em>.
    <li> <strong>%negative-dollar-indices</strong> <br/>
           Do not generate warnings when zero- or negative dollar-indices are
            used in the grammar's action blocks. Zero or negative
            dollar-indices are commonly used to implement inherited
            attributes, and should normally be avoided. When used, they can be
            specified like <em>$-1</em>, or like <em>$&lt;type&gt;-1</em>, where <em>type</em> is
            empty; an <em>STYPE__</em> tag; or a field-name. However, note that in
            combination with the <em>%polymorphic</em> directive (see below) only
            the <em>$-i</em> format can be used.
    <li> <strong>%no-lines</strong> <br/> 
           By default <em>#line</em> preprocessor directives are inserted just
            before action statements in the file containing the parser's
            <em>parse</em> function. These directives are suppressed by the
            <em>%no-lines</em> directive.
    <li> <strong>%nonassoc</strong> <em>terminal ...</em> <br/> Defines the names of symbolic
            terminal tokens that should be treated as non-associative. I.e.,
            in case of a shift/reduce conflict, a reduction is preferred over
            a shift.  Sequences of <em>%left, %nonassoc, %right</em> and <em>%token</em>
            directives may be used to define the precedence of operators.  In
            expressions, the first used directive defines the tokens having
            the lowest precedence, the last used defines the tokens having the
            highest priority. See also <em>%token</em> below.
    <li> <strong>%parsefun-source</strong> <em>filename</em> <br/>
           <em>Filename</em> defines the name of the file to contain the parser
            member function <em>parse</em>. Defaults to <em>parse.cc</em>.  This
            directive is overruled by the <strong>--parse-source</strong> (<strong>-p</strong>)
            command-line option.
    <li> <strong>%polymorphic</strong> <em>polymorphic-specification(s)</em><br/>
           Bison's traditional way of handling multiple semantic values is to
            use a <em>%union</em> specification (see below). Although <em>%union</em> is
            supported by <strong>bisonc++</strong>, a polymorphic semantic value class is
            preferred due to its improved type safety.
<p>
The <em>%polymorphic</em> directive defines a polymorphic semantic
            value class and can be used instead of a <em>%union</em>
            specification. Refer to section <strong>POLYMORPHIC SEMANTIC VALUES</strong>
            below or to <strong>bisonc++</strong>'s user manual for a detailed description of the
            specification, characteristics, and use of polymorphic semantic
            values.
    <li> <strong>%prec</strong> <em>token</em> <br/> 
           Overrules the defined precendence of an operator for a particular
            grammatical rule. A well known application of <em>%prec</em> is:
                <pre>

    expression:
        '-' expression %prec UMINUS
        {
            ...
        }
                
</pre>

            Here, the default priority and precedence of the `<em>-</em>' token as
            the subtraction operator is overruled by the precedence and
            priority of the <em>UMINUS</em> token, which is commonly defined as 
                <pre>

    %right UMINUS
                
</pre>

            (see below) following, e.g., the <em>'*'</em> and <em>'/'</em> operators.
    <li> <strong>%print-tokens</strong> <br/>
           The <em>print</em> directive provides an implementation of the Parser
            class's <em>print__</em> function displaying the current token value
            and the text matched by the lexical scanner as received by the
            generated <em>parse</em> function.
    <li> <strong>%required-tokens</strong> <em>number</em><br/>
           Following a syntactic error, require at least <em>number</em>
            successfully processed tokens before another syntactic error can
            be reported. By default <em>number</em> is zero.
    <li> <strong>%right</strong> <em>terminal ...</em> <br/> 
           Defines the names of symbolic terminal tokens that should be
            treated as right-associative. I.e., in case of a shift/reduce
            conflict, a shift is preferred over a reduction.  Sequences of
            <em>%left, %nonassoc, %right</em> and <em>%token</em> directives may be used
            to define the precedence of operators.  In expressions, the first
            used directive defines the tokens having the lowest precedence,
            the last used defines the tokens having the highest priority. See
            also <em>%token</em> below.
    <li> <strong>%scanner</strong> <em>pathname</em><br/>
           Use <em>pathname</em> as the path name to the file pre-included in the
            parser's class header. See the description of the <em>--scanner</em>
            option for details about this directive.  Similar to the convention
            adopted for this argument, <em>pathname</em> by default is surrounded
            by double quotes.  However, when the argument is surrounded by
            pointed brackets <em>#include &lt;pathname&gt;</em> is included. This
            directive results in the definition of a composed <em>Scanner
            d_scanner</em> data member into the generated parser, and in the
            definition of a <em>int lex()</em> member, returning
            <em>d_scanner.lex()</em>.
<p>
By specifying the <em>%flex</em> directive the function
            <em>d_scanner.yylex()</em> is called. Any other function to call can be
            specified using the <em>--scanner-token-function</em> option (or
            <em>%scanner-token-function</em> directive).
<p>
It is an error if this directive is used and an already
            existing parser class header file does not include <em>`pathname'</em>.
    <li> <strong>%scanner-class-name</strong> <em>scannerClassName</em> <br/> 
           Defines the name of the scanner class, declared by the <em>pathname</em>
            header file that is specified at the <em>scanner</em> option or 
            directive. By default the class name <em>Scanner</em> is used.
<p>
It is an error if this directive is used and either the
            <em>scanner</em> directive was not provided, or the parser class
            interface in an already existing parser class header file does not
            declare a scanner class <em>d_scanner</em> object.
    <li> <strong>%scanner-matched-text-function</strong> <em>function-call</em> <br/> 
           The scanner function returning the text that was matched by the
            lexical scanner after its token function (see below) has
            returned. A complete function call expression should be provided
            (including a scanner object, if used).  Example: 
                <pre>

    %scanner-matched-text-function myScanner.matchedText()
                
</pre>

           By specifying the <em>%flex</em> directive the function
            <em>d_scanner.YYText()</em> is called.
<p>
If the function call contains white space
            <em>scanner-token-function</em> should be surrounded by double quotes.
    <li> <strong>%scanner-token-function</strong> <em>function-call</em> <br/> 
           The scanner function returning the next token, called from the
            generated parser's <em>lex</em> function. A complete function
            call expression should be provided (including a scanner object, if
            used). Example: 
            <pre>

    %scanner-token-function d_scanner.lex()
                
</pre>

           If the function call contains white space
            <em>scanner-token-function</em> should be surrounded by double quotes.
<p>
It is an error if this directive is used and the scanner token
            function is not called from the code in an already
            existing implementation header.
    <li> <strong>%start</strong> <em>non-terminal</em> <br/>    
            The non-terminal <em>non-terminal</em> should be used as the grammar's 
            start-symbol. If omitted, the first grammatical rule is used
            as the grammar's starting rule. All syntactically correct
            sentences must be derivable from this starting rule.
    <li> <strong>%stype typename</strong> <br/> 
           The type of the semantic value of non-terminal tokens.  By default
            it is <em>int</em>. <em>%stype, %union,</em> and <em>%polymorphic</em> are
            mutually exclusive directives.   
<p>
Within the parser class, the semantic value type is available as
            the type `<em>STYPE__</em>'. All text on the line following <em>%stype</em>
            is used for the <em>typename</em> specification. It should therefore
            not contain comment or any other characters that are not part of
            the actual type definition.
    <li> <strong>%target-directory pathname</strong> <br/> 
           <em>Pathname</em> defines the directory where generated files should be
            written.  By default this is the directory where <strong>bisonc++</strong> is
            called. This directive is overruled by the <em>--target-directory</em>
            command-line option.
    <li> <strong>%token</strong> <em>terminal ...</em> <br/>    
           Defines the names of symbolic terminal tokens.  Sequences of
            <em>%left, %nonassoc, %right</em> and <em>%token</em> directives may be used
            to define the precedence of operators. In expressions, the first
            used directive defines the tokens having the lowest precedence,
            the last used defines the tokens having the highest priority. See
            also <em>%token</em> below.<br/>
           <strong>NOTE:</strong> Symbolic tokens are defined as <em>enum</em>-values in the
            parser's base class. The names of symbolic tokens may not be equal
            to the names of the members and types defined by <strong>bisonc++</strong> itself (see
            the next sections). This requirement is <em>not</em> enforced by <strong>bisonc++</strong>,
            but compilation errors may result if this requirement is violated.
    <li> <strong>%type</strong> <em>&lt;type&gt; non-terminal ...</em> <br/>    
           In combination with <em>%polymorphic</em> or <em>%union</em>: associate the
            semantic value of a non-terminal symbol with a polymorphic
            semantic value tag or union field defined by these directives.
    <li> <strong>%union</strong> <em>union-definition</em> <br/>    
           Acts identically to the identically named <strong>bison</strong> and <strong>bison++</strong>
            declaration.  <strong>Bisonc++</strong> generates a union, named <em>STYPE__</em>, as its
            semantic type.  
    <li> <strong>%weak-tags</strong> <br/>
           This directive is ignored unless the <em>%polymorphic</em>
            directive was specified. It results in the declaration of <em>enum
            Tag__</em> rather than <em>enum class Tag__</em>. When in doubt, don't use
            this directive.
    </ul>
<p>
<h2>5. POLYMORPHIC SEMANTIC VALUES</h2>
<p>
The <em>%polymorphic</em> directive allows <strong>bisonc++</strong> to generate a parser using
polymorphic semantic values. The various semantic values are specified as
pairs, consisting of <em>tags</em> (which are <strong>C++</strong> identifiers), and <strong>C++</strong>
type names. Tags and type names are separated by colons. Multiple tag and type
name combinations are separated by semicolons, and an optional semicolon ends
the final tag/type specification.
<p>
Here is an example, defining three semantic values: an <em>int</em>, a
<em>std::string</em> and a <em>std::vector&lt;double&gt;</em>:
        <pre>

    %polymorphic INT: int; STRING: std::string; 
                 VECT: std::vector&lt;double&gt;
        
</pre>

    The identifier to the left of the colon is called the <em>tag-identifier</em>
(or simply <em>tag</em>), and the type name to the right of the colon is called the
<em>type-name</em>. Since <strong>bisonc++</strong> version 4.12.00 the types no longer have to
offer  offer default constructors, but if no default constructor is available
then the option <em>--no-default-action-return</em> is required.
<p>
When polymorphic type-names refer to types not yet declared by the
parser's base class header, then these types must be declared in a header file
whose location is specified through the <em>%baseclass-preinclude</em> directive.
<p>
    The <em>%type</em> directive is used to associate (non-)terminals with semantic
value types.
<p>
Non-terminals may be associated with polymorphic semantic
values using <em>%type</em> directives. E.g., after:
        <pre>

    %polymorphic INT: int; TEXT: std::string
    %type &lt;INT&gt; expr
        
</pre>

    the <em>expr</em> non-terminal returns <em>int</em> semantic values. In this case,
a rule like:
        <pre>

    expr:
        expr '+' expr
        {
            $$ = $1 + $3;
        }
        
</pre>

    automatically associates $$, $1 and $3 with <em>int</em> values. Here $$ is an
lvalue (representing the semantic value associated with the <em>expr:</em> rule),
while $1 and $3 represent, because of the <em>%type</em> specification, <em>int</em>
semantic values which are associated with, resp., the first and second
<em>expr</em> non-terminal in the production rule <em>expr '+' expr</em>.
<p>
When negative dollar indices (like $-1) are used, pre-defined associations
between non-terminals and semantic types are ignored.  With positive indices
or in combination with the production rule's return value <em>$$</em>, however,
semantic value types can explicitly be specified using the common `$&lt;type&gt;$'
or `$&lt;type&gt;1' syntax. (In this and following examples index number 1 represents
any valid positive index; -1 represents any valid negative index).
<p>
The type-overruling syntax does not allow blanks to be used (so $&lt;INT&gt;$ is OK,
$&lt; INT &gt;$ isn't).
<p>
Various combinations of type-associations and type specifications may be
encountered:
<ul>
<li> $-1: <em>%type</em> associations are ignored, and the semantic value type
    <em>STYPE__</em> is used instead. A warning is issued unless the
    <em>%negative-dollar-indices</em> directive was specified.
<li> $&lt;tag&gt;-1: <em>error</em>: <em>&lt;tag&gt;</em> specifications are not allowed for
    negative dollar indices. 
</ul>
<p>

<div style="text-align: center">
<table>

<td colspan=1><hr/></td>


<tr>
<td> <div style="text-align: center"><table>

    
    
<tr>
<td colspan=5 style="text-align: center">$$ or $1 specifications</td>
 
</tr>

    <td colspan=5><hr/></td>

    
<tr>
<td> %type&lt;TAG&gt;</td><td> </td><td> $&lt;tag&gt;</td><td> </td><td> action:</td>
 
</tr>

    <td colspan=5><hr/></td>

    
<tr>
<td> absent</td><td> </td><td> no &lt;tag&gt;</td><td> </td><td> STYPE__ is used</td>
 
</tr>

                        <tr><td colspan=2</td><td colspan=3><hr/></td></tr>

                    
<tr>
<td> </td><td> </td><td> $&lt;id&gt;</td><td> </td><td> tag-override</td>
 
</tr>

                        <tr><td colspan=2</td><td colspan=3><hr/></td></tr>

                    
<tr>
<td> </td><td> </td><td> $&lt;&gt;</td><td> </td><td> STYPE__ is used</td>
 
</tr>

                        <tr><td colspan=2</td><td colspan=3><hr/></td></tr>

                    
<tr>
<td> </td><td> </td><td> $&lt;STYPE__&gt;</td><td> </td><td> STYPE__ is used</td>
 
</tr>

    <td colspan=5><hr/></td>

    
<tr>
<td> STYPE__</td><td> </td><td> no &lt;tag&gt;</td><td> </td><td> STYPE__ is used</td>
 
</tr>

                        <tr><td colspan=2</td><td colspan=3><hr/></td></tr>

                    
<tr>
<td> </td><td> </td><td> $&lt;id&gt;</td><td> </td><td> tag-override</td>
 
</tr>

                        <tr><td colspan=2</td><td colspan=3><hr/></td></tr>

                    
<tr>
<td> </td><td> </td><td> $&lt;&gt;</td><td> </td><td> STYPE__ is used</td>
 
</tr>

                        <tr><td colspan=2</td><td colspan=3><hr/></td></tr>

                    
<tr>
<td> </td><td> </td><td> $&lt;STYPE__&gt;</td><td> </td><td> STYPE__ is used</td>
 
</tr>

    <td colspan=5><hr/></td>

    
<tr>
<td> (existing) tag</td><td> </td><td> no &lt;tag&gt;</td><td> </td><td> auto-tag</td>
 
</tr>

                        <tr><td colspan=2</td><td colspan=3><hr/></td></tr>

                    
<tr>
<td> </td><td> </td><td> $&lt;id&gt;</td><td> </td><td> tag-override</td>
 
</tr>

                        <tr><td colspan=2</td><td colspan=3><hr/></td></tr>

                    
<tr>
<td> </td><td> </td><td> $&lt;&gt;</td><td> </td><td> STYPE__ is used</td>
 
</tr>

                        <tr><td colspan=2</td><td colspan=3><hr/></td></tr>

                    
<tr>
<td> </td><td> </td><td> $&lt;STYPE__&gt;</td><td> </td><td> STYPE__ is used</td>
 
</tr>

    <td colspan=5><hr/></td>

    
<tr>
<td> (undefined) tag</td><td> </td><td> no &lt;tag&gt;</td><td> </td><td> tag-error</td>
 
</tr>

                        <tr><td colspan=2</td><td colspan=3><hr/></td></tr>

                    
<tr>
<td> </td><td> </td><td> $&lt;id&gt;</td><td> </td><td> tag-override</td>
 
</tr>

                        <tr><td colspan=2</td><td colspan=3><hr/></td></tr>

                    
<tr>
<td> </td><td> </td><td> $&lt;&gt;</td><td> </td><td> STYPE__ is used</td>
 
</tr>

                        <tr><td colspan=2</td><td colspan=3><hr/></td></tr>

                    
<tr>
<td> </td><td> </td><td> $&lt;STYPE__&gt;</td><td> </td><td> STYPE__ is used</td>
 
</tr>

    <td colspan=5><hr/></td>


</table>
</div></td>
 
</tr>


</table></div>
<ul>
     auto-tag: $$ and $1 represent, respectively, <em>$$.get&lt;tag&gt;()</em> and
            <em>$1.get&lt;tag&gt;()</em>;
<p>
 tag-error: <em>error:</em> tag undefined;
<p>
 tag-override: if <em>id</em> is a defined tag, then $&lt;tag&gt;$ and $&lt;tag&gt;1
            represent the tag's type. Otherwise: <em>error</em> (using undefined
            tag <em>id</em>).
</ul>
<p>
<td colspan=0><hr/></td>

<p>
When using `$$.' or `$1.' default tags are ignored. A warning is issued
that the default tag is ignored. This syntax allows members of the semantic
value type (<em>STYPE__</em>) to be called explicitly. The default tag is only
ignored if there are no additional characters (e.g., blanks, closing
parentheses) between the dollar-expressions and the member selector operator
(e.g., no tags are used with $1.member(), but tags are used with
<em>($1).member()</em>). In fact, notations like <em>($$), ($1)</em>, etc. are synonym
to using <em>$$.get&lt;Tag__::TYPE&gt;(), $1.get&lt;Tag__::TYPE&gt;()</em>
<p>
The opposite, overriding default tag associations, is
accomplished using constructions like $&lt;STYPE__&gt;$ and $&lt;STYPE__&gt;1.
<p>
When negative dollar indices are used, the appropriate tag must explicitly be
specified. The next example shows how this is realized in the grammar
specification file itself:
        <pre>

    %polymorphic INT: int
    %type &lt;INT&gt; ident
    %%
    
    type:
        ident arg
    ;
    
    arg:
        {
            call($-1.get&lt;Tag__::INT&gt;());
        }
    ;
        
</pre>

    In this example <em>call</em> may define an <em>int</em> or <em>int &amp;</em> parameter. 
<p>
It is also possible to delegate specification of the semantic value to the
function <em>call</em> itself, as shown next:
        <pre>

    %polymorphic INT: int
    %type &lt;INT&gt; ident
    %%
    
    type:
        ident arg
    ;
    
    arg:
        {
            call($-1);
        }
    ;
        
</pre>

    Here, the function <em>call</em> could be implemented like this:
        <pre>

    void call(STYPE__ &amp;st)
    {
        st.get&lt;Tag__::INT&gt;() = 5;
    }
        
</pre>

<p>
Semantic values may also directly be associated with terminal tokens. In that
case it is the lexical scanner's responsibility to assign a properly typed
value to the parser's <em>STYPE__ d_val__</em> data member. When the lexical
scanner receives a pointer to the parser's <em>d_val__</em> data member (using,
e.g., a member <em>setSval(STYPE__ *dval)</em>)
    , 
then the lecical scanner must use <em>tagged assignment</em> as shown in the above
example to reach the different polymorphic types. The lexical scanner, having
defined a <em>Parser::STYPE__ *d_val</em> data member could then use statements
like
        <pre>

    d_val.get&lt;Tag__::INT&gt;() = stoi(matched());
        
</pre>

    to assign an <em>int</em> value to the parser's semantic value, which is then
immediately available when the lexical scanner's <em>lex</em> function
returns. Note, however that this also adds intelligence about the meaning of a
<em>Parser::INT</em> token to the scanner. It can be argued that this knowledge
belongs to the parser, and that the scanner should merely recognize regular
expressions and return tokens and their corresponding matched text.
<p>
The <em>%polymorphic</em> directive adds the following definitions and
declarations to the generated base class header and parser source
file (if the <em>%namespace</em> directive was used then all declared/defined
elements are placed inside the name space that is specified by the
<em>%namespace</em> directive):
    <ul>
    <li> An additional header is included in the parser's base class
header: 
            <pre>

    #include &lt;memory&gt;
            
</pre>

    <li> All semantic value type identifiers are collected in a strongly typed
`<em>Tag__</em>' enumeration. E.g.,
        <pre>

    enum class Tag__
    {
        INT,
        STRING,
        VECT
    };
        
</pre>

    <li> The name space <em>Meta__</em> contains almost all of the code
implementing polymorphic values.
    </ul>
<p>
The name space <em>Meta__</em> contains the following elements:
    <ul>
    <li> A polymorphic base class <em>Base</em>. This class is normally not
     explicitly referred to by user-defined code. Refer to by <strong>bisonc++</strong>'s
     user manual for a detailed description of this class.
<p>
<li> For each of the tag-identifiers specified with the <em>%polymorphic</em>
     directive a class template <em>Semantic&lt;Tag__&gt;</em> is defined, containing a
     data element of the type-name matching the <em>Tag__</em> for which
     <em>Semantic&lt;Tag__&gt;</em> was derived. 
<p>
The <em>Semantic&lt;Tag__&gt;</em> classes are normally not explicitly referred to by
     user-defined code. Refer to by <strong>bisonc++</strong>'s user manual for a detailed
     description of these classes.
<p>
<li> A class <em>SType</em>, derived from <em>std::shared_ptr&lt;Base&gt;</em>. This class
     becomes the parser's semantic value type, offering the following
     members:<br/>
<p>
<em>Constructors:</em> default, copy and move constructors;<br/>
<p>
<em>Assignment operators:</em> copy and move assignment operators declaring 
            <em>SType</em> or any of the <em>%polymorphic</em> type-names as their
            right-hand side operands;<br/>
<p>
<em>Tag__ tag() const</em>, returning <em>Semantic&lt;Tag__&gt;</em>'s <em>Tag__</em>
             value;<br/>
<p>
<em>DataType &amp;get&lt;Tag__&gt;()</em> returns a reference to the semantic value
             stored inside <em>Semantic&lt;Tag__&gt;</em>.
<p>
This member checks for 0-pointers and for <em>Tag__</em> mismatches
             between the requested and actual <em>Tag__</em>, in that case
             replacing the current <em>Semantic</em> object pointed to by a new
             <em>Semantic&lt;Tag__&gt;</em> object of the requested <em>Tag__</em>.
<p>
<em>DataType &amp;data&lt;Tag__&gt;()</em> returns a reference to the semantic value
             stored inside <em>Semantic&lt;Tag__&gt;</em>.
<p>
This is a (partially) <em>unchecking</em> variant of the corresponing
             <em>get</em> member, resulting in a <em>Segfault</em> if used when the
             <em>shared_ptr</em> holds a 0-pointer, compilation may fail in case of
             a mismatch between the requested and actual <em>Tag__</em>.
    </ul>
<p>
Since <strong>bisonc++</strong> declares <em>typedef Meta__::SType STYPE__</em>, polymorphic
semantic values can be used without referring to the name space <em>Meta__</em>. 
<p>
<h2>6. PUBLIC MEMBERS AND -TYPES</h2>
<p>

    The following public members and types are available to users of the
parser classes generated by <strong>bisonc++</strong> (parser class-name prefixes (e.g.,
<em>Parser::</em>) prefixes are silently implied):
    <ul>
    <li> <strong>LTYPE__</strong>:<br/> 
           The parser's location type (user-definable). Available only when
            either <em>%lsp-needed, %ltype</em> or <em>%locationstruct</em> has been
            declared. 
    <li> <strong>STYPE__</strong>:<br/>
            The parser's stack-type (user-definable), defaults to <strong>int</strong>.
    <li> <strong>Tokens__</strong>:<br/>
           The enumeration type of all the symbolic tokens defined in the
            grammar file (i.e., <strong>bisonc++</strong>'s input file). The scanner should be
            prepared to return these symbolic tokens. Note that, since the
            symbolic tokens are defined in the parser's class and not in the
            scanner's class, the lexical scanner must prefix the parser's
            class name to the symbolic token names when they are
            returned. E.g., <em>return Parser::IDENT</em> should be used rather
            than <em>return IDENT</em>.
    <li> <strong>int parse()</strong>:<br/>
           The parser's parsing member function. It returns 0 when parsing was
            successfully completed; 1 if errors were encountered while parsing
            the input.
    <li> <strong>void setDebug(bool mode)</strong>:<br/>
       This member can be used to activate or deactivate the debug-code
        compiled into the parsing function. It is always defined but is only
        operational if the <em>%debug</em> directive or <em>--debug</em> option was
        specified. When debugging code has been compiled into the parsing
        function, it is <em>not</em> active by default. To activate the debugging
        code, use <em>setDebug(true)</em>.
<p>
This member can be used to activate or deactivate the debug-code
        compiled into the parsing function. It is available but has no
        effect if no debug code has been compiled into the parsing
        function. When debugging code has been compiled into the parsing
        function, it is active by default, but debug-code is suppressed by
        calling <em>setDebug(false)</em>.
    </ul>
<p>
When the <em>%polymorphic</em> directive is used:
    <ul>
    <li> <strong>Meta__</strong>:<br/>
           Templates and classes that are required for implementing the
            polymorphic semantic values are all declared in the <em>Meta__</em>
            namespace. The <em>Meta__</em> namespace itself is nested under the
            namespace that may have been declared by the <em>%namespace</em>
            directive.
<p>
<li> <strong>Tag__</strong>:<br/>
           The (strongly typed) <em>enum class Tag__</em> contains all the
            tag-identifiers specified by the <em>%polymorphic</em> directive. It is
            declared outside of the Parser's class, but within the namespace
            that may have been declared by the <em>%namespace</em> directive.
    </ul>
<p>
<h2>7. PRIVATE ENUMS AND -TYPES</h2>
<p>
    The following enumerations and types can be used by members of parser
classes generated by <strong>bisonc++</strong>. They are actually protected members inherited from
the parser's base class.
    <ul>
    <li> <strong>Base::ErrorRecovery__</strong>:<br/>
        This enumeration defines two values:
        <pre>

    DEFAULT_RECOVERY_MODE__,
    UNEXPECTED_TOKEN__
        
</pre>

       The <em>DEFAULT_RECOVERY_MODE__</em> terminates the parsing process. The
        non-default recovery procedure is available once an <em>error</em> token is
        used in a production rule. When the parsing process throws
        <em>UNEXPECTED_TOKEN__</em> the recovery procedure is started (i.e., it is
        started whenever a syntactic error is encountered or 
        <em>ERROR</em><em>()</em> is called). 
<p>
The recovery procedure consists of (1) looking for the first state on
        the state-stack having an error-production, followed by (2) handling
        all state transitions that are possible without retrieving a terminal
        token. Then, in the state requiring a terminal token and starting with
        the initial unexpected token (3) all subsequent terminal tokens are
        ignored until a token is retrieved which is a continuation token in
        that state. 
<p>
If the error recovery procedure fails (i.e., if no acceptable token is
        ever encountered) error recovery falls back to the default recovery
        mode (i.e., the parsing process is terminated).
<p>
<li> <strong>Base::Return__</strong>:<br/>
        This enumeration defines two values:
        <pre>

    PARSE_ACCEPT = 0,
    PARSE_ABORT = 1
        
</pre>

        (which are of course the <em>parse</em> function's return values).
     </ul>
<p>
<h2>8. PRIVATE MEMBER FUNCTIONS</h2>
<p>
    The following members can be used by members of parser classes generated
by <strong>bisonc++</strong>. When prefixed by <em>Base::</em> they are actually protected members
inherited from the parser's base class.  Members for which the phrase ``Used
internally'' is used should not be called by user-defined code.
    <ul>
    <li> <strong>Base::ParserBase()</strong>:<br/>
       Used internally.
    <li> <strong>void Base::ABORT() const throw(Return__)</strong>:<br/>
       This member can be called from any member function (called from any of
        the parser's action blocks) to indicate a failure while parsing thus
        terminating the parsing function with an error value 1. Note that this
        offers a marked extension and improvement of the macro <em>YYABORT</em>
        defined by <strong>bison++</strong> in that <em>YYABORT</em> could not be called from
        outside of the parsing member function.
    <li> <strong>void Base::ACCEPT() const throw(Return__)</strong>:<br/>
       This member can be called from any member function (called from any of
        the parser's action blocks) to indicate successful parsing and thus
        terminating the parsing function. Note that this offers a marked
        extension and improvement of the macro <em>YYACCEPT</em> defined by
        <strong>bison++</strong> in that <em>YYACCEPT</em> could not be called from outside of
        the parsing member function.
    <li> <strong>void Base::clearin()</strong>:<br/>
       This member replaces <strong>bison</strong>(++)'s macro <em>yyclearin</em> and causes
        <strong>bisonc++</strong> to request another token from its <em>lex()</em> member,
        even if the current token has not yet been processed. It is a useful
        member when the parser should be reset to its initial state, e.g.,
        between successive calls of <em>parse</em>. In this situation the scanner
        must probably be reloaded with new information as well.
    <li> <strong>bool Base::debug() const</strong>:<br/>
       This member returns the current value of the debug variable.
    <li> <strong>void Base::ERROR() const throw(ErrorRecovery__)</strong>:<br/>
       This member can be called from any member function (called from any of
        the parser's action blocks) to generate an error, and results in the
        parser executing its error recovery code. Note that this offers a
        marked extension and improvement of the macro <em>YYERROR</em> defined by
        <strong>bison++</strong> in that <em>YYERROR</em> could not be called from outside of
        the parsing member function.
    <li> <strong>void error(char const *msg)</strong>:<br/>
      By default implemented inline in the <em>parser.ih</em> internal header file,
       it writes a simple message to the standard error stream. It is called
       when a syntactic error is encountered, and its default implementation
       may safely be altered.
    <li> <strong>void errorRecovery__()</strong>:<br/>
       Used internally.
    <li> <strong>void Base::errorVerbose__()</strong>:<br/>
       Used internally.
    <li> <strong>void exceptionHandler__(std::exception const &amp;exc)</strong>:<br/>
       This member's default implementation is provided inline in the
        <em>parser.ih</em> internal header file. It consists of a mere <em>throw</em>
        statement, rethrowing a caught exception.
<p>
The <em>parse</em> member function's body essentially consists of a
        <em>while</em> statement, in which the next token is obtained via the
        parser's <em>lex</em> member. This token is then processed according to the
        current state of the parsing process. This may result in executing
        actions over which the parsing process has no control and which may
        result in exceptions being thrown.
<p>
Such exceptions do not necessarily have to terminate the parsing
        process: they could be thrown by code, linked to the parser, that
        simply checks for semantic errors (like divisions by zero) 
        throwing exceptions if such errors are observed.
<p>
The member <em>exceptionHandler__</em> receives and may handle such
        exceptions without necessarily ending the parsing process. It receives
        any <em>std::exception</em> thrown by the parser's actions, as though the
        action block itself was surrounded by a <em>try ... catch</em> statement.
        It is of course still possible to use an explicit <em>try ... catch</em>
        statement within action blocks. However, <em>exceptionHandler__</em> can
        be used to factor out code that is common to various action blocks.
<p>
The next example shows an explicit implementation of
        <em>exceptionHandler__</em>: any <em>std::exception</em> thrown by the parser's
        action blocks is caught, showing the exception's message, and
        increasing the parser's error count. After this parsing continues as
        if no exception had been thrown:
        <pre>

    void Parser::exceptionHandler__(std::exception const &amp;exc)
    {
        std::cout &lt;&lt; exc.what() &lt;&lt; '\n';
        ++d_nErrors__;
    }
            
</pre>

<p>
<strong>Note:</strong> Parser-class header files (e.g., Parser.h) and parser-class
    internal header files (e.g., Parser.ih) generated with <strong>bisonc++</strong> &lt; 4.02.00
    require two hand-modifications when using <strong>bisonc++</strong> &gt;= 4.02.00:
<p>
In Parser.h, just below the declaration 
        <pre>

    void print__();
        
</pre>

    add:
        <pre>

    void exceptionHandler__(std::exception const &amp;exc);
        
</pre>

<p>
In Parser.ih, assuming the name of the generated class is `Parser', add the
    following member definition (if a namespace is used: within the
    namespace's scope):
        <pre>

    inline void Parser::exceptionHandler__(std::exception const &amp;exc)
    {
        throw;  // re-implement to handle exceptions thrown by actions
    }
        
</pre>

    <li> <strong>void executeAction(int)</strong>:<br/>
       Used internally.
    <li> <strong>int lex()</strong>:<br/>
      By default implemented inline in the <em>parser.ih</em> internal header file,
       it can be pre-implemented by <strong>bisonc++</strong> using the <em>scanner</em> option or
       directive (see above); alternatively it <em>must</em> be implemented by the
       programmer. It interfaces to the lexical scanner, and should return the
       next token produced by the lexical scanner, either as a plain character
       or as one of the symbolic tokens defined in the <em>Parser::Tokens__</em>
       enumeration. Zero or negative token values are interpreted as `end of
       input'.
    <li> <strong>int lookup(bool)</strong>:<br/>
       Used internally.
    <li> <strong>void nextToken()</strong>:<br/>
       Used internally.
    <li> <strong>void Base::pop__()</strong>:<br/>
       Used internally.
    <li> <strong>void Base::popToken__()</strong>:<br/>
       Used internally.
    <li> <strong>void print__()()</strong>:<br/>
       Used internally.
    <li> <strong>void print()</strong>:<br/>
      By default implemented inline in the <em>parser.ih</em> internal header file,
       this member calls <em>print__</em> to display the last received token and
       corrseponding matched text. The <em>print__</em> member is only implemented
       if the <em>--print-tokens</em> option or <em>%print-tokens</em> directive was
       used when the parsing function was generated. Calling <em>print__</em> from
       <em>print</em> is unconditional, but can easily be controlled by the using
       program, by defining, e.g., a command-line option.
    <li> <strong>void Base::push__()</strong>:<br/>
       Used internally.
    <li> <strong>void Base::pushToken__()</strong>:<br/>
       Used internally.
    <li> <strong>void Base::reduce__()</strong>:<br/>
       Used internally.
    <li> <strong>void Base::symbol__()</strong>:<br/>
       Used internally.
    <li> <strong>void Base::top__()</strong>:<br/>
       Used internally.
    </ul>
<p>
<h2>9. PRIVATE DATA MEMBERS</h2>
<p>
The following data members can be used by members of parser classes
generated by <strong>bisonc++</strong>. All data members are actually protected
members inherited from the parser's base class. 
    <ul>
    <li> <strong>size_t d_acceptedTokens__</strong>:<br/>
       Counts the number of accepted tokens since the start of the <em>parse()</em>
        function or since the last detected syntactic error. It is initialized
        to <em>d_requiredTokens__</em> to allow an early error to be detected as
        well. 
    <li> <strong>bool d_debug__</strong>:<br/>
       When the <em>debug</em> option has been specified, this variable (<em>true</em>
        by default) determines whether debug information is actually
        displayed.
    <li> <strong>LTYPE__ d_loc__</strong>:<br/>
       The location type value associated with a terminal token. It can be
        used by, e.g., lexical scanners to pass location information of a
        matched token to the parser in parallel with a returned token. It is
        available only when <em>%lsp-needed, %ltype</em> or <em>%locationstruct</em> has
        been defined. <br/>
       Lexical scanners may be offered the facility to assign a value to this
        variable in parallel with a returned token. In order to allow a
        scanner access to <em>d_loc__</em>, <em>d_loc__</em>'s address should be passed
        to the scanner. This can be realized, for example, by defining a
        member <em>void setLoc(STYPE__ *)</em> in the lexical scanner, which is
        then called from the parser's constructor as follows:
       <pre>

            d_scanner.setSLoc(&amp;d_loc__);
       
</pre>

       Subsequently, the lexical scanner may assign a value to the parser's
        <em>d_loc__</em> variable through the pointer to <em>d_loc__</em> stored inside
        the lexical scanner.
    <li> <strong>LTYPE__ d_lsp__</strong>:<br/>
       The location stack pointer.
        Do not modify.
    <li> <strong>size_t d_nErrors__</strong>:<br/>
       The number of errors counted by <em>parse</em>. It is initialized by the
        parser's base class initializer, and is updated while <em>parse</em>
        executes. When <em>parse</em> has returned it contains the total number
        of errors counted by <em>parse</em>. Errors are not counted if suppressed
        (i.e., if <em>d_acceptedTokens__</em> is less than <em>d_requiredTokens__</em>).
    <li> <strong>size_t d_nextToken__</strong>:<br/>
       A pending token. 
        Do not modify.
    <li> <strong>size_t d_requiredTokens__</strong>:<br/>
       Defines the minimum number of accepted tokens that the <em>parse</em>
        function must have processed before a syntactic error can be
        generated. 
    <li> <strong>int d_state__</strong>:<br/>
       The current parsing state. 
        Do not modify.
    <li> <strong>int d_token__</strong>:<br/>
       The current token.
        Do not modify.
    <li> <strong>STYPE__ d_val__</strong>:<br/>
       The semantic value of a returned token or non-terminal symbol. With
        non-terminal tokens it is assigned a value through the action rule's
        symbol <em>$$</em>. Lexical scanners may be offered the facility to assign
        a semantic value to this variable in parallel with a returned
        token. In order to allow a scanner access to <em>d_val__</em>,
        <em>d_val__</em>'s address should be passed to the scanner. This can be
        realized, for example, by passing <em>d_val__</em>'s address to the lexical
        scanner's constructor.
       Subsequently, the lexical scanner may assign a value to the parser's
        <em>d_val__</em> variable through the pointer to <em>d_val__</em> stored in a
        data member of the lexical scanner.
       Note that in some cases this approach <em>must</em> be used to make
        available the correct semantic value to the parser. In particular,
        when a grammar state defines multiple reductions, depending on the
        next token, the reduction's action only takes place following the
        retrieval of the next token, thus losing the initially matched token
        text. 
       If <em>STYPE</em> is a polymorphic semantic value, direct assignment of
        values to <em>d_val__</em> is not possible. In that case <em>tagged
        assignment</em> must be 
        used.
<p>
<li> <strong>LTYPE__ d_vsp__</strong>:<br/>
       The semantic value stack pointer. 
        Do not modify.
    </ul>
<p>
<h2>10. TYPES AND VARIABLES IN THE ANONYMOUS NAMESPACE</h2>
<p>
    In the file defining the <em>parse</em> function the following types and
variables are defined in the anonymous namespace. These are mentioned here for
the sake of completeness, and are not normally accessible to other parts of
the parser.
<p>
<ul>
    <li> <strong>char const author[]</strong>:<br/>
       Defining the name and e-mail address of <strong>Bisonc++</strong>'s author.
    <li> <strong>ReservedTokens</strong>:<br/>
       This enumeration defines some token values used internally by the
        parsing functions. They are:
        <pre>

    PARSE_ACCEPT   =  0,
    _UNDETERMINED_ = -2,
    _EOF_          = -1,
    _error_        = 256,
       
</pre>

       These tokens are used by the parser to determine whether another token
        should be requested from the lexical scanner, and to handle
        error-conditions. 
    <li> <strong>StateType</strong>:<br/>
       This enumeration defines several moe token values used internally by
        the parsing functions. They are:
        <pre>

        NORMAL,
        ERR_ITEM,
        REQ_TOKEN,
        ERR_REQ,    // ERR_ITEM | REQ_TOKEN
        DEF_RED,    // state having default reduction
        ERR_DEF,    // ERR_ITEM | DEF_RED
        REQ_DEF,    // REQ_TOKEN | DEF_RED
        ERR_REQ_DEF // ERR_ITEM | REQ_TOKEN | DEF_RED
       
</pre>

       These tokens are used by the parser to define the types of the various
        states of the analyzed grammar.
    <li> <strong>PI__</strong> (Production Info):<br/>
       This <em>struct</em> provides information about production rules. It has two
        fields: <em>d_nonTerm</em> is the identification number of the production's
        non-terminal, <em>d_size</em> represents the number of elements of the
        productin rule.
    <li> <strong>static PI__ s_productionInfo</strong>:<br/>
       Used internally by the parsing function.
    <li> <strong>SR__</strong> (Shift-Reduce Info):<br/>
       This <em>struct</em> provides the shift/reduce information for the various
        grammatic states. <em>SR__</em> values are collected in arrays, one array
        per grammatic state. These array, named <em>s_</em><em>&lt;nr&gt;</em>, 
        where tt&lt;nr&gt; is a state number are defined in the anonymous namespace
        as well. The <em>SR__</em> elements consist of two unions,
        defining fields that are applicable to, respectively, the first,
        intermediate and the last array elements.<br/>
       The first element of each array consists of (1st field) a <em>StateType</em>
        and (2nd field) the index of the last array element;
       intermediate elements consist of (1st field) a symbol value and (2nd
        field) (if negative) the production rule number reducing to the
        indicated symbol value or (if positive) the next state when the symbol
        given in the 1st field is the current token; 
       the last element of each array consists of (1st field) a placeholder for
        the current token and (2nd field) the (negative) rule number to reduce
        to by default or the (positive) number of an error-state to go to when
        an erroneous token has been retrieved. If the 2nd field is zero, no
        error or default action has been defined for the state, and
        error-recovery is attepted.
    <li> <strong>STACK_EXPANSION</strong>:<br/>
       An enumeration value specifying the number of additional elements that
        are added to the state- and semantic value stacks when full.
    <li> <strong>static SR__ s_&lt;nr&gt;[]</strong>:<br/>
       Here, <em>&lt;nr&gt;</em> is a numerical value representing a state number.
       Used internally by the parsing function.
    <li> <strong>static SR__ *s_state[]</strong>:<br/>
       Used internally by the parsing function.
    </ul>
<p>
<h2>11. RESTRICTIONS ON TOKEN NAMES</h2>
<p>
To avoid collisions with names defined by the parser's (base) class, the
following identifiers should not be used as token names:
    <ul>
    <li> Identifiers ending in two underscores;
    <li> Any of the following identifiers: <em>ABORT, ACCEPT, ERROR, clearin,
        debug</em>, or <em>setDebug</em>.
    </ul>
<p>
<h2>12. OBSOLETE SYMBOLS</h2>
<p>
All <strong>DECLARATIONS</strong> and <strong>DEFINE</strong> symbols not listed above but defined
in <strong>bison++</strong> are obsolete with <strong>bisonc++</strong>. In particular, there is no <em>%header{
... %}</em> section anymore. Also, all <strong>DEFINE</strong> symbols related to member
functions are now obsolete. There is no need for these symbols anymore as they
can simply be declared in the class header file and defined elsewhere.
<p>
<h2>13. EXAMPLE</h2>
<p>
Using a fairly worn-out example, we'll construct a simple calculator
below. The basic operators as well as parentheses can be used to specify
expressions, and each expression should be terminated by a newline. The
program terminates when a <em>q</em> is entered. Empty lines result in a mere
prompt. 
<p>
First an associated grammar is constructed. When a syntactic error is
encountered all tokens are skipped until then next newline and a simple
message is printed using the default <em>error</em> function. It is assumed that
no semantic errors occur (in particular, no divisions by zero). The grammar is
decorated with actions performed when the corresponding grammatical production
rule is recognized. The grammar itself is rather standard and straightforward,
but note the first part of the specification file, containing various other
directives, among which the <em>%scanner</em> directive, resulting in a
composed <em>d_scanner</em> object as well as an implementation of the member
function <em>int lex</em>. In this example, a common <em>Scanner</em> class
construction strategy was used: the class <em>Scanner</em> was derived from the
class <em>yyFlexLexer</em> generated by <strong>flex++</strong>(1). The actual process of
constructing a class using <strong>flex++</strong>(1) is beyond the scope of this man-page,
but <strong>flex++</strong>(1)'s specification file is mentioned below, to further complete
the example. Here is <strong>bisonc++</strong>'s input file:
<p>
<pre>
%filenames parser
%scanner ../scanner/scanner.h

                                // lowest precedence
%token  NUMBER                  // integral numbers
        EOLN                    // newline

%left   '+' '-' 
%left   '*' '/' 
%right  UNARY
                                // highest precedence 

%%

expressions:
    expressions  evaluate
|
    prompt
;

evaluate:
    alternative prompt
;

prompt:
    {
        prompt();
    }
;

alternative:
    expression EOLN
    {
        cout &lt;&lt; $1 &lt;&lt; endl;
    }
|
    'q' done
|
    EOLN
|
    error EOLN
;

done:
    {
        cout &lt;&lt; "Done.\n";
        ACCEPT();
    }
;

expression:
    expression '+' expression
    {
        $$ = $1 + $3;
    }
|
    expression '-' expression
    {
        $$ = $1 - $3;
    }
|
    expression '*' expression
    {
        $$ = $1 * $3;
    }
|
    expression '/' expression
    {
        $$ = $1 / $3;
    }
|
    '-' expression      %prec UNARY
    {
        $$ = -$2;
    }
|
    '+' expression      %prec UNARY
    {
        $$ = $2;
    }
|
    '(' expression ')'
    {
        $$ = $2;
    }
|
    NUMBER
    {
        $$ = stoul(d_scanner.matched());
    }
;
</pre>

<p>
Next, <strong>bisonc++</strong> processes this file. In the process, <strong>bisonc++</strong> generates the
following files from its skeletons:
    <ul>
    <li> The parser's base class, which should not be modified by the
         programmer: 
<p>
<pre>
// Generated by Bisonc++ V4.01.02 on Wed, 06 Mar 2013 15:26:21 +0100

#ifndef ParserBase_h_included
#define ParserBase_h_included

#include &lt;vector&gt;
#include &lt;iostream&gt;


namespace // anonymous
{
    struct PI__;
}



class ParserBase
{
    public:
// $insert tokens

    // Symbolic tokens:
    enum Tokens__
    {
        NUMBER = 257,
        EOLN,
        UNARY,
    };

// $insert STYPE
typedef int STYPE__;

    private:
        int d_stackIdx__;
        std::vector&lt;size_t&gt;   d_stateStack__;
        std::vector&lt;STYPE__&gt;  d_valueStack__;

    protected:
        enum Return__
        {
            PARSE_ACCEPT__ = 0,   // values used as parse()'s return values
            PARSE_ABORT__  = 1
        };
        enum ErrorRecovery__
        {
            DEFAULT_RECOVERY_MODE__,
            UNEXPECTED_TOKEN__,
        };
        bool        d_debug__;
        size_t      d_nErrors__;
        size_t      d_requiredTokens__;
        size_t      d_acceptedTokens__;
        int         d_token__;
        int         d_nextToken__;
        size_t      d_state__;
        STYPE__    *d_vsp__;
        STYPE__     d_val__;
        STYPE__     d_nextVal__;

        ParserBase();

        void ABORT() const;
        void ACCEPT() const;
        void ERROR() const;
        void clearin();
        bool debug() const;
        void pop__(size_t count = 1);
        void push__(size_t nextState);
        void popToken__();
        void pushToken__(int token);
        void reduce__(PI__ const &amp;productionInfo);
        void errorVerbose__();
        size_t top__() const;

    public:
        void setDebug(bool mode);
}; 

inline bool ParserBase::debug() const
{
    return d_debug__;
}

inline void ParserBase::setDebug(bool mode)
{
    d_debug__ = mode;
}

inline void ParserBase::ABORT() const
{
    throw PARSE_ABORT__;
}

inline void ParserBase::ACCEPT() const
{
    throw PARSE_ACCEPT__;
}

inline void ParserBase::ERROR() const
{
    throw UNEXPECTED_TOKEN__;
}


// As a convenience, when including ParserBase.h its symbols are available as
// symbols in the class Parser, too.
#define Parser ParserBase


#endif


</pre>

<p>
<li> The parser class <em>parser.h</em> itself. In the grammar
specification various member functions are used (e.g., <em>done</em>) and
<em>prompt</em>. These functions are so small that they can very well be
implemented inline. Note that <em>done</em> calls <em>ACCEPT</em> to terminate
further parsing. <em>ACCEPT</em> and related members (e.g., <em>ABORT</em>) can be
called from any member called by <em>parse</em>. As a consequence, action blocks
could contain mere function calls, rather than several statements, thus
minimizing the need to rerun <strong>bisonc++</strong> when an action is modified.
<p>
Once <strong>bisonc++</strong> had created <em>parser.h</em> it was augmented with the required
additional members, resulting in the following final version:
<p>
<pre>
#ifndef Parser_h_included
#define Parser_h_included

// $insert baseclass
#include "parserbase.h"
// $insert scanner.h
#include "../scanner/scanner.h"


#undef Parser
class Parser: public ParserBase
{
    // $insert scannerobject
    Scanner d_scanner;
        
    public:
        int parse();

    private:
        void error(char const *msg);
        int lex();                  
                                    
        void print();               
        void prompt();
        void done();

    // support functions for parse():
        void executeAction(int ruleNr);
        void errorRecovery();
        int lookup(bool recovery);
        void nextToken();
        void print__();
};

inline void Parser::prompt()
{
    std::cout &lt;&lt; "? " &lt;&lt; std::flush;
}

inline void Parser::done()
{
    std::cout &lt;&lt; "Done\n";
    ACCEPT();
}

#endif
</pre>

<p>
<li> To complete the example, the following lexical scanner specification
was used:
<p>
<pre>
%interactive
%filenames scanner

%%

[ \t]+                          // skip white space

\n                              return Parser::EOLN;

[0-9]+                          return Parser::NUMBER;

.                               return matched()[0];


%%


</pre>

<p>
<li> Since no member functions other than <em>parse</em> were defined in
separate source files, only <em>parse</em> includes <em>parser.ih</em>. Since
<em>cerr</em> is used in the grammar's actions, a <em>using namespace
std</em> or comparable statement is required. This was effectuated from
<em>parser.ih</em> Here is the implementation header declaring the standard
namespace:
<p>
<pre>
// Generated by Bisonc++ V4.01.02 on Wed, 06 Mar 2013 15:10:36 +0100

    // Include this file in the sources of the class Parser.

// $insert class.h
#include "parser.h"


inline void Parser::error(char const *msg)
{
    std::cerr &lt;&lt; msg &lt;&lt; '\n';
}

// $insert lex
inline int Parser::lex()
{
    return d_scanner.lex();
}

inline void Parser::print()         
{
    print__();           // displays tokens if --print was specified
}


    // Add here includes that are only required for the compilation 
    // of Parser's sources.



    // UN-comment the next using-declaration if you want to use
    // int Parser's sources symbols from the namespace std without
    // specifying std::

using namespace std;
</pre>

<p>
The implementation of the parsing member function <em>parse</em> is basically
irrelevant, since it should not be modified by the programmer. It was written
on the file <em>parse.cc</em>.
    <li> Finally, here is the program offering our simple calculator:
<p>
<pre>
#include "parser/parser.h"

int main()
{
    Parser calculator;
    return calculator.parse();
}
</pre>

    </ul>
<p>
<h2>14. USING PARSER-CLASS SYMBOLS IN LEXICAL SCANNERS</h2>
<p>
Note here that although the file <em>parserbase.h</em>, defining the
parser class' base-class, rather than the header file <em>parser.h</em>
defining the parser class is included, the lexical scanner may simply return
tokens of the class <em>Parser</em> (e.g., <em>Parser::NUMBER</em> rather than
<em>ParserBase::NUMBER</em>). In fact, using a simple <em>#define - #undef</em>
pair generated by the <strong>bisonc++</strong> respectively at the end of the base class header
the file and just before the definition of the parser class itself it is
the possible to assume in the lexical scanner that all symbols defined in the
the parser's base class are actually defined in the parser class itself. It
the should be noted that this feature can only be used to access base class
the <em>enum</em> and types. The actual parser class is not available by the time
the the lexical scanner is defined, thus avoiding circular class dependencies.
<p>
<h2>15. FILES</h2>
    <ul>
    <li> <strong>bisonc++base.h</strong>: skeleton of the parser's base class;
    <li> <strong>bisonc++.h</strong>: skeleton of the parser class;
    <li> <strong>bisonc++.ih</strong>: skeleton of the implementation header;
    <li> <strong>bisonc++.cc</strong>: skeleton of the member <em>parse</em>;
    <li> <strong>bisonc++polymorphic</strong>: skeleton of the declarations used by
        <em>%polymorphic</em>;
    <li> <strong>bisonc++polymorphic.inline</strong>: skeleton of the inline
        implementations of the members declared in <strong>bisonc++polymorphic</strong>.
    </ul>
<p>
<h2>16. SEE ALSO</h2>
    <strong>bison</strong>(1), <strong>bison++</strong>(1), <strong>bison.info</strong> (using texinfo),
    <strong>flex++</strong>(1)
<p>
Lakos, J. (2001) <strong>Large Scale C++ Software Design</strong>, Addison Wesley.<br/>
    Aho, A.V., Sethi, R., Ullman, J.D. (1986) <strong>Compilers</strong>, Addison Wesley.
<p>
<h2>17. BUGS</h2>
<p>
Parser-class header files (e.g., Parser.h) and parser-class internal
    header files (e.g., Parser.ih) generated with bisonc++ &lt; 4.02.00 require
    two hand-modifications when used in combination with bisonc++ &gt;=
    4.02.00. See the description of <em>exceptionHandler__</em> for details.
<p>
Discontinued options:
    <ul>
        <li> <strong>--include-only</strong>
        <li> <strong>--namespace</strong>
    </ul>
<p>
To avoid collisions with names defined by the parser's (base) class, the
following identifiers should not be used as token nams:
    <ul>
    <li> Identifiers ending in two underscores;
    <li> Any of the following identifiers: <em>ABORT, ACCEPT, ERROR, clearin,
        debug, error</em>, or <em>setDebug</em>.
    </ul>
<p>
When re-using files generated by <strong>bisonc++</strong> before version 2.0.0, minor
hand-modification might be necessary. The identifiers in the following list
(defined in the parser's base class) now have two underscores affixed to them:
<em>LTYPE, STYPE</em> and <em>Tokens</em>. When using classes derived from the generated
parser class, the following identifiers are available in such derived classes:
<em>DEFAULT_RECOVERY_MODE, ErrorRecovery, Return, UNEXPECTED_TOKEN, d_debug,
d_loc, d_lsp, d_nErrors, d_nextToken, d_state, d_token, d_val</em>, and <em>d_vsp</em>.
When used in derived classes, they too need two underscores affixed to them.
<p>
The member function <em>void lookup</em> (&lt; 1.00) was replaced by <em>int
lookup</em>. When regenerating parsers created by early versions of <strong>bisonc++</strong>
(versions before version 1.00), <em>lookup</em>'s prototype should be corrected by
hand, since <strong>bisonc++</strong> will not by itself rewrite the parser class's header
file.
<p>
The <em>Semantic</em> parser, mentioned in <strong>bison++</strong>(1) is not implemented in
<strong>bisonc++</strong>(1). According to <strong>bison++</strong>(1) the semantic parser was not
available in <strong>bison++</strong> either. It is possible that the <em>Pure</em> parser is
now available through the <em>--thread-safe</em> option.
<p>
<h2>18. ABOUT bisonc++</h2>
<p>
<strong>Bisonc++</strong> was based on <strong>bison++</strong>, originally developed by Alain
Coetmeur (coetmeur@icdc.fr), R&amp;D department (RDT), Informatique-CDC, France,
who based his work on <strong>bison</strong>, GNU version 1.21. 
<p>
<strong>Bisonc++</strong> version 0.98 and beyond is a complete rewrite of an LALR-1 parser
generator, closely following the construction process as described in Aho,
Sethi and Ullman's (1986) book <strong>Compilers</strong> (i.e., the <em>Dragon book</em>).  It
uses the same grammar specification as <strong>bison</strong> and <strong>bison++</strong>, and it uses
practically the same options and directives as <strong>bisonc++</strong> versions earlier than
0.98. Variables, declarations and macros that are obsolete were removed. 
<p>
<h2>AUTHOR</h2>
<p>
Frank B. Brokken (f.b.brokken@rug.nl).
